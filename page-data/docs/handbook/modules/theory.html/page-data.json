{"componentChunkName":"component---src-templates-documentation-tsx","path":"/docs/handbook/modules/theory.html","result":{"data":{"markdownRemark":{"id":"57dcda0f-e694-52c7-a93f-49d8615d8432","excerpt":"Scripts and modules in JavaScript In the early days of JavaScript, when the language only ran in browsers, there were no modules, but it was still possible to‚Ä¶","html":"<h2 id=\"scripts-and-modules-in-javascript\" style=\"position:relative;\"><a href=\"#scripts-and-modules-in-javascript\" aria-label=\"scripts and modules in javascript permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Scripts and modules in JavaScript</h2>\n<p>In the early days of JavaScript, when the language only ran in browsers, there were no modules, but it was still possible to split the JavaScript for a web page into multiple files by using multiple <code>script</code> tags in HTML:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">html</div><div class='code-container'><code><div class='line'><span style=\"color: #800000\">&lt;html&gt;</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #800000\">&lt;head&gt;</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #800000\">&lt;script</span><span style=\"color: #000000FF\"> </span><span style=\"color: #EE0000\">src</span><span style=\"color: #000000FF\">=</span><span style=\"color: #0000FF\">\"a.js\"</span><span style=\"color: #800000\">&gt;&lt;/script&gt;</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #800000\">&lt;script</span><span style=\"color: #000000FF\"> </span><span style=\"color: #EE0000\">src</span><span style=\"color: #000000FF\">=</span><span style=\"color: #0000FF\">\"b.js\"</span><span style=\"color: #800000\">&gt;&lt;/script&gt;</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #800000\">&lt;/head&gt;</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #800000\">&lt;body&gt;&lt;/body&gt;</span></div><div class='line'><span style=\"color: #800000\">&lt;/html&gt;</span></div></code></div></pre>\n<p>This approach had some downsides, especially as web pages grew larger and more complex. In particular, all scripts loaded onto the same page share the same scope‚Äîappropriately called the ‚Äúglobal scope‚Äù‚Äîmeaning the scripts had to be very careful not to overwrite each others‚Äô variables and functions.</p>\n<p>Any system that solves this problem by giving files their own scope while still providing a way to make bits of code available to other files can be called a ‚Äúmodule system.‚Äù (It may sound obvious to say that each file in a module system is called a ‚Äúmodule,‚Äù but the term is often used to contrast with <em>script</em> files, which run outside a module system, in a global scope.)</p>\n<blockquote>\n<p>There are <a href=\"https://github.com/myshov/history-of-javascript/tree/master/4_evolution_of_js_modularity\">many module systems</a>, and TypeScript <a href=\"https://www.typescriptlang.org/tsconfig/#module\">supports emitting several</a>, but this documentation will focus on the two most important systems today: ECMAScript modules (ESM) and CommonJS (CJS).</p>\n<p>ECMAScript Modules (ESM) is the module system built into the language, supported in modern browsers and in Node.js since v12. It uses dedicated <code>import</code> and <code>export</code> syntax:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">js</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// a.js</span></div><div class='line'><span style=\"color: #AF00DB\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">default</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"Hello from a.js\"</span><span style=\"color: #000000\">;</span></div></code></div></pre>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">js</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// b.js</span></div><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">a</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./a.js\"</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">a</span><span style=\"color: #000000\">); </span><span style=\"color: #008000\">// 'Hello from a.js'</span></div></code></div></pre>\n<p>CommonJS (CJS) is the module system that originally shipped in Node.js, before ESM was part of the language specification. It‚Äôs still supported in Node.js alongside ESM. It uses plain JavaScript objects and functions named <code>exports</code> and <code>require</code>:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">js</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// a.js</span></div><div class='line'><span style=\"color: #1C6277\">exports</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">message</span><span style=\"color: #000000\"> = </span><span style=\"color: #A31515\">\"Hello from a.js\"</span><span style=\"color: #000000\">;</span></div></code></div></pre>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">js</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// b.js</span></div><div class='line'><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #0070C1\">a</span><span style=\"color: #000000\"> = </span><span style=\"color: #795E26\">require</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">\"./a\"</span><span style=\"color: #000000\">);</span></div><div class='line'><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">a</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">message</span><span style=\"color: #000000\">); </span><span style=\"color: #008000\">// 'Hello from a.js'</span></div></code></div></pre>\n</blockquote>\n<p>Accordingly, when TypeScript detects that a file is a CommonJS or ECMAScript module, it starts by assuming that file will have its own scope. Beyond that, though, the compiler‚Äôs job gets a little more complicated.</p>\n<h2 id=\"typescripts-job-concerning-modules\" style=\"position:relative;\"><a href=\"#typescripts-job-concerning-modules\" aria-label=\"typescripts job concerning modules permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TypeScript‚Äôs job concerning modules</h2>\n<p>The TypeScript compiler‚Äôs chief goal is to prevent certain kinds of runtime errors by catching them at compile time. With or without modules involved, the compiler needs to know about the code‚Äôs intended runtime environment‚Äîwhat globals are available, for example. When modules are involved, there are several additional questions the compiler needs to answer in order to do its job. Let‚Äôs use a few lines of input code as an example to think about all the information needed to analyze it:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">sayHello</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"greetings\"</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #795E26\">sayHello</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">\"world\"</span><span style=\"color: #000000\">);</span></div></code></div></pre>\n<p>To check this file, the compiler needs to know the type of <code>sayHello</code> (is it a function that can accept one string argument?), which opens quite a few additional questions:</p>\n<ol>\n<li>Will the module system load this TypeScript file directly, or will it load a JavaScript file that I (or another compiler) generate from this TypeScript file?</li>\n<li>What <em>kind</em> of module does the module system expect to find, given the file name it will load and its location on disk?</li>\n<li>If output JavaScript is being emitted, how will the module syntax present in this file be transformed in the output code?</li>\n<li>Where will the module system look to find the module specified by <code>\"greetings\"</code>? Will the lookup succeed?</li>\n<li>What kind of module is the file resolved by that lookup?</li>\n<li>Does the module system allow the kind of module detected in (2) to reference the kind of module detected in (5) with the syntax decided in (3)?</li>\n<li>Once the <code>\"greetings\"</code> module has been analyzed, what piece of that module is bound to <code>sayHello</code>?</li>\n</ol>\n<p>Notice that all of these questions depend on characteristics of the <em>host</em>‚Äîthe system that ultimately consumes the output JavaScript (or raw TypeScript, as the case may be) to direct its module loading behavior, typically either a runtime (like Node.js) or bundler (like Webpack).</p>\n<p>The ECMAScript specification defines how ESM imports and exports link up with each other, but it doesn‚Äôt specify how the file lookup in (4), known as <em>module resolution</em>, happens, and it doesn‚Äôt say anything about other module systems like CommonJS. So runtimes and bundlers, especially those that want to support both ESM and CJS, have a lot of freedom to design their own rules. Consequently, the way TypeScript should answer the questions above can vary dramatically depending on where the code is intended to run. There‚Äôs no single right answer, so the compiler must be told the rules through configuration options.</p>\n<p>The other key idea to keep in mind is that TypeScript almost always thinks about these questions in terms of its <em>output</em> JavaScript files, not its <em>input</em> TypeScript (or JavaScript!) files. Today, some runtimes and bundlers support loading TypeScript files directly, and in those cases, it doesn‚Äôt make sense to think about separate input and output files. Most of this document discusses cases where TypeScript files are compiled to JavaScript files, which in turn are loaded by the runtime module system. Examining these cases is essential for building an understanding of the compiler‚Äôs options and behavior‚Äîit‚Äôs easier to start there and simplify when thinking about esbuild, Bun, and other <a href=\"#module-resolution-for-bundlers-typescript-runtimes-and-nodejs-loaders\">TypeScript-first runtimes and bundlers</a>. So for now, we can summarize TypeScript‚Äôs job when it comes to modules in terms of output files:</p>\n<p>Understand the <strong>rules of the host</strong> enough</p>\n<ol>\n<li>to compile files into a valid <strong>output module format</strong>,</li>\n<li>to ensure that imports in those <strong>outputs</strong> will <strong>resolve successfully</strong>, and</li>\n<li>to know what <strong>type</strong> to assign to <strong>imported names</strong>.</li>\n</ol>\n<h2 id=\"who-is-the-host\" style=\"position:relative;\"><a href=\"#who-is-the-host\" aria-label=\"who is the host permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Who is the host?</h2>\n<p>Before we move on, it‚Äôs worth making sure we‚Äôre on the same page about the term <em>host</em>, because it will come up frequently. We defined it before as ‚Äúthe system that ultimately consumes the output code to direct its module loading behavior.‚Äù In other words, it‚Äôs the system outside of TypeScript that TypeScript‚Äôs module analysis tries to model:</p>\n<ul>\n<li>When the output code (whether produced by <code>tsc</code> or a third-party transpiler) is run directly in a runtime like Node.js, the runtime is the host.</li>\n<li>When there is no ‚Äúoutput code‚Äù because a runtime consumes TypeScript files directly, the runtime is still the host.</li>\n<li>When a bundler consumes TypeScript inputs or outputs and produces a bundle, the bundler is the host, because it looked at the original set of imports/requires, looked up what files they referenced, and produced a new file or set of files where the original imports and requires are erased or transformed beyond recognition. (That bundle itself might comprise modules, and the runtime that runs it will be its host, but TypeScript doesn‚Äôt know about anything that happens post-bundler.)</li>\n<li>If another transpiler, optimizer, or formatter runs on TypeScript‚Äôs outputs, it‚Äôs <em>not</em> a host that TypeScript cares about, as long as it leaves the imports and exports it sees alone.</li>\n<li>When loading modules in a web browser, the behaviors TypeScript needs to model are actually split between the web server and the module system running in the browser. The browser‚Äôs JavaScript engine (or a script-based module-loading framework like RequireJS) controls what module formats are accepted, while the web server decides what file to send when one module triggers a request to load another.</li>\n<li>The TypeScript compiler itself is not a host, because it does not provide any behavior related to modules beyond trying to model other hosts.</li>\n</ul>\n<h2 id=\"the-module-output-format\" style=\"position:relative;\"><a href=\"#the-module-output-format\" aria-label=\"the module output format permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The module output format</h2>\n<p>In any project, the first question about modules we need to answer is what kinds of modules the host expects, so TypeScript can set its output format for each file to match. Sometimes, the host only <em>supports</em> one kind of module‚ÄîESM in the browser, or CJS in Node.js v11 and earlier, for example. Node.js v12 and later accepts both CJS and ES modules, but uses file extensions and <code>package.json</code> files to determine what format each file should be, and throws an error if the file‚Äôs contents don‚Äôt match the expected format.</p>\n<p>The <code>module</code> compiler option provides this information to the compiler. Its primary purpose is to control the module format of any JavaScript that gets emitted during compilation, but it also serves to inform the compiler about how the module kind of each file should be detected, how different module kinds are allowed to import each other, and whether features like <code>import.meta</code> and top-level <code>await</code> are available. So, even if a TypeScript project is using <code>noEmit</code>, choosing the right setting for <code>module</code> still matters. As we established earlier, the compiler needs an accurate understanding of the module system so it can type check (and provide IntelliSense for) imports. See <a href=\"/docs/handbook/modules/guides/choosing-compiler-options.html\"><em>Choosing compiler options</em></a> for guidance on choosing the right <code>module</code> setting for your project.</p>\n<p>The available <code>module</code> settings are</p>\n<ul>\n<li><a href=\"/docs/handbook/modules/reference.html#node16-nodenext\"><strong><code>node16</code></strong></a>: Reflects the module system of Node.js v16+, which supports ES modules and CJS modules side-by-side with particular interoperability and detection rules.</li>\n<li><a href=\"/docs/handbook/modules/reference.html#node16-nodenext\"><strong><code>nodenext</code></strong></a>: Currently identical to <code>node16</code>, but will be a moving target reflecting the latest Node.js versions as Node.js‚Äôs module system evolves.</li>\n<li><a href=\"/docs/handbook/modules/reference.html#es2015-es2020-es2022-esnext\"><strong><code>es2015</code></strong></a>: Reflects the ES2015 language specification for JavaScript modules (the version that first introduced <code>import</code> and <code>export</code> to the language).</li>\n<li><a href=\"/docs/handbook/modules/reference.html#es2015-es2020-es2022-esnext\"><strong><code>es2020</code></strong></a>: Adds support for <code>import.meta</code> and <code>export * as ns from \"mod\"</code> to <code>es2015</code>.</li>\n<li><a href=\"/docs/handbook/modules/reference.html#es2015-es2020-es2022-esnext\"><strong><code>es2022</code></strong></a>: Adds support for top-level <code>await</code> to <code>es2020</code>.</li>\n<li><a href=\"/docs/handbook/modules/reference.html#es2015-es2020-es2022-esnext\"><strong><code>esnext</code></strong></a>: Currently identical to <code>es2022</code>, but will be a moving target reflecting the latest ECMAScript specifications, as well as module-related Stage 3+ proposals that are expected to be included in upcoming specification versions.</li>\n<li><strong><a href=\"/docs/handbook/modules/reference.html#commonjs\"><code>commonjs</code></a>, <a href=\"/docs/handbook/modules/reference.html#system\"><code>system</code></a>, <a href=\"/docs/handbook/modules/reference.html#amd\"><code>amd</code></a>, and <a href=\"/docs/handbook/modules/reference.html#umd\"><code>umd</code></a></strong>: Each emits everything in the module system named, and assumes everything can be successfully imported into that module system. These are no longer recommended for new projects and will not be covered in detail by this documentation.</li>\n</ul>\n<blockquote>\n<p>Node.js‚Äôs rules for module format detection and interoperability make it incorrect to specify <code>module</code> as <code>esnext</code> or <code>commonjs</code> for projects that run in Node.js, even if all files emitted by <code>tsc</code> are ESM or CJS, respectively. The only correct <code>module</code> settings for projects that intend to run in Node.js are <code>node16</code> and <code>nodenext</code>. While the emitted JavaScript for an all-ESM Node.js project might look identical between compilations using <code>esnext</code> and <code>nodenext</code>, the type checking can differ. See the <a href=\"/docs/handbook/modules/reference.html#node16-nodenext\">reference section on <code>nodenext</code></a> for more details.</p>\n</blockquote>\n<h3 id=\"module-format-detection\" style=\"position:relative;\"><a href=\"#module-format-detection\" aria-label=\"module format detection permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Module format detection</h3>\n<p>Node.js understands both ES modules and CJS modules, but the format of each file is determined by its file extension and the <code>type</code> field of the first <code>package.json</code> file found in a search of the file‚Äôs directory and all ancestor directories:</p>\n<ul>\n<li><code>.mjs</code> and <code>.cjs</code> files are always interpreted as ES modules and CJS modules, respectively.</li>\n<li><code>.js</code> files are interpreted as ES modules if the nearest <code>package.json</code> file contains a <code>type</code> field with the value <code>\"module\"</code>. If there is no <code>package.json</code> file, or if the <code>type</code> field is missing or has any other value, <code>.js</code> files are interpreted as CJS modules.</li>\n</ul>\n<p>If a file is determined to be an ES module by these rules, Node.js will not inject the CommonJS <code>module</code> and <code>require</code> objects into the file‚Äôs scope during evaluation, so a file that tries to use them will cause a crash. Conversely, if a file is determined to be a CJS module, <code>import</code> and <code>export</code> declarations in the file will cause a syntax error crash.</p>\n<p>When the <code>module</code> compiler option is set to <code>node16</code> or <code>nodenext</code>, TypeScript applies this same algorithm to the project‚Äôs <em>input</em> files to determine the module kind of each corresponding <em>output</em> file. Let‚Äôs look at how module formats are detected in an example project that uses <code>--module nodenext</code>:</p>\n<table>\n<thead>\n<tr>\n<th>Input file name</th>\n<th>Contents</th>\n<th>Output file name</th>\n<th>Module kind</th>\n<th>Reason</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>/package.json</code></td>\n<td><code>{}</code></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>/main.mts</code></td>\n<td></td>\n<td><code>/main.mjs</code></td>\n<td>ESM</td>\n<td>File extension</td>\n</tr>\n<tr>\n<td><code>/utils.cts</code></td>\n<td></td>\n<td><code>/utils.cjs</code></td>\n<td>CJS</td>\n<td>File extension</td>\n</tr>\n<tr>\n<td><code>/example.ts</code></td>\n<td></td>\n<td><code>/example.js</code></td>\n<td>CJS</td>\n<td>No <code>\"type\": \"module\"</code> in <code>package.json</code></td>\n</tr>\n<tr>\n<td><code>/node_modules/pkg/package.json</code></td>\n<td><code>{ \"type\": \"module\" }</code></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><code>/node_modules/pkg/index.d.ts</code></td>\n<td></td>\n<td></td>\n<td>ESM</td>\n<td><code>\"type\": \"module\"</code> in <code>package.json</code></td>\n</tr>\n<tr>\n<td><code>/node_modules/pkg/index.d.cts</code></td>\n<td></td>\n<td></td>\n<td>CJS</td>\n<td>File extension</td>\n</tr>\n</tbody>\n</table>\n<p>When the input file extension is <code>.mts</code> or <code>.cts</code>, TypeScript knows to treat that file as an ES module or CJS module, respectively, because Node.js will treat the output <code>.mjs</code> file as an ES module or the output <code>.cjs</code> file as a CJS module. When the input file extension is <code>.ts</code>, TypeScript has to consult the nearest <code>package.json</code> file to determine the module format, because this is what Node.js will do when it encounters the output <code>.js</code> file. (Notice that the same rules apply to the <code>.d.cts</code> and <code>.d.ts</code> declaration files in the <code>pkg</code> dependency: though they will not produce an output file as part of this compilation, the presence of a <code>.d.ts</code> file <em>implies</em> the existence of a corresponding <code>.js</code> file‚Äîperhaps created when the author of the <code>pkg</code> library ran <code>tsc</code> on an input <code>.ts</code> file of their own‚Äîwhich Node.js must interpret as an ES module, due to its <code>.js</code> extension and the presence of the <code>\"type\": \"module\"</code> field in <code>/node_modules/pkg/package.json</code>. Declaration files are covered in more detail in a <a href=\"#the-role-of-declaration-files\">later section</a>.)</p>\n<p>The detected module format of input files is used by TypeScript to ensure it emits the output syntax that Node.js expects in each output file. If TypeScript were to emit <code>/example.js</code> with <code>import</code> and <code>export</code> statements in it, Node.js would crash when parsing the file. If TypeScript were to emit <code>/main.mjs</code> with <code>require</code> calls, Node.js would crash during evaluation. Beyond emit, the module format is also used to determine rules for type checking and module resolution, which we‚Äôll discuss in the following sections.</p>\n<p>It‚Äôs worth mentioning again that TypeScript‚Äôs behavior in <code>--module node16</code> and <code>--module nodenext</code> is entirely motivated by Node.js‚Äôs behavior. Since TypeScript‚Äôs goal is to catch potential runtime errors at compile time, it needs a very accurate model of what will happen at runtime. This fairly complex set of rules for module kind detection is <em>necessary</em> for checking code that will run in Node.js, but may be overly strict or just incorrect if applied to non-Node.js hosts.</p>\n<h3 id=\"input-module-syntax\" style=\"position:relative;\"><a href=\"#input-module-syntax\" aria-label=\"input module syntax permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Input module syntax</h3>\n<p>It‚Äôs important to note that the <em>input</em> module syntax seen in input source files is somewhat decoupled from the output module syntax emitted to JS files. That is, a file with an ESM import:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> { </span><span style=\"color: #001080\">sayHello</span><span style=\"color: #000000\"> } </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"greetings\"</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #795E26\">sayHello</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">\"world\"</span><span style=\"color: #000000\">);</span></div></code></div></pre>\n<p>might be emitted in ESM format exactly as-is, or might be emitted as CommonJS:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #1C6277\">Object</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">defineProperty</span><span style=\"color: #000000\">(</span><span style=\"color: #1C6277\">exports</span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\">\"__esModule\"</span><span style=\"color: #000000\">, { </span><span style=\"color: #001080\">value:</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">true</span><span style=\"color: #000000\"> });</span></div><div class='line'><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #0070C1\">greetings_1</span><span style=\"color: #000000\"> = </span><span style=\"color: #795E26\">require</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">\"greetings\"</span><span style=\"color: #000000\">);</span></div><div class='line'><span style=\"color: #000000\">(</span><span style=\"color: #098658\">0</span><span style=\"color: #000000\">, </span><span style=\"color: #001080\">greetings_1</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">sayHello</span><span style=\"color: #000000\">)(</span><span style=\"color: #A31515\">\"world\"</span><span style=\"color: #000000\">);</span></div></code></div></pre>\n<p>depending on the <code>module</code> compiler option (and any applicable <a href=\"#module-format-detection\">module format detection</a> rules, if the <code>module</code> option supports more than one kind of module). In general, this means that looking at the contents of an input file isn‚Äôt enough to determine whether it‚Äôs an ES module or a CJS module.</p>\n<blockquote>\n<p>Today, most TypeScript files are authored using ESM syntax (<code>import</code> and <code>export</code> statements) regardless of the output format. This is largely a legacy of the long road ESM has taken to widespread support. ECMAScript modules were standardized in 2015, were supported in most browsers by 2017, and landed in Node.js v12 in 2019. During much of this window, it was clear that ESM was the future of JavaScript modules, but very few runtimes could consume it. Tools like Babel made it possible for JavaScript to be authored in ESM and downleveled to another module format that could be used in Node.js or browsers. TypeScript followed suit, adding support for ES module syntax and softly discouraging the use of the original CommonJS-inspired <code>import fs = require(\"fs\")</code> syntax in <a href=\"https://devblogs.microsoft.com/typescript/announcing-typescript-1-5/\">the 1.5 release</a>.</p>\n<p>The upside of this ‚Äúauthor ESM, output anything‚Äù strategy was that TypeScript could use standard JavaScript syntax, making the authoring experience familiar to newcomers, and (theoretically) making it easy for projects to start targeting ESM outputs in the future. There are three significant downsides, which became fully apparent only after ESM and CJS modules were allowed to coexist and interoperate in Node.js:</p>\n<ol>\n<li>Early assumptions about how ESM/CJS interoperability would work in Node.js turned out to be wrong, and today, interoperability rules differ between Node.js and bundlers. Consequently, the configuration space for modules in TypeScript is large.</li>\n<li>When the syntax in input files all looks like ESM, it‚Äôs easy for an author or code reviewer to lose track of what kind of module a file is at runtime. And because of Node.js‚Äôs interoperability rules, what kind of module each file is became very important.</li>\n<li>When input files are written in ESM, the syntax in type declaration outputs (<code>.d.ts</code> files) looks like ESM too. But because the corresponding JavaScript files could have been emitted in any module format, TypeScript can‚Äôt tell what kind of module a file is just by looking at the contents of its type declarations. And again, because of the nature of ESM/CJS interoperability, TypeScript <em>has</em> to know what kind of module everything is in order to provide correct types and prevent imports that will crash.</li>\n</ol>\n<p>In TypeScript 5.0, a new compiler option called <code>verbatimModuleSyntax</code> was introduced to help TypeScript authors know exactly how their <code>import</code> and <code>export</code> statements will be emitted. When enabled, the flag requires imports and exports in input files to be written in the form that will undergo the least amount of transformation before emit. So if a file will be emitted as ESM, imports and exports must be written in ESM syntax; if a file will be emitted as CJS, it must be written in the CommonJS-inspired TypeScript syntax (<code>import fs = require(\"fs\")</code> and <code>export = {}</code>). This setting is particularly recommended for Node.js projects that use mostly ESM, but have a select few CJS files. It is not recommended for projects that currently target CJS, but may want to target ESM in the future.</p>\n</blockquote>\n<h3 id=\"esm-and-cjs-interoperability\" style=\"position:relative;\"><a href=\"#esm-and-cjs-interoperability\" aria-label=\"esm and cjs interoperability permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ESM and CJS interoperability</h3>\n<p>Can an ES module <code>import</code> a CommonJS module? If so, does a default import link to <code>exports</code> or <code>exports.default</code>? Can a CommonJS module <code>require</code> an ES module? CommonJS isn‚Äôt part of the ECMAScript specification, so runtimes, bundlers, and transpilers have been free to make up their own answers to these questions since ESM was standardized in 2015, and as such no standard set of interoperability rules exist. Today, most runtimes and bundlers broadly fall into one of three categories:</p>\n<ol>\n<li><strong>ESM-only.</strong> Some runtimes, like browser engines, only support what‚Äôs actually a part of the language: ECMAScript Modules.</li>\n<li><strong>Bundler-like.</strong> Before any major JavaScript engine could run ES modules, Babel allowed developers to write them by transpiling them to CommonJS. The way these ESM-transpiled-to-CJS files interacted with hand-written-CJS files implied a set of permissive interoperability rules that have become the de facto standard for bundlers and transpilers.</li>\n<li><strong>Node.js.</strong> In Node.js, CommonJS modules cannot load ES modules synchronously (with <code>require</code>); they can only load them asynchronously with dynamic <code>import()</code> calls. ES modules can default-import CJS modules, which always binds to <code>exports</code>. (This means that a default import of a Babel-like CJS output with <code>__esModule</code> behaves differently between Node.js and some bundlers.)</li>\n</ol>\n<p>TypeScript needs to know which of these rule sets to assume in order to provide correct types on (particularly <code>default</code>) imports and to error on imports that will crash at runtime. When the <code>module</code> compiler option is set to <code>node16</code> or <code>nodenext</code>, Node.js‚Äôs rules are enforced. All other <code>module</code> settings, combined with the <a href=\"/docs/handbook/modules/reference.html#esModuleInterop\"><code>esModuleInterop</code></a> option, result in bundler-like interop in TypeScript. (While using <code>--module esnext</code> does prevent you from <em>writing</em> CommonJS modules, it does not prevent you from <em>importing</em> them as dependencies. There‚Äôs currently no TypeScript setting that can guard against an ES module importing a CommonJS module, as would be appropriate for direct-to-browser code.)</p>\n<h3 id=\"module-specifiers-are-not-transformed\" style=\"position:relative;\"><a href=\"#module-specifiers-are-not-transformed\" aria-label=\"module specifiers are not transformed permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Module specifiers are not transformed</h3>\n<p>While the <code>module</code> compiler option can transform imports and exports in input files to different module formats in output files, the module <em>specifier</em> (the string <code>from</code> which you <code>import</code>, or pass to <code>require</code>) is always emitted as-written. For example, an input like:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> { </span><span style=\"color: #001080\">add</span><span style=\"color: #000000\"> } </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./math.mjs\"</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #795E26\">add</span><span style=\"color: #000000\">(</span><span style=\"color: #098658\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #098658\">2</span><span style=\"color: #000000\">);</span></div></code></div></pre>\n<p>might be emitted as either:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> { </span><span style=\"color: #001080\">add</span><span style=\"color: #000000\"> } </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./math.mjs\"</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #795E26\">add</span><span style=\"color: #000000\">(</span><span style=\"color: #098658\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #098658\">2</span><span style=\"color: #000000\">);</span></div></code></div></pre>\n<p>or:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #0070C1\">math_1</span><span style=\"color: #000000\"> = </span><span style=\"color: #795E26\">require</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">\"./math.mjs\"</span><span style=\"color: #000000\">);</span></div><div class='line'><span style=\"color: #001080\">math_1</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">add</span><span style=\"color: #000000\">(</span><span style=\"color: #098658\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #098658\">2</span><span style=\"color: #000000\">);</span></div></code></div></pre>\n<p>depending on the <code>module</code> compiler option, but the module specifier will always be <code>\"./math.mjs\"</code>. There is no compiler option that enables transforming, substituting, or rewriting module specifiers. Consequently, module specifiers must be written in a way that works for the code‚Äôs target runtime or bundler, and it‚Äôs TypeScript‚Äôs job to understand those <em>output</em>-relative specifiers. The process of finding the file referenced by a module specifier is called <em>module resolution</em>.</p>\n<h2 id=\"module-resolution\" style=\"position:relative;\"><a href=\"#module-resolution\" aria-label=\"module resolution permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Module resolution</h2>\n<p>Let‚Äôs return to our <a href=\"#typescripts-job-concerning-modules\">first example</a> and review what we‚Äôve learned about it so far:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">sayHello</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"greetings\"</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #795E26\">sayHello</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">\"world\"</span><span style=\"color: #000000\">);</span></div></code></div></pre>\n<p>So far, we‚Äôve discussed how the host‚Äôs module system and TypeScript‚Äôs <code>module</code> compiler option might impact this code. We know that the input syntax looks like ESM, but the output format depends on the <code>module</code> compiler option, potentially the file extension, and <code>package.json</code> <code>\"type\"</code> field. We also know that what <code>sayHello</code> gets bound to, and even whether the import is even allowed, may vary depending on the module kinds of this file and the target file. But we haven‚Äôt yet discussed how to <em>find</em> the target file.</p>\n<h3 id=\"module-resolution-is-host-defined\" style=\"position:relative;\"><a href=\"#module-resolution-is-host-defined\" aria-label=\"module resolution is host defined permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Module resolution is host-defined</h3>\n<p>While the ECMAScript specification defines how to parse and interpret <code>import</code> and <code>export</code> statements, it leaves module resolution up to the host. If you‚Äôre creating a hot new JavaScript runtime, you‚Äôre free to create a module resolution scheme like:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">monkey</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"üêí\"</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// Looks for './eats/bananas.js'</span></div><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">cow</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"üêÑ\"</span><span style=\"color: #000000\">;    </span><span style=\"color: #008000\">// Looks for './eats/grass.js'</span></div><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">lion</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"ü¶Å\"</span><span style=\"color: #000000\">;   </span><span style=\"color: #008000\">// Looks for './eats/you.js'</span></div></code></div></pre>\n<p>and still claim to implement ‚Äústandards-compliant ESM.‚Äù Needless to say, TypeScript would have no idea what types to assign to <code>monkey</code>, <code>cow</code>, and <code>lion</code> without built-in knowledge of this runtime‚Äôs module resolution algorithm. Just as <code>module</code> informs the compiler about the host‚Äôs expected module format, <code>moduleResolution</code>, along with a few customization options, specify the algorithm the host uses to resolve module specifiers to files. This also clarifies why TypeScript doesn‚Äôt modify import specifiers during emit: the relationship between an import specifier and a file on disk (if one even exists) is host-defined, and TypeScript is not a host.</p>\n<p>The available <code>moduleResolution</code> options are:</p>\n<ul>\n<li><a href=\"/docs/handbook/modules/reference.html#classic\"><strong><code>classic</code></strong></a>: TypeScript‚Äôs oldest module resolution mode, this is unfortunately the default when <code>module</code> is set to anything other than <code>commonjs</code>, <code>node16</code>, or <code>nodenext</code>. It was probably made to provide best-effort resolution for a wide range of <a href=\"https://requirejs.org/docs/api.html#packages\">RequireJS</a> configurations. It should not be used for new projects (or even old projects that don‚Äôt use RequireJS or another AMD module loader), and is scheduled for deprecation in TypeScript 6.0.</li>\n<li><a href=\"/docs/handbook/modules/reference.html#node10-formerly-known-as-node\"><strong><code>node10</code></strong></a>: Formerly known as <code>node</code>, this is the unfortunate default when <code>module</code> is set to <code>commonjs</code>. It‚Äôs a pretty good model of Node.js versions older than v12, and sometimes it‚Äôs a passable approximation of how most bundlers do module resolution. It supports looking up packages from <code>node_modules</code>, loading directory <code>index.js</code> files, and omitting <code>.js</code> extensions in relative module specifiers. Because Node.js v12 introduced different module resolution rules for ES modules, though, it‚Äôs a very bad model of modern versions of Node.js. It should not be used for new projects.</li>\n<li><a href=\"/docs/handbook/modules/reference.html#node16-nodenext-1\"><strong><code>node16</code></strong></a>: This is the counterpart of <code>--module node16</code> and is set by default with that <code>module</code> setting. Node.js v12 and later support both ESM and CJS, each of which uses its own module resolution algorithm. In Node.js, module specifiers in import statements and dynamic <code>import()</code> calls are not allowed to omit file extensions or <code>/index.js</code> suffixes, while module specifiers in <code>require</code> calls are. This module resolution mode understands and enforces this restriction where necessary, as determined by the <a href=\"#module-format-detection\">module format detection rules</a> instated by <code>--module node16</code>. (For <code>node16</code> and <code>nodenext</code>, <code>module</code> and <code>moduleResolution</code> go hand-in-hand: setting one to <code>node16</code> or <code>nodenext</code> while setting the other to something else has unsupported behavior and may be an error in the future.)</li>\n<li><a href=\"/docs/handbook/modules/reference.html#node16-nodenext-1\"><strong><code>nodenext</code></strong></a>: Currently identical to <code>node16</code>, this is the counterpart of <code>--module nodenext</code> and is set by default with that <code>module</code> setting. It‚Äôs intended to be a forward-looking mode that will support new Node.js module resolution features as they‚Äôre added.</li>\n<li><a href=\"/docs/handbook/modules/reference.html#bundler\"><strong><code>bundler</code></strong></a>: Node.js v12 introduced some new module resolution features for importing npm packages‚Äîthe <code>\"exports\"</code> and <code>\"imports\"</code> fields of <code>package.json</code>‚Äîand many bundlers adopted those features without also adopting the stricter rules for ESM imports. This module resolution mode provides a base algorithm for code targeting a bundler. It supports <code>package.json</code> <code>\"exports\"</code> and <code>\"imports\"</code> by default, but can be configured to ignore them. It requires setting <code>module</code> to <code>esnext</code>.</li>\n</ul>\n<h3 id=\"typescript-imitates-the-hosts-module-resolution-but-with-types\" style=\"position:relative;\"><a href=\"#typescript-imitates-the-hosts-module-resolution-but-with-types\" aria-label=\"typescript imitates the hosts module resolution but with types permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TypeScript imitates the host‚Äôs module resolution, but with types</h3>\n<p>Remember the three components of TypeScript‚Äôs <a href=\"#typescripts-job-concerning-modules\">job</a> concerning modules?</p>\n<ol>\n<li>Compile files into a valid <strong>output module format</strong></li>\n<li>Ensure that imports in those <strong>outputs</strong> will <strong>resolve successfully</strong></li>\n<li>Know what <strong>type</strong> to assign to <strong>imported names</strong>.</li>\n</ol>\n<p>Module resolution is needed to accomplish last two. But when we spend most of our time working in input files, it can be easy to forget about (2)‚Äîthat a key component of module resolution is validating that the imports or <code>require</code> calls in the output files, containing the <a href=\"#module-specifiers-are-not-transformed\">same module specifiers as the input files</a>, will actually work at runtime. Let‚Äôs look at a new example with multiple files:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// @Filename: math.ts</span></div><div class='line'><span style=\"color: #AF00DB\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">add</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">a</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">number</span><span style=\"color: #000000\">, </span><span style=\"color: #001080\">b</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">number</span><span style=\"color: #000000\">) {</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #AF00DB\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">a</span><span style=\"color: #000000\"> + </span><span style=\"color: #001080\">b</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #000000\">}</span></div><div class='line'></div><div class='line'><span style=\"color: #008000\">// @Filename: main.ts</span></div><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> { </span><span style=\"color: #001080\">add</span><span style=\"color: #000000\"> } </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./math\"</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #795E26\">add</span><span style=\"color: #000000\">(</span><span style=\"color: #098658\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #098658\">2</span><span style=\"color: #000000\">);</span></div></code></div></pre>\n<p>When we see the import from <code>\"./math\"</code>, it might be tempting to think, ‚ÄúThis is how one TypeScript file refers to another. The compiler follows this (extensionless) path in order to assign a type to <code>add</code>.‚Äù</p>\n<img src=\"/a85812d59d60953c409c8433a93d4585/theory.md-1.svg\" width=\"400\" alt=\"A simple flowchart diagram. A file (rectangle node) main.ts resolves (labeled arrow) through module specifier './math' to another file math.ts.\">\n<p>This isn‚Äôt entirely wrong, but the reality is deeper. The resolution of <code>\"./math\"</code> (and subsequently, the type of <code>add</code>) need to reflect the reality of what happens at runtime to the <em>output</em> files. A more robust way to think about this process would look like this:</p>\n<p><img src=\"/09d658ba8b445fb6e9312f70a458bf67/theory.md-2.svg\" alt=\"A flowchart diagram with two groups of files: Input files and Output files. main.ts (an input file) maps to output file main.js, which resolves through the module specifier &#x22;./math&#x22; to math.js (another output file), which maps back to the input file math.ts.\"></p>\n<p>This model makes it clear that for TypeScript, module resolution is mostly a matter of accurately modeling the host‚Äôs module resolution algorithm between output files, with a little bit of remapping applied to find type information. Let‚Äôs look at another example that appears unintuitive through the lens of the simple model, but makes perfect sense with the robust model:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// @moduleResolution: node16</span></div><div class='line'><span style=\"color: #008000\">// @rootDir: src</span></div><div class='line'><span style=\"color: #008000\">// @outDir: dist</span></div><div class='line'></div><div class='line'><span style=\"color: #008000\">// @Filename: src/math.mts</span></div><div class='line'><span style=\"color: #AF00DB\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">add</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">a</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">number</span><span style=\"color: #000000\">, </span><span style=\"color: #001080\">b</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">number</span><span style=\"color: #000000\">) {</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #AF00DB\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">a</span><span style=\"color: #000000\"> + </span><span style=\"color: #001080\">b</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #000000\">}</span></div><div class='line'></div><div class='line'><span style=\"color: #008000\">// @Filename: src/main.mts</span></div><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> { </span><span style=\"color: #001080\">add</span><span style=\"color: #000000\"> } </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./math.mjs\"</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #795E26\">add</span><span style=\"color: #000000\">(</span><span style=\"color: #098658\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #098658\">2</span><span style=\"color: #000000\">);</span></div></code></div></pre>\n<p>Node.js ESM <code>import</code> declarations use a strict module resolution algorithm that requires relative paths to include file extensions. When we only think about input files, it‚Äôs a little strange that <code>\"./math.mjs\"</code> seems to resolve to <code>math.mts</code>. Since we‚Äôre using an <code>outDir</code> to put compiled outputs in a different directory, <code>math.mjs</code> doesn‚Äôt even exist next to <code>main.mts</code>! Why should this resolve? With our new mental model, it‚Äôs no problem:</p>\n<p><img src=\"/1f82dc338fa5095a7ea944303985a2b9/theory.md-3.svg\" alt=\"A flowchart diagram with identical structure to the one above. There are two groups of files: Input files and Output files. src/main.mts (an input file) maps to output file dist/main.mjs, which resolves through module specifier &#x22;./math.mjs&#x22; to dist/math.mjs (another output file), which maps back to input file src/math.mts.\"></p>\n<p>Understanding this mental model may not immediately eliminate the strangeness of seeing output file extensions in input files, and it‚Äôs natural to think in terms of shortcuts: <em><code>\"./math.mjs\"</code> refers to the input file <code>math.mts</code>. I have to write the output extension, but the compiler knows to look for <code>.mts</code> when I write <code>.mjs</code>.</em> This shortcut is even how the compiler works internally, but the more robust mental model explains <em>why</em> module resolution in TypeScript works this way: given the constraint that the module specifier in the output file will be <a href=\"#module-specifiers-are-not-transformed\">the same</a> as the module specifier in the input file, this is the only process that accomplishes our two goals of validating output files and assigning types.</p>\n<h3 id=\"the-role-of-declaration-files\" style=\"position:relative;\"><a href=\"#the-role-of-declaration-files\" aria-label=\"the role of declaration files permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>The role of declaration files</h3>\n<p>In the previous example, we saw the ‚Äúremapping‚Äù part of module resolution working between input and output files. But what happens when we import library code? Even if the library was written in TypeScript, it may not have published its source code. If we can‚Äôt rely on mapping the library‚Äôs JavaScript files back to a TypeScript file, we can verify that our import works at runtime, but how do we accomplish our second goal of assigning types?</p>\n<p>This is where declaration files (<code>.d.ts</code>, <code>.d.mts</code>, etc.) come into play. The best way to understand how declaration files are interpreted is to understand where they come from. When you run <code>tsc --declaration</code> on an input file, you get one output JavaScript file and one output declaration file:</p>\n<img src=\"/fef70ad85e4ea4ef928cc62ddb67407b/declaration-files.svg\" width=\"400\" style=\"background-color: white; border-radius: 8px;\" alt=\"A diagram showing the relationship between different file types. A .ts file (top) has two arrows labeled 'generates' flowing to a .js file (bottom left) and a .d.ts file (bottom right). Another arrow labeled 'implies' points from the .d.ts file to the .js file.\">\n<p>Because of this relationship, the compiler <em>assumes</em> that wherever it sees a declaration file, there is a corresponding JavaScript file that is perfectly described by the type information in the declaration file. For performance reasons, in every module resolution mode, the compiler always looks for TypeScript and declaration files first, and if it finds one, it doesn‚Äôt continue looking for the corresponding JavaScript file. If it finds a TypeScript input file, it knows a JavaScript file <em>will</em> exist after compilation, and if it finds a declaration file, it knows a compilation (perhaps someone else‚Äôs) already happened and created a JavaScript file at the same time as the declaration file.</p>\n<p>The declaration file tells the compiler not only that a JavaScript file exists, but also what its name and extension are:</p>\n<table>\n<thead>\n<tr>\n<th>Declaration file extension</th>\n<th>JavaScript file extension</th>\n<th>TypeScript file extension</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>.d.ts</code></td>\n<td><code>.js</code></td>\n<td><code>.ts</code></td>\n</tr>\n<tr>\n<td><code>.d.ts</code></td>\n<td><code>.js</code></td>\n<td><code>.tsx</code></td>\n</tr>\n<tr>\n<td><code>.d.mts</code></td>\n<td><code>.mjs</code></td>\n<td><code>.mts</code></td>\n</tr>\n<tr>\n<td><code>.d.cts</code></td>\n<td><code>.cjs</code></td>\n<td><code>.cts</code></td>\n</tr>\n<tr>\n<td><code>.d.*.ts</code></td>\n<td><code>.*</code></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<p>The last row expresses that non-JS files can be typed with the <code>allowArbitraryExtensions</code> compiler option to support cases where the module system supports importing non-JS files as JavaScript objects. For example, a file named <code>styles.css</code> can be represented by a declaration file named <code>styles.d.css.ts</code>.</p>\n<blockquote>\n<p>‚ÄúBut wait! Plenty of declaration files are written by hand, <em>not</em> generated by <code>tsc</code>. Ever heard of DefinitelyTyped?‚Äù you might object. And it‚Äôs true‚Äîhand-writing declaration files, or even moving/copying/renaming them to represent outputs of an external build tool, is a dangerous, error-prone venture. DefinitelyTyped contributors and authors of typed libraries not using <code>tsc</code> to generate both JavaScript and declaration files should ensure that every JavaScript file has a sibling declaration file with the same name and matching extension. Breaking from this structure can lead to false-positive TypeScript errors for end users. The npm package <a href=\"https://www.npmjs.com/package/@arethetypeswrong/cli\"><code>@arethetypeswrong/cli</code></a> can help catch and explain these errors before they‚Äôre published.</p>\n</blockquote>\n<h3 id=\"module-resolution-for-bundlers-typescript-runtimes-and-nodejs-loaders\" style=\"position:relative;\"><a href=\"#module-resolution-for-bundlers-typescript-runtimes-and-nodejs-loaders\" aria-label=\"module resolution for bundlers typescript runtimes and nodejs loaders permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Module resolution for bundlers, TypeScript runtimes, and Node.js loaders</h3>\n<p>So far, we‚Äôve really emphasized the distinction between <em>input files</em> and <em>output files</em>. Recall that when specifying a file extension on a relative module specifier, TypeScript typically <a href=\"#typescript-imitates-the-hosts-module-resolution-but-with-types\">makes you use the <em>output</em> file extension</a>:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// @Filename: src/math.ts</span></div><div class='line'><span style=\"color: #AF00DB\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">add</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">a</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">number</span><span style=\"color: #000000\">, </span><span style=\"color: #001080\">b</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">number</span><span style=\"color: #000000\">) {</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #AF00DB\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">a</span><span style=\"color: #000000\"> + </span><span style=\"color: #001080\">b</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #000000\">}</span></div><div class='line'></div><div class='line'><span style=\"color: #008000\">// @Filename: src/main.ts</span></div><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> { </span><span style=\"color: #001080\">add</span><span style=\"color: #000000\"> } </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./math.ts\"</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #008000\">//                  ^^^^^^^^^^^</span></div><div class='line'><span style=\"color: #008000\">// An import path can only end with a '.ts' extension when 'allowImportingTsExtensions' is enabled.</span></div></code></div></pre>\n<p>This restriction applies since TypeScript <a href=\"#module-specifiers-are-not-transformed\">won‚Äôt rewrite the extension</a> to <code>.js</code>, and if <code>\"./math.ts\"</code> appears in an output JS file, that import won‚Äôt resolve to another JS file at runtime. TypeScript really wants to prevent you from generating an unsafe output JS file. But what if there <em>is</em> no output JS file? What if you‚Äôre in one of these situations:</p>\n<ul>\n<li>You‚Äôre bundling this code, the bundler is configured to transpile TypeScript files in-memory, and it will eventually consume and erase all the imports you‚Äôve written to produce a bundle.</li>\n<li>You‚Äôre running this code directly in a TypeScript runtime like Deno or Bun.</li>\n<li>You‚Äôre using <code>ts-node</code>, <code>tsx</code>, or another transpiling loader for Node.</li>\n</ul>\n<p>In these cases, you can turn on <code>noEmit</code> (or <code>emitDeclarationOnly</code>) and <code>allowImportingTsExtensions</code> to disable emitting unsafe JavaScript files and silence the error on <code>.ts</code>-extensioned imports.</p>\n<p>With or without <code>allowImportingTsExtensions</code>, it‚Äôs still important to pick the most appropriate <code>moduleResolution</code> setting for the module resolution host. For bundlers and the Bun runtime, it‚Äôs <code>bundler</code>. These module resolvers were inspired by Node.js, but didn‚Äôt adopt the strict ESM resolution algorithm that <a href=\"#extension-searching-and-directory-index-files\">disables extension searching</a> that Node.js applies to imports. The <code>bundler</code> module resolution setting reflects this, enabling <code>package.json</code> <code>\"exports\"</code> support like <code>node16</code> and <code>nodenext</code>, while always allowing extensionless imports. See <a href=\"/docs/handbook/modules/guides/choosing-compiler-options.html\"><em>Choosing compiler options</em></a> for more guidance.</p>\n<h3 id=\"module-resolution-for-libraries\" style=\"position:relative;\"><a href=\"#module-resolution-for-libraries\" aria-label=\"module resolution for libraries permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Module resolution for libraries</h3>\n<p>When compiling an app, you choose the <code>moduleResolution</code> option for a TypeScript project based on who the module resolution <a href=\"#module-resolution-is-host-defined\">host</a> is. When compiling a library, you don‚Äôt know where the output code will run, but you‚Äôd like it to run in as many places as possible. Using <code>\"module\": \"nodenext\"</code> (along with the implied <a href=\"/docs/handbook/modules/reference.html#node16-nodenext\"><code>\"moduleResolution\": \"nodenext\"</code></a>) is the best bet for maximizing the compatibility of the output JavaScript‚Äôs module specifiers, since it will force you to comply with Node.js‚Äôs stricter rules for <code>import</code> module resolution. Let‚Äôs look at what would happen if a library were to compile with <code>\"moduleResolution\": \"bundler\"</code> (or worse, <code>\"node10\"</code>):</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #AF00DB\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">*</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./utils\"</span><span style=\"color: #000000\">;</span></div></code></div></pre>\n<p>Assuming <code>./utils.ts</code> (or <code>./utils/index.ts</code>) exists, a bundler would be fine with this code, so <code>\"moduleResolution\": \"bundler\"</code> doesn‚Äôt complain. Compiled with <code>\"module\": \"esnext\"</code>, the output JavaScript for this export statement will look exactly the same as the input. If that JavaScript were published to npm, it would be usable by projects that use a bundler, but it would cause an error when run in Node.js:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class='code-container'><code><div class='line'><span style=\"color: undefined\">Error [ERR_MODULE_NOT_FOUND]: Cannot find module '.../node_modules/dependency/utils' imported from .../node_modules/dependency/index.js\nDid you mean to import ./utils.js?</span></div></code></div></pre>\n<p>On the other hand, if we had written:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #AF00DB\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">*</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./utils.js\"</span><span style=\"color: #000000\">;</span></div></code></div></pre>\n<p>This would produce output that works both in Node.js <em>and</em> in bundlers.</p>\n<p>In short, <code>\"moduleResolution\": \"bundler\"</code> is infectious, allowing code that only works in bundlers to be produced. Likewise, <code>\"moduleResolution\": \"nodenext\"</code> is only checking that the output works in Node.js, but in most cases, module code that works in Node.js will work in other runtimes and in bundlers.</p>\n<p>Of course, this guidance can only apply in cases where the library ships outputs from <code>tsc</code>. If the library is being bundled <em>before</em> shipping, <code>\"moduleResolution\": \"bundler\"</code> may be acceptable. Any build tool that changes the module format or module specifiers to produce the final build of the library bears the responsibility of ensuring the safety and compatibility of the product‚Äôs module code, and <code>tsc</code> can no longer contribute to that task, since it can‚Äôt know what module code will exist at runtime.</p>","headings":[{"value":"Scripts and modules in JavaScript","depth":2},{"value":"TypeScript‚Äôs job concerning modules","depth":2},{"value":"Who is the host?","depth":2},{"value":"The module output format","depth":2},{"value":"Module format detection","depth":3},{"value":"Input module syntax","depth":3},{"value":"ESM and CJS interoperability","depth":3},{"value":"Module specifiers are not transformed","depth":3},{"value":"Module resolution","depth":2},{"value":"Module resolution is host-defined","depth":3},{"value":"TypeScript imitates the host‚Äôs module resolution, but with types","depth":3},{"value":"The role of declaration files","depth":3},{"value":"Module resolution for bundlers, TypeScript runtimes, and Node.js loaders","depth":3},{"value":"Module resolution for libraries","depth":3}],"frontmatter":{"permalink":"/docs/handbook/modules/theory.html","title":"Modules - Theory","disable_toc":null,"handbook":null,"oneline":"How TypeScript models JavaScript modules","preamble":null,"deprecated_by":null,"deprecation_redirects":null,"experimental":null}},"prev":null,"next":null},"pageContext":{"id":"3-modules---theory","slug":"/docs/handbook/modules/theory.html","repoPath":"/packages/documentation/copy/en/modules-reference/Theory.md","lang":"en","modifiedTime":"2024-10-21T12:33:11.301Z"}},"staticQueryHashes":[]}