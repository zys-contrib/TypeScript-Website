{"componentChunkName":"component---src-templates-documentation-tsx","path":"/docs/handbook/modules/appendices/esm-cjs-interop.html","result":{"data":{"markdownRemark":{"id":"ed126a84-9b4c-5e7f-bba1-c5144f38e4c3","excerpt":"It’s 2015, and you’re writing an ESM-to-CJS transpiler. There’s no specification for how to do this; all you have is a specification of how ES modules are…","html":"<p>It’s 2015, and you’re writing an ESM-to-CJS transpiler. There’s no specification for how to do this; all you have is a specification of how ES modules are supposed to interact with each other, knowledge of how CommonJS modules interact with each other, and a knack for figuring things out. Consider an exporting ES module:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #AF00DB\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #0070C1\">A</span><span style=\"color: #000000\"> = {};</span></div><div class='line'><span style=\"color: #AF00DB\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #0070C1\">B</span><span style=\"color: #000000\"> = {};</span></div><div class='line'><span style=\"color: #AF00DB\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">default</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"Hello, world!\"</span><span style=\"color: #000000\">;</span></div></code></div></pre>\n<p>How would you turn this into a CommonJS module? Recalling that default exports are just named exports with special syntax, there seems to be only one choice:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #1C6277\">exports</span><span style=\"color: #000000\">.</span><span style=\"color: #0070C1\">A</span><span style=\"color: #000000\"> = {};</span></div><div class='line'><span style=\"color: #1C6277\">exports</span><span style=\"color: #000000\">.</span><span style=\"color: #0070C1\">B</span><span style=\"color: #000000\"> = {};</span></div><div class='line'><span style=\"color: #1C6277\">exports</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">default</span><span style=\"color: #000000\"> = </span><span style=\"color: #A31515\">\"Hello, world!\"</span><span style=\"color: #000000\">;</span></div></code></div></pre>\n<p>This is a nice analog, and it lets you implement a similar on the importing side:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">hello</span><span style=\"color: #000000\">, { </span><span style=\"color: #001080\">A</span><span style=\"color: #000000\">, </span><span style=\"color: #001080\">B</span><span style=\"color: #000000\"> } </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./module\"</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">hello</span><span style=\"color: #000000\">, </span><span style=\"color: #0070C1\">A</span><span style=\"color: #000000\">, </span><span style=\"color: #0070C1\">B</span><span style=\"color: #000000\">);</span></div><div class='line'></div><div class='line'><span style=\"color: #008000\">// transpiles to:</span></div><div class='line'></div><div class='line'><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #0070C1\">module_1</span><span style=\"color: #000000\"> = </span><span style=\"color: #795E26\">require</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">\"./module\"</span><span style=\"color: #000000\">);</span></div><div class='line'><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">module_1</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">default</span><span style=\"color: #000000\">, </span><span style=\"color: #001080\">module_1</span><span style=\"color: #000000\">.</span><span style=\"color: #0070C1\">A</span><span style=\"color: #000000\">, </span><span style=\"color: #001080\">module_1</span><span style=\"color: #000000\">.</span><span style=\"color: #0070C1\">B</span><span style=\"color: #000000\">);</span></div></code></div></pre>\n<p>So far, everything in CJS-world matches up one-to-one with everything in ESM-world. Extending the equivalence above one step further, we can see that we also have:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">*</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">as</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">mod</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./module\"</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">mod</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">default</span><span style=\"color: #000000\">, </span><span style=\"color: #001080\">mod</span><span style=\"color: #000000\">.</span><span style=\"color: #0070C1\">A</span><span style=\"color: #000000\">, </span><span style=\"color: #001080\">mod</span><span style=\"color: #000000\">.</span><span style=\"color: #0070C1\">B</span><span style=\"color: #000000\">);</span></div><div class='line'></div><div class='line'><span style=\"color: #008000\">// transpiles to:</span></div><div class='line'></div><div class='line'><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #0070C1\">mod</span><span style=\"color: #000000\"> = </span><span style=\"color: #795E26\">require</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">\"./module\"</span><span style=\"color: #000000\">);</span></div><div class='line'><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">mod</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">default</span><span style=\"color: #000000\">, </span><span style=\"color: #001080\">mod</span><span style=\"color: #000000\">.</span><span style=\"color: #0070C1\">A</span><span style=\"color: #000000\">, </span><span style=\"color: #001080\">mod</span><span style=\"color: #000000\">.</span><span style=\"color: #0070C1\">B</span><span style=\"color: #000000\">);</span></div></code></div></pre>\n<p>You might notice that in this scheme, there’s no way to write an ESM export that produces an output where <code>exports</code> is assigned a function, class, or primitive:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// @Filename: exports-function.js</span></div><div class='line'><span style=\"color: #1C6277\">module</span><span style=\"color: #000000\">.</span><span style=\"color: #1C6277\">exports</span><span style=\"color: #000000\"> = </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">hello</span><span style=\"color: #000000\">() {</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">\"Hello, world!\"</span><span style=\"color: #000000\">);</span></div><div class='line'><span style=\"color: #000000\">};</span></div></code></div></pre>\n<p>But existing CommonJS modules frequently take this form. How might an ESM import, processed with our transpiler, access this module? We just established that a namespace import (<code>import *</code>) transpiles to a plain <code>require</code> call, so we can support an input like:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">*</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">as</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">hello</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./exports-function\"</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #795E26\">hello</span><span style=\"color: #000000\">();</span></div><div class='line'></div><div class='line'><span style=\"color: #008000\">// transpiles to:</span></div><div class='line'></div><div class='line'><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #0070C1\">hello</span><span style=\"color: #000000\"> = </span><span style=\"color: #795E26\">require</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">\"./exports-function\"</span><span style=\"color: #000000\">);</span></div><div class='line'><span style=\"color: #795E26\">hello</span><span style=\"color: #000000\">();</span></div></code></div></pre>\n<p>Our output works at runtime, but we have a compliance problem: according to the JavaScript specification, a namespace import always resolves to a <a href=\"https://tc39.es/ecma262/#sec-module-namespace-objects\"><em>Module Namespace Object</em></a>, that is, an object whose members are the exports of the module. In this case, <code>require</code> would return the function <code>hello</code>, but <code>import *</code> can never return a function. The correspondence we assumed appears invalid.</p>\n<p>It’s worth taking a step back here and clarifying what the <em>goal</em> is. As soon as modules landed in the ES2015 specification, transpilers emerged with support for downleveling ESM to CJS, allowing users to adopt the new syntax long before runtimes implemented support for it. There was even a sense that writing ESM code was a good way to “future-proof” new projects. For this to be true, there needed to be a seamless migration path from executing the transpilers’ CJS output to executing the ESM input natively once runtimes developed support for it. The goal was to find a way to downlevel ESM to CJS that would allow any or all of those transpiled outputs to be replaced by their true ESM inputs in a future runtime, with no observable change in behavior.</p>\n<p>By following the specification, it was easy enough for transpilers to find a set of transformations that made the semantics of their transpiled CommonJS outputs match the specified semantics of their ESM inputs (arrows represent imports):</p>\n<p><img src=\"/5babf010ab0c0004cb0b2200978a903d/esm-cjs-interop.mmd-1.svg\" alt=\"A flowchart with two similar flows side-by-side. Left: ESM. Right: ESM transpiled to CJS. In the ESM flow: &#x22;Importing module&#x22; flows to &#x22;Imported module&#x22; through arrow labeled &#x22;specified behavior&#x22;. In the ESM transpiled to CJS flow: &#x22;Importing module&#x22; flows to &#x22;Imported module&#x22; through arrow labeled &#x22;designed based on spec&#x22;.\"></p>\n<p>However, CommonJS modules (written as CommonJS, not as ESM transpiled to CommonJS) were already well-established in the Node.js ecosystem, so it was inevitable that modules written as ESM and transpiled to CJS would start “importing” modules written as CommonJS. The behavior for this interoperability, though, was not specified by ES2015, and didn’t yet exist in any real runtime.</p>\n<p><img src=\"/96fe17d52f22424c730c49eb79ae7b50/esm-cjs-interop.mmd-2.svg\" alt=\"A flowchart with three areas side-by-side. Left: ESM. Middle: True CJS. Right: ESM transpiled to CJS. Left: ESM &#x22;Importing module&#x22; flows to ESM &#x22;Imported module&#x22; through arrow labeled &#x22;specified behavior,&#x22; and to True CJS &#x22;Imported module&#x22; through dotted arrow labeled &#x22;unspecified behavior.&#x22; Right: ESM transpiled to CJS &#x22;Importing module&#x22; flows to ESM transpiled to CJS &#x22;Imported module&#x22; through arrow labeled &#x22;designed based on spec,&#x22; and to True CJS &#x22;Imported module&#x22; through dotted arrow labeled &#x22;❓🤷‍♂️❓&#x22;\"></p>\n<p>Even if transpiler authors did nothing, a behavior would emerge from the existing semantics between the <code>require</code> calls they emitted in transpiled code and the <code>exports</code> defined in existing CJS modules. And to allow users to transition seamlessly from transpiled ESM to true ESM once their runtime supported it, that behavior would have to match the one the runtime chose to implement.</p>\n<p>Guessing what interop behavior runtimes would support wasn’t limited to ESM importing “true CJS” modules either. Whether ESM would be able to recognize ESM-transpiled-from-CJS as distinct from CJS, and whether CJS would be able to <code>require</code> ES modules, were also unspecified. Even whether ESM imports would use the same module resolution algorithm as CJS <code>require</code> calls was unknowable. All these variables would have to be predicted correctly in order to give transpiler users a seamless migration path toward native ESM.</p>\n<h2 id=\"allowsyntheticdefaultimports-and-esmoduleinterop\" style=\"position:relative;\"><a href=\"#allowsyntheticdefaultimports-and-esmoduleinterop\" aria-label=\"allowsyntheticdefaultimports and esmoduleinterop permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>allowSyntheticDefaultImports</code> and <code>esModuleInterop</code></h2>\n<p>Let’s return to our specification compliance problem, where <code>import *</code> transpiles to <code>require</code>:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// Invalid according to the spec:</span></div><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">*</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">as</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">hello</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./exports-function\"</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #795E26\">hello</span><span style=\"color: #000000\">();</span></div><div class='line'></div><div class='line'><span style=\"color: #008000\">// but the transpilation works:</span></div><div class='line'><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #0070C1\">hello</span><span style=\"color: #000000\"> = </span><span style=\"color: #795E26\">require</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">\"./exports-function\"</span><span style=\"color: #000000\">);</span></div><div class='line'><span style=\"color: #795E26\">hello</span><span style=\"color: #000000\">();</span></div></code></div></pre>\n<p>When TypeScript first added support for writing and transpiling ES modules, the compiler addressed this problem by issuing an error on any namespace import of a module whose <code>exports</code> was not a namespace-like object:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">*</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">as</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">hello</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./exports-function\"</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #008000\">// TS2497              ^^^^^^^^^^^^^^^^^^^^</span></div><div class='line'><span style=\"color: #008000\">// External module '\"./exports-function\"' resolves to a non-module entity</span></div><div class='line'><span style=\"color: #008000\">// and cannot be imported using this construct.</span></div></code></div></pre>\n<p>The only workaround was for users to go back to using the older TypeScript import syntax representing a CommonJS <code>require</code>:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">hello</span><span style=\"color: #000000\"> = </span><span style=\"color: #AF00DB\">require</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">\"./exports-function\"</span><span style=\"color: #000000\">);</span></div></code></div></pre>\n<p>Forcing users to revert to non-ESM syntax was essentially an admission that “we don’t know how or if a CJS module like <code>\"./exports-function\"</code> will be accessible with ESM imports in the future, but we know it <em>can’t</em> be with <code>import *</code>, even though it will work at runtime in the transpilation scheme we’re using.” It doesn’t meet the goal of allowing this file to be migrated to real ESM without changes, but neither does the alternative of allowing the <code>import *</code> to link to a function. This is still the behavior in TypeScript today when <code>allowSyntheticDefaultImports</code> and <code>esModuleInterop</code> are disabled.</p>\n<blockquote>\n<p>Unfortunately, this is a slight oversimplification—TypeScript didn’t fully avoid the compliance issue with this error, because it allowed namespace imports of functions to work, and retain their call signatures, as long as the function declaration merged with a namespace declaration—even if the namespace was empty. So while a module exporting a bare function was recognized as a “non-module entity”:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #0000FF\">declare</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">$</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">selector</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">string</span><span style=\"color: #000000\">): </span><span style=\"color: #1C6277\">any</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #AF00DB\">export</span><span style=\"color: #000000\"> = </span><span style=\"color: #001080\">$</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// Cannot `import *` this 👍</span></div></code></div></pre>\n<p>A should-be-meaningless change allowed the invalid import to type check without errors:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #0000FF\">declare</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">namespace</span><span style=\"color: #000000\"> </span><span style=\"color: #1C6277\">$</span><span style=\"color: #000000\"> {}</span></div><div class='line'><span style=\"color: #0000FF\">declare</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">$</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">selector</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">string</span><span style=\"color: #000000\">): </span><span style=\"color: #1C6277\">any</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #AF00DB\">export</span><span style=\"color: #000000\"> = </span><span style=\"color: #001080\">$</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// Allowed to `import *` this and call it 😱</span></div></code></div></pre>\n</blockquote>\n<p>Meanwhile, other transpilers were coming up with a way to solve the same problem. The thought process went something like this:</p>\n<ol>\n<li>To import a CJS module that exports a function or a primitive, we clearly need to use a default import. A namespace import would be illegal, and named imports don’t make sense here.</li>\n<li>Most likely, this means that runtimes implementing ESM/CJS interop will choose to make default imports of CJS modules <em>always</em> link directly to the whole <code>exports</code>, rather than only doing so if the <code>exports</code> is a function or primitive.</li>\n<li>So, a default import of a true CJS module should work just like a <code>require</code> call. But we’ll need a way to disambiguate true CJS modules from our transpiled CJS modules, so we can still transpile <code>export default \"hello\"</code> to <code>exports.default = \"hello\"</code> and have a default import of <em>that</em> module link to <code>exports.default</code>. Basically, a default import of one of our own transpiled modules needs to work one way (to simulate ESM-to-ESM imports), while a default import of any other existing CJS module needs to work another way (to simulate how we think ESM-to-CJS imports will work).</li>\n<li>When we transpile an ES module to CJS, let’s add a special extra field to the output:\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #1C6277\">exports</span><span style=\"color: #000000\">.</span><span style=\"color: #0070C1\">A</span><span style=\"color: #000000\"> = {};</span></div><div class='line'><span style=\"color: #1C6277\">exports</span><span style=\"color: #000000\">.</span><span style=\"color: #0070C1\">B</span><span style=\"color: #000000\"> = {};</span></div><div class='line'><span style=\"color: #1C6277\">exports</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">default</span><span style=\"color: #000000\"> = </span><span style=\"color: #A31515\">\"Hello, world!\"</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #008000\">// Extra special flag!</span></div><div class='line'><span style=\"color: #1C6277\">exports</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">__esModule</span><span style=\"color: #000000\"> = </span><span style=\"color: #0000FF\">true</span><span style=\"color: #000000\">;</span></div></code></div></pre>\nthat we can check for when we transpile a default import:\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// import hello from \"./modue\";</span></div><div class='line'><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #0070C1\">_mod</span><span style=\"color: #000000\"> = </span><span style=\"color: #795E26\">require</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">\"./module\"</span><span style=\"color: #000000\">);</span></div><div class='line'><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #0070C1\">hello</span><span style=\"color: #000000\"> = </span><span style=\"color: #001080\">_mod</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">__esModule</span><span style=\"color: #000000\"> ? </span><span style=\"color: #001080\">_mod</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">default</span><span style=\"color: #000000\"> : </span><span style=\"color: #001080\">_mod</span><span style=\"color: #000000\">;</span></div></code></div></pre>\n</li>\n</ol>\n<p>The <code>__esModule</code> flag first appeared in Traceur, then in Babel, SystemJS, and Webpack shortly after. TypeScript added the <code>allowSyntheticDefaultImports</code> in 1.8 to allow the type checker to link default imports directly to the <code>exports</code>, rather than the <code>exports.default</code>, of any module types that lacked an <code>export default</code> declaration. The flag didn’t modify how imports or exports were emitted, but it allowed default imports to reflect how other transpilers would treat them. Namely, it allowed a default import to be used to resolve to “non-module entities,” where <code>import *</code> was an error:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// Error:</span></div><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">*</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">as</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">hello</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./exports-function\"</span><span style=\"color: #000000\">;</span></div><div class='line'></div><div class='line'><span style=\"color: #008000\">// Old workaround:</span></div><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">hello</span><span style=\"color: #000000\"> = </span><span style=\"color: #AF00DB\">require</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">\"./exports-function\"</span><span style=\"color: #000000\">);</span></div><div class='line'></div><div class='line'><span style=\"color: #008000\">// New way, with `allowSyntheticDefaultImports`:</span></div><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">hello</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./exports-function\"</span><span style=\"color: #000000\">;</span></div></code></div></pre>\n<p>This was usually enough to let Babel and Webpack users write code that already worked in those systems without TypeScript complaining, but it was only a partial solution, leaving a few issues unsolved:</p>\n<ol>\n<li>Babel and others varied their default import behavior on whether an <code>__esModule</code> property was found on the target module, but <code>allowSyntheticDefaultImports</code> only enabled a <em>fallback</em> behavior when no default export was found in the target module’s types. This created an inconsistency if the target module had an <code>__esModule</code> flag but <em>no</em> default export. Transpilers and bundlers would still link a default import of such a module to its <code>exports.default</code>, which would be <code>undefined</code>, and would ideally be an error in TypeScript, since real ESM imports cause errors if they can’t be linked. But with <code>allowSyntheticDefaultImports</code>, TypeScript would think a default import of such an import links to the whole <code>exports</code> object, allowing named exports to be accessed as its properties.</li>\n<li><code>allowSyntheticDefaultImports</code> didn’t change how namespace imports were typed, creating an odd inconsistency where both could be used and would have the same type:\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// @Filename: exportEqualsObject.d.ts</span></div><div class='line'><span style=\"color: #0000FF\">declare</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #0070C1\">obj</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">object</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #AF00DB\">export</span><span style=\"color: #000000\"> = </span><span style=\"color: #001080\">obj</span><span style=\"color: #000000\">;</span></div><div class='line'></div><div class='line'><span style=\"color: #008000\">// @Filename: main.ts</span></div><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">objDefault</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./exportEqualsObject\"</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">*</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">as</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">objNamespace</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./exportEqualsObject\"</span><span style=\"color: #000000\">;</span></div><div class='line'></div><div class='line'><span style=\"color: #008000\">// This should be true at runtime, but TypeScript gives an error:</span></div><div class='line'><span style=\"color: #001080\">objNamespace</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">default</span><span style=\"color: #000000\"> === </span><span style=\"color: #001080\">objDefault</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #008000\">//           ^^^^^^^ Property 'default' does not exist on type 'typeof import(\"./exportEqualsObject\")'.</span></div></code></div></pre>\n</li>\n<li>Most importantly, <code>allowSyntheticDefaultImports</code> did not change the JavaScript emitted by <code>tsc</code>. So while the flag enabled more accurate checking as long as the code was fed into another tool like Babel or Webpack, it created a real danger for users who were emitting <code>--module commonjs</code> with <code>tsc</code> and running in Node.js. If they encountered an error with <code>import *</code>, it may have appeared as if enabling <code>allowSyntheticDefaultImports</code> would fix it, but in fact it only silenced the build-time error while emitting code that would crash in Node.</li>\n</ol>\n<p>TypeScript introduced the <code>esModuleInterop</code> flag in 2.7, which refined the type checking of imports to address the remaining inconsistencies between TypeScript’s analysis and the interop behavior used in existing transpilers and bundlers, and critically, adopted the same <code>__esModule</code>-conditional CommonJS emit that transpilers had adopted years before. (Another new emit helper for <code>import *</code> ensured the result was always an object, with call signatures stripped, fully resolving the specification compliance issue that the aforementioned “resolves to a non-module entity” error didn’t quite sidestep.) Finally, with the new flag enabled, TypeScript’s type checking, TypeScript’s emit, and the rest of the transpiling and bundling ecosystem were in agreement on a CJS/ESM interop scheme that was spec-legal and, perhaps, plausibly adoptable by Node.</p>\n<h2 id=\"interop-in-nodejs\" style=\"position:relative;\"><a href=\"#interop-in-nodejs\" aria-label=\"interop in nodejs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Interop in Node.js</h2>\n<p>Node.js shipped support for ES modules unflagged in v12. Like the bundlers and transpilers began doing years before, Node.js gave CommonJS modules a “synthetic default export” of their <code>exports</code> object, allowing the entire module contents to be accessed with a default import from ESM:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// @Filename: export.cjs</span></div><div class='line'><span style=\"color: #1C6277\">module</span><span style=\"color: #000000\">.</span><span style=\"color: #1C6277\">exports</span><span style=\"color: #000000\"> = { </span><span style=\"color: #001080\">hello:</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"world\"</span><span style=\"color: #000000\"> };</span></div><div class='line'></div><div class='line'><span style=\"color: #008000\">// @Filename: import.mjs</span></div><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">greeting</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./export.cjs\"</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #001080\">greeting</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">hello</span><span style=\"color: #000000\">; </span><span style=\"color: #008000\">// \"world\"</span></div></code></div></pre>\n<p>That’s one win for seamless migration! Unfortunately, the similarities mostly end there.</p>\n<h3 id=\"no-__esmodule-detection-the-double-default-problem\" style=\"position:relative;\"><a href=\"#no-__esmodule-detection-the-double-default-problem\" aria-label=\"no __esmodule detection the double default problem permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>No <code>__esModule</code> detection (the “double default” problem)</h3>\n<p>Node.js wasn’t able to respect the <code>__esModule</code> marker to vary its default import behavior. So a transpiled module with a “default export” behaves one way when “imported” by another transpiled module, and another way when imported by a true ES module in Node.js:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// @Filename: node_modules/dependency/index.js</span></div><div class='line'><span style=\"color: #1C6277\">exports</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">__esModule</span><span style=\"color: #000000\"> = </span><span style=\"color: #0000FF\">true</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #1C6277\">exports</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">default</span><span style=\"color: #000000\"> = </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">doSomething</span><span style=\"color: #000000\">() { </span><span style=\"color: #008000\">/*...*/</span><span style=\"color: #000000\"> }</span></div><div class='line'></div><div class='line'><span style=\"color: #008000\">// @Filename: transpile-vs-run-directly.{js/mjs}</span></div><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">doSomething</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"dependency\"</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #008000\">// Works after transpilation, but not a function in Node.js ESM:</span></div><div class='line'><span style=\"color: #795E26\">doSomething</span><span style=\"color: #000000\">();</span></div><div class='line'><span style=\"color: #008000\">// Doesn't exist after trasnpilation, but works in Node.js ESM:</span></div><div class='line'><span style=\"color: #001080\">doSomething</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">default</span><span style=\"color: #000000\">();</span></div></code></div></pre>\n<p>While the transpiled default import only makes the synthetic default export if the target module lacks an <code>__esModule</code> flag, Node.js <em>always</em> synthesizes a default export, creating a “double default” on the transpiled module.</p>\n<h3 id=\"unreliable-named-exports\" style=\"position:relative;\"><a href=\"#unreliable-named-exports\" aria-label=\"unreliable named exports permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Unreliable named exports</h3>\n<p>In addition to making a CommonJS module’s <code>exports</code> object available as a default import, Node.js attempts to find properties of <code>exports</code> to make available as named imports. This behavior matches bundlers and transpilers when it works; however, Node.js uses <a href=\"https://github.com/nodejs/cjs-module-lexer\">syntactic analysis</a> to synthesize named exports before any code executes, whereas transpiled modules resolve their named imports at runtime. The result is that imports from CJS modules that work in transpiled modules may not work in Node.js:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// @Filename: named-exports.cjs</span></div><div class='line'><span style=\"color: #1C6277\">exports</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">hello</span><span style=\"color: #000000\"> = </span><span style=\"color: #A31515\">\"world\"</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #1C6277\">exports</span><span style=\"color: #000000\">[</span><span style=\"color: #A31515\">\"worl\"</span><span style=\"color: #000000\"> + </span><span style=\"color: #A31515\">\"d\"</span><span style=\"color: #000000\">] = </span><span style=\"color: #A31515\">\"hello\"</span><span style=\"color: #000000\">;</span></div><div class='line'></div><div class='line'><span style=\"color: #008000\">// @Filename: transpile-vs-run-directly.{js/mjs}</span></div><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> { </span><span style=\"color: #001080\">hello</span><span style=\"color: #000000\">, </span><span style=\"color: #001080\">world</span><span style=\"color: #000000\"> } </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./named-exports.cjs\"</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #008000\">// `hello` works, but `world` is missing in Node.js 💥</span></div><div class='line'></div><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">mod</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./named-exports.cjs\"</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #001080\">mod</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">world</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #008000\">// Accessing properties from the default always works ✅</span></div></code></div></pre>\n<h3 id=\"cannot-require-a-true-es-module\" style=\"position:relative;\"><a href=\"#cannot-require-a-true-es-module\" aria-label=\"cannot require a true es module permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Cannot <code>require</code> a true ES module</h3>\n<p>True CommonJS modules can <code>require</code> an ESM-transpiled-to-CJS module, since they’re both CommonJS at runtime. But in Node.js, <code>require</code> crashes if it resolves to an ES module. This means published libraries cannot migrate from transpiled modules to true ESM without breaking their CommonJS (true or transpiled) consumers:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// @Filename: node_modules/dependency/index.js</span></div><div class='line'><span style=\"color: #AF00DB\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">doSomething</span><span style=\"color: #000000\">() { </span><span style=\"color: #008000\">/* ... */</span><span style=\"color: #000000\"> }</span></div><div class='line'></div><div class='line'><span style=\"color: #008000\">// @Filename: dependent.js</span></div><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> { </span><span style=\"color: #001080\">doSomething</span><span style=\"color: #000000\"> } </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"dependency\"</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #008000\">// ✅ Works if dependent and dependency are both transpiled</span></div><div class='line'><span style=\"color: #008000\">// ✅ Works if dependent and dependency are both true ESM</span></div><div class='line'><span style=\"color: #008000\">// ✅ Works if dependent is true ESM and dependency is transpiled</span></div><div class='line'><span style=\"color: #008000\">// 💥 Crashes if dependent is transpiled and dependency is true ESM</span></div></code></div></pre>\n<h3 id=\"different-module-resolution-algorithms\" style=\"position:relative;\"><a href=\"#different-module-resolution-algorithms\" aria-label=\"different module resolution algorithms permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Different module resolution algorithms</h3>\n<p>Node.js introduced a new module resolution algorithm for resolving ESM imports that differed significantly from the long-standing algorithm for resolving <code>require</code> calls. While not directly related to interop between CJS and ES modules, this difference was one more reason why a seamless migration from transpiled modules to true ESM might not be possible:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// @Filename: add.js</span></div><div class='line'><span style=\"color: #AF00DB\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">add</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">a</span><span style=\"color: #000000\">, </span><span style=\"color: #001080\">b</span><span style=\"color: #000000\">) {</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #AF00DB\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">a</span><span style=\"color: #000000\"> + </span><span style=\"color: #001080\">b</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #000000\">}</span></div><div class='line'></div><div class='line'><span style=\"color: #008000\">// @Filename: math.js</span></div><div class='line'><span style=\"color: #AF00DB\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">*</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./add\"</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #008000\">//            ^^^^^^^</span></div><div class='line'><span style=\"color: #008000\">// Works when transpiled to CJS,</span></div><div class='line'><span style=\"color: #008000\">// but would have to be \"./add.js\"</span></div><div class='line'><span style=\"color: #008000\">// in Node.js ESM.</span></div></code></div></pre>\n<h2 id=\"conclusions\" style=\"position:relative;\"><a href=\"#conclusions\" aria-label=\"conclusions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Conclusions</h2>\n<p>Clearly, a seamless migration from transpiled modules to ESM isn’t possible, at least in Node.js. Where does this leave us?</p>\n<h3 id=\"setting-the-right-module-compiler-option-is-critical\" style=\"position:relative;\"><a href=\"#setting-the-right-module-compiler-option-is-critical\" aria-label=\"setting the right module compiler option is critical permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Setting the right <code>module</code> compiler option is critical</h3>\n<p>Since interoperability rules differ between hosts, TypeScript can’t offer correct checking behavior unless it understands what kind of module is represented by each file it sees, and what set of rules to apply to them. This is the purpose of the <code>module</code> compiler option. (In particular, code that is intended to run in Node.js is subject to stricter rules than code that will be processed by a bundler. The compiler’s output is not checked for Node.js compatibility unless <code>module</code> is set to <code>node16</code> or <code>nodenext</code>.)</p>\n<h3 id=\"applications-with-commonjs-code-should-always-enable-esmoduleinterop\" style=\"position:relative;\"><a href=\"#applications-with-commonjs-code-should-always-enable-esmoduleinterop\" aria-label=\"applications with commonjs code should always enable esmoduleinterop permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Applications with CommonJS code should always enable <code>esModuleInterop</code></h3>\n<p>In a TypeScript <em>application</em> (as opposed to a library that others may consume) where <code>tsc</code> is used to emit JavaScript files, whether <code>esModuleInterop</code> is enabled doesn’t have major consequences. The way you write imports for certain kinds of modules will change, but TypeScript’s checking and emit are in sync, so error-free code should be safe to run in either mode. The downside of leaving <code>esModuleInterop</code> disabled in this case is that it allows you to write JavaScript code with semantics that clearly violate the ECMASCript specification, confusing intuitions about namespace imports and making it harder to migrate to running ES modules in the future.</p>\n<p>In an application that gets processed by a third-party transpiler or bundler, on the other hand, enabling <code>esModuleInterop</code> is more important. All major bundlers and transpilers use an <code>esModuleInterop</code>-like emit strategy, so TypeScript needs to adjust its checking to match. (The compiler always reasons about what will happen in the JavaScript files that <code>tsc</code> would emit, so even if another tool is being used in place of <code>tsc</code>, emit-affecting compiler options should still be set to match the output of that tool as closely as possible.)</p>\n<p><code>allowSyntheticDefaultImports</code> without <code>esModuleInterop</code> should be avoided. It changes the compiler’s checking behavior without changing the code emitted by <code>tsc</code>, allowing potentially unsafe JavaScript to be emitted. Additionally, the checking changes it introduces are an incomplete version of the ones introduced by <code>esModuleInterop</code>. Even if <code>tsc</code> isn’t being used for emit, it’s better to enable <code>esModuleInterop</code> than <code>allowSyntheticDefaultImports</code>.</p>\n<p>Some people object to the inclusion of the <code>__importDefault</code> and <code>__importStar</code> helper functions included in <code>tsc</code>’s JavaScript output when <code>esModuleInterop</code> is enabled, either because it marginally increases the output size on disk or because the interop algorithm employed by the helpers seems to misrepresent Node.js’s interop behavior by checking for <code>__esModule</code>, leading to the hazards discussed earlier. Both of these objections can be addressed, at least partially, without accepting the flawed checking behavior exhibited with <code>esModuleInterop</code> disabled. First, the <code>importHelpers</code> compiler option can be used to import the helper functions from <code>tslib</code> rather than inlining them into each file that needs them. To discuss the second objection, let’s look at a final example:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// @Filename: node_modules/transpiled-dependency/index.js</span></div><div class='line'><span style=\"color: #1C6277\">exports</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">__esModule</span><span style=\"color: #000000\"> = </span><span style=\"color: #0000FF\">true</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #1C6277\">exports</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">default</span><span style=\"color: #000000\"> = </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">doSomething</span><span style=\"color: #000000\">() { </span><span style=\"color: #008000\">/* ... */</span><span style=\"color: #000000\"> };</span></div><div class='line'><span style=\"color: #1C6277\">exports</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">something</span><span style=\"color: #000000\"> = </span><span style=\"color: #A31515\">\"something\"</span><span style=\"color: #000000\">;</span></div><div class='line'></div><div class='line'><span style=\"color: #008000\">// @Filename: node_modules/true-cjs-dependency/index.js</span></div><div class='line'><span style=\"color: #1C6277\">module</span><span style=\"color: #000000\">.</span><span style=\"color: #1C6277\">exports</span><span style=\"color: #000000\"> = </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">doSomethingElse</span><span style=\"color: #000000\">() { </span><span style=\"color: #008000\">/* ... */</span><span style=\"color: #000000\"> };</span></div><div class='line'></div><div class='line'><span style=\"color: #008000\">// @Filename: src/sayHello.ts</span></div><div class='line'><span style=\"color: #AF00DB\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">default</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">sayHello</span><span style=\"color: #000000\">() { </span><span style=\"color: #008000\">/* ... */</span><span style=\"color: #000000\"> }</span></div><div class='line'><span style=\"color: #AF00DB\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #0070C1\">hello</span><span style=\"color: #000000\"> = </span><span style=\"color: #A31515\">\"hello\"</span><span style=\"color: #000000\">;</span></div><div class='line'></div><div class='line'><span style=\"color: #008000\">// @Filename: src/main.ts</span></div><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">doSomething</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"transpiled-dependency\"</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">doSomethingElse</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"true-cjs-dependency\"</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">sayHello</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./sayHello.js\"</span><span style=\"color: #000000\">;</span></div></code></div></pre>\n<p>Assume we’re compiling <code>src</code> to CommonJS for use in Node.js. Without <code>allowSyntheticDefaultImports</code> or <code>esModuleInterop</code>, the import of <code>doSomethingElse</code> from <code>\"true-cjs-dependency\"</code> is an error, and the others are not. To fix the error without changing any compiler options, you could change the import to <code>import doSomethingElse = require(\"true-cjs-dependency\")</code>. However, depending on how the types for the module (not shown) are written, you may also be able to write and call a namespace import, which would be a language-level specification violation. With <code>esModuleInterop</code>, none of the imports shown are errors (and all are callable), but the invalid namespace import would be caught.</p>\n<p>What would change if we decided to migrate <code>src</code> to true ESM in Node.js (say, add <code>\"type\": \"module\"</code> to our root package.json)? The first import, <code>doSomething</code> from <code>\"transpiled-dependency\"</code>, would no longer be callable—it exhibits the “double default” problem, where we’d have to call <code>doSomething.default()</code> rather than <code>doSomething()</code>. (TypeScript understands and catches this under <code>--module node16</code> and <code>nodenext</code>.) But notably, the <em>second</em> import of <code>doSomethingElse</code>, which needed <code>esModuleInterop</code> to work when compiling to CommonJS, works fine in true ESM.</p>\n<p>If there’s something to complain about here, it’s not what <code>esModuleInterop</code> does with the second import. The changes it makes, both allowing the default import and preventing callable namespace imports, are exactly in line with Node.js’s real ESM/CJS interop strategy, and made migration to real ESM easier. The problem, if there is one, is that <code>esModuleInterop</code> seems to fail at giving us a seamless migration path for the <em>first</em> import. But this problem was not introduced by enabling <code>esModuleInterop</code>; the first import was completely unaffected by it. Unfortunately, this problem cannot be solved without breaking the semantic contract between <code>main.ts</code> and <code>sayHello.ts</code>, because the CommonJS output of <code>sayHello.ts</code> looks structurally identical to <code>transpiled-dependency/index.js</code>. If <code>esModuleInterop</code> changed the way the transpiled import of <code>doSomething</code> works to be identical to the way it would work in Node.js ESM, it would change the behavior of the <code>sayHello</code> import in the same way, making the input code violate ESM semantics (thus still preventing the <code>src</code> directory from being migrated to ESM without changes).</p>\n<p>As we’ve seen, there is no seamless migration path from transpiled modules to true ESM. But <code>esModuleInterop</code> is one step in the right direction. For those who still prefer to minimize module syntax transformations and the inclusion of the import helper functions, enabling <code>verbatimModuleSyntax</code> is a better choice than disabling <code>esModuleInterop</code>. <code>verbatimModuleSyntax</code> enforces that the <code>import mod = require(\"mod\")</code> and <code>export = ns</code> syntax be used in CommonJS-emitting files, avoiding all the kinds of import ambiguity we’ve discussed, at the cost of ease of migration to true ESM.</p>\n<h3 id=\"library-code-needs-special-considerations\" style=\"position:relative;\"><a href=\"#library-code-needs-special-considerations\" aria-label=\"library code needs special considerations permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Library code needs special considerations</h3>\n<p>Libraries (that ship declaration files) should take extra care to ensure the types they write are error-free under a wide range of compiler options. For example, it’s possible to write one interface that extends another in such a way that it only compiles successfully when <code>strictNullChecks</code> is disabled. If a library were to publish types like that, it would force all their users to disable <code>strictNullChecks</code> too. <code>esModuleInterop</code> can allow type declarations to contain similarly “infectious” default imports:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// @Filename: /node_modules/dependency/index.d.ts</span></div><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">express</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"express\"</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #0000FF\">declare</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">doSomething</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">req</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">express</span><span style=\"color: #000000\">.</span><span style=\"color: #1C6277\">Request</span><span style=\"color: #000000\">): </span><span style=\"color: #1C6277\">any</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #AF00DB\">export</span><span style=\"color: #000000\"> = </span><span style=\"color: #001080\">doSomething</span><span style=\"color: #000000\">;</span></div></code></div></pre>\n<p>Suppose this default import <em>only</em> works with <code>esModuleInterop</code> enabled, and causes an error when a user without that option references this file. The user should <em>probably</em> enable <code>esModuleInterop</code> anyway, but it’s generally seen as bad form for libraries to make their configurations infectious like this. It would be much better for the library to ship a declaration file like:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">express</span><span style=\"color: #000000\"> = </span><span style=\"color: #AF00DB\">require</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">\"express\"</span><span style=\"color: #000000\">);</span></div><div class='line'><span style=\"color: #008000\">// ...</span></div></code></div></pre>\n<p>Examples like this have led to conventional wisdom that says libraries should <em>not</em> enable <code>esModuleInterop</code>. This advice is a reasonable start, but we’ve looked at examples where the type of a namespace import changes, potentially <em>introducing</em> an error, when enabling <code>esModuleInterop</code>. So whether libraries compile with or without <code>esModuleInterop</code>, they run the risk of writing syntax that makes their choice infectious.</p>\n<p>Library authors who want to go above and beyond to ensure maximum compatibility would do well to validate their declaration files against a matrix of compiler options. But using <code>verbatimModuleSyntax</code> completely sidesteps the issue with <code>esModuleInterop</code> by forcing CommonJS-emitting files to use CommonJS-style import and export syntax. Additionally, since <code>esModuleInterop</code> only affects CommonJS, as more libraries move to ESM-only publishing over time, the relevance of this issue will decline.</p>\n<!--\n\nhttps://github.com/babel/babel/issues/493\nhttps://github.com/babel/babel/issues/95\nhttps://github.com/nodejs/node/pull/16675\nhttps://github.com/nodejs/ecmascript-modules/pull/31\nhttps://github.com/google/traceur-compiler/pull/785#issuecomment-35633727\nhttps://github.com/microsoft/TypeScript/pull/2460\nhttps://github.com/systemjs/systemjs/commit/3b3b03a4b8ffc0f71fab263ef9d5c70f0adc5339\nhttps://github.com/microsoft/TypeScript/pull/5577\nhttps://github.com/microsoft/TypeScript/pull/19675\nhttps://github.com/microsoft/TypeScript/issues/16093\nhttps://github.com/nodejs/modules/issues/139\nhttps://github.com/microsoft/TypeScript/issues/54212\n\n-->","headings":[{"value":"allowSyntheticDefaultImports and esModuleInterop","depth":2},{"value":"Interop in Node.js","depth":2},{"value":"No __esModule detection (the “double default” problem)","depth":3},{"value":"Unreliable named exports","depth":3},{"value":"Cannot require a true ES module","depth":3},{"value":"Different module resolution algorithms","depth":3},{"value":"Conclusions","depth":2},{"value":"Setting the right module compiler option is critical","depth":3},{"value":"Applications with CommonJS code should always enable esModuleInterop","depth":3},{"value":"Library code needs special considerations","depth":3}],"frontmatter":{"permalink":"/docs/handbook/modules/appendices/esm-cjs-interop.html","title":"Modules - ESM/CJS Interoperability","disable_toc":null,"handbook":null,"oneline":"A detailed look at interoperability between ES modules and CommonJS modules","preamble":null,"deprecated_by":null,"deprecation_redirects":null,"experimental":null}},"prev":null,"next":null},"pageContext":{"id":"3-modules---esm/cjs-interoperability","slug":"/docs/handbook/modules/appendices/esm-cjs-interop.html","repoPath":"/packages/documentation/copy/en/modules-reference/appendices/ESM-CJS-Interop.md","lang":"en","modifiedTime":"2024-10-21T12:33:11.301Z"}},"staticQueryHashes":[]}