{"componentChunkName":"component---src-templates-play-example-tsx","path":"/ko/play/typescript/language/type-guards.ts.html","result":{"pageContext":{"name":"Type Guards","title":"Type Guards","lang":"ko","html":" 타입 가드는 코드를 통해 코드 흐름 분석에 영향을 주는 용어입니다.\n TypeScript는 런타임에서 객체가 유효한지 판단하는 \n 기존의 JavaScript 동작을 이용해서 코드 흐름에 영향을 줄 수 있습니다.\n 이 예시는 여러분이 다음 예제를 읽어봤다고 가정하겠습니다:code-flow\n\n 예시를 실행해보기 위해 어떤 클래스를 생성해볼 것입니다.\n 여기에 인터넷 또는 전화 주문을 다루는 시스템이 있습니다.\n\n<code><pre>\ninterface Order {\n  address: string;\n}\ninterface TelephoneOrder extends Order {\n  callerNumber: string;\n}\ninterface InternetOrder extends Order {\n  email: string;\n}\n\n// 두 개의 Order 서브 타입 또는 undefined가 될 수 있는 타입이 있습니다\ntype PossibleOrders = TelephoneOrder | InternetOrder | undefined;\n\n// PossibleOrder를 반환하는 함수가 있습니다\ndeclare function getOrder(): PossibleOrders;\nconst possibleOrder = getOrder();\n\n</pre></code>\n// 특정 키가 유니언을 좁히기 위한 객체에 있는지 확인하는\n \"in\" 연산자를 사용할 수 있습니다.\n (\"in\"은 객체 키를 검사하기 위한 JavaScript 연산자입니다.)\n\n<code><pre>\nif (\"email\" in possibleOrder) {\n  const mustBeInternetOrder = possibleOrder;\n}\n\n</pre></code>\n// 인터페이스를 따르는 클래스가 있는 경우\n JavaScript \"instanceof\" 연산자를 사용할 수 있습니다:\n\n<code><pre>\nclass TelephoneOrderClass {\n  address: string;\n  callerNumber: string;\n}\n\nif (possibleOrder instanceof TelephoneOrderClass) {\n  const mustBeTelephoneOrder = possibleOrder;\n}\n\n</pre></code>\n// 유니언을 좁을 좁히기 위해\n JavaScript \"typeof\" 연산자를 사용할 수 있습니다.\n JavaScript 내의 기본형(문자열, 객체, 숫자 같은)만 동작합니다.\n\n<code><pre>\nif (typeof possibleOrder === \"undefined\") {\n  const definitelyNotAnOder = possibleOrder;\n}\n\n</pre></code>\n// 여기에서 typeof가 가능한 값의 전체 리스트를\n 확인할 수 있습니다: https://developer.mozilla.org/docs/Web/JavaScript/Reference/Operators/typeof\n\n JavaScript 연산자를 사용하는 것은 여러분을 여기까지만 도달할 수 있게 만듭니다.\n 자체 객체 타입을 검사하고 싶다면,\n 타입 서술어 함수를 사용할 수 있습니다.\n\n 타입 서술어 함수는\n 함수가 true를 반환할 때 반환 타입이 코드 흐름 분석에\n 정보를 제공하는 함수입니다.\n\n possible order를 사용하면서, possibleOrder가 어느 타입인지 선언하기 위해서\n 두 가지 타입 가드를 사용할 수 있습니다:\n\n<code><pre>\nfunction isAnInternetOrder(order: PossibleOrders): order is InternetOrder {\n  return order && \"email\" in order;\n}\n\nfunction isATelephoneOrder(order: PossibleOrders): order is TelephoneOrder {\n  return order && \"calledNumber\" in order;\n}\n\n</pre></code>\n// 이제 if문 내부에서 타입이 어떤 possibleOrder인지 좁히기 위해\n if문 안에서 이러한 함수들을 사용할 수 있습니다:\n\n<code><pre>\nif (isAnInternetOrder(possibleOrder)) {\n  console.log(\"Order received via email:\", possibleOrder.email);\n}\n\nif (isATelephoneOrder(possibleOrder)) {\n  console.log(\"Order received via phone:\", possibleOrder.callerNumber);\n}\n\n</pre></code>\n// 여기에서 코드 흐름 분석에 대해 더 읽어볼 수 있습니다:\n\n  - example:code-flow\n  - example:type-guards\n  - example:discriminate-types\n","redirectHref":"ko/play/?#example/type-guards"}},"staticQueryHashes":[]}