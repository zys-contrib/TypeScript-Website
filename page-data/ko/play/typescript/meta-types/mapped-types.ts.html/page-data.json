{"componentChunkName":"component---src-templates-play-example-tsx","path":"/ko/play/typescript/meta-types/mapped-types.ts.html","result":{"pageContext":{"name":"Mapped Types","title":"Mapped Types","lang":"ko","html":" 매핑된 타입은 다른 타입을 기반으로 새로운 타입을 만드는 방법입니다.\n 또한 효과적으로 타입을 변환할 수 있습니다.\n\n 매핑된 타입을 사용하는 일반적인 케이스는\n 기존 타입의 부분적인 하위집합을 다루는 것입니다.\n 예를 들어 다음 API는 Artist를 반환할 수 있습니다:\n\n<code><pre>\ninterface Artist {\n  id: number;\n  name: string;\n  bio: string;\n}\n\n</pre></code>\n// 그러나, Artist의 하위집합만 변경하기 위해\n API를 수정해야 한다면\n 일반적으로 타입을 추가로 만들어야 했습니다.\n\n<code><pre>\ninterface ArtistForEdit {\n  id: number;\n  name?: string;\n  bio?: string;\n}\n\n</pre></code>\n// 위에 Artist 타입과 같지 않을 수도 있습니다.\n 매핑된 타입은 기존 타입에서\n 변화를 만들어 낼 수 있습니다.\n\n<code><pre>\ntype MyPartialType<Type> = {\n  // 모든 기존 프로퍼티에 대해서\n  // Type의 타입 내부는 ?: 버전으로 변환합니다\n  [Property in keyof Type]?: Type[Property];\n};\n\n</pre></code>\n// 이제 수정하는 인터페이스를 추가로 만드는 대신에\n 매핑된 타입을 사용할 수 있습니다:\n<code><pre>\ntype MappedArtistForEdit = MyPartialType<Artist>;\n\n</pre></code>\n// 완벽해 보이지만,\n id 값이 null 이 되는 상황을 방지할 수 없습니다.\n 그래서 교차 타입을 사용하여 빠르게 하나를 개선해 봅시다.\n (예시를 살펴보세요:union-and-intersection-types)\n\n<code><pre>\ntype MyPartialTypeForEdit<Type> = {\n  [Property in keyof Type]?: Type[Property];\n} & { id: number };\n\n</pre></code>\n// 매핑된 타입의 부분적인 결과를 가지며\n id: number set를 가진 객체와 병합합니다.\n 효과적으로 id를 강제로 타입 안에 넣어줍니다.\n\n<code><pre>\ntype CorrectMappedArtistForEdit = MyPartialTypeForEdit<Artist>;\n\n</pre></code>\n// 매핑된 타입이 어떻게 동작하는지에 대한\n 매우 간단한 예시입니다만, 기초 대부분을 다룹니다.\n 더 깊게 살펴보고 싶다면, 핸드북을 참고하세요:\n\n https://www.typescriptlang.org/docs/handbook/advanced-types.html#mapped-types\n","redirectHref":"ko/play/?#example/mapped-types"}},"staticQueryHashes":[]}