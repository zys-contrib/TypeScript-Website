{"componentChunkName":"component---src-templates-play-example-tsx","path":"/ko/play/3-8/breaking-changes/checking-unions-with-index-signatures.ts.html","result":{"pageContext":{"name":"Checking Unions with Index Signatures","title":"Checking Unions with Index Signatures","lang":"ko","html":" 이전 버전의 TypeScript에서\n 검사기는 유니언의 선언되지 않은 필드가\n 색인된 타입과 동일한지 확인하지 않았습니다.\n\n 여기에서 색인된 타입에 관해 배워볼 수 있습니다: example:indexed-types\n\n 예를 들어, 아래에 있는 IdentifierCache는\n 객체에 있는 키가 숫자임을 보여줍니다:\n\n<code><pre>\ntype IdentifierCache = { [key: string]: number };\n\n</pre></code>\n// 'file_a'가 문자열 값을 가지고 있어서\n 실패를 의미합니다\n\n<code><pre>\nconst cacheWithString: IdentifierCache = { file_a: \"12343\" };\n\n</pre></code>\n// 그러나, 유니언에 넣을 때는\n 유효성 검사가 실행되지 않았습니다:\n\n<code><pre>\nlet userCache: IdentifierCache | { index: number };\nuserCache = { file_one: 5, file_two: \"abc\" };\n\n</pre></code>\n// 이 부분은 고쳐졌고,\n 컴파일러에서 'file_two'에 관한 오류가 발생합니다.\n\n 키가 다른 타입일 때도 고려합니다\n 예를 들어: ([key: string] 그리고 [key: number])\n\n<code><pre>\ntype IdentifierResponseCache = { [key: number]: number };\n\nlet resultCache: IdentifierCache | IdentifierResponseCache;\nresultCache = { file_one: \"abc\" };\n","redirectHref":"ko/play/?ts=3.8.3#example/checking-unions-with-index-signatures"}},"staticQueryHashes":[]}