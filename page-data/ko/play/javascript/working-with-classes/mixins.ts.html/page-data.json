{"componentChunkName":"component---src-templates-play-example-tsx","path":"/ko/play/javascript/working-with-classes/mixins.ts.html","result":{"pageContext":{"name":"Mixins","title":"Mixins","lang":"ko","html":"\n TypeScript가 지원하는 JavaScript에 있는 클래스를 위해\n 가짜 다중 상속 패턴인 믹스인이 있습니다.\n 다중 상속 패턴은 많은 클래스가 합쳐진\n 하나의 클래스를 생성할 수 있게 해줍니다.\n\n 시작하기 위해, 다른 클래스로부터 확장하는 타입이 필요합니다.\n 주요 책임은 전달받은 타입이\n 하나의 클래스라고 선언하는 것입니다.\n\n<code><pre>\ntype Constructor = new (...args: any[]) => {};\n\n</pre></code>\n// 그러고 나서 래핑하여 최종 클래스에 확장하는\n 클래스 시리즈를 생성할 수 있습니다.\n 비슷한 객체가 다른 능력을 갖출 때, 이 패턴은 잘 동작합니다.\n\n 믹스인은 캡슐화된 private 프로퍼티로 변경하기 위해\n scale 프로퍼티를 getter와 setter를 함께 추가합니다:\n\n<code><pre>\nfunction Scale<TBase extends Constructor>(Base: TBase) {\n  return class extends Base {\n    // 믹스인은 private/protected 프로퍼티를 선언할 수 없겠지만,\n    // ES2020 private 필드를 사용할 수 있습니다\n    _scale = 1;\n\n    setScale(scale: number) {\n      this._scale = scale;\n    }\n\n    get scale(): number {\n      return this._scale;\n    }\n  };\n}\n\n</pre></code>\n// 믹스인은 현대식 컴퓨터가 깊이를 만드는 데 사용하는\n 알파 구성요소에 대한 추가 메서드를 추가합니다:\n\n<code><pre>\nfunction Alpha<TBase extends Constructor>(Base: TBase) {\n  return class extends Base {\n    alpha = 1;\n\n    setHidden() {\n      this.alpha = 0;\n    }\n\n    setVisible() {\n      this.alpha = 1;\n    }\n\n    setAlpha(alpha: number) {\n      this.alpha = alpha;\n    }\n  };\n}\n\n// 확장될 간단한 스프라이트 기반 클래스:\n\nclass Sprite {\n  name = \"\";\n  x = 0;\n  y = 0;\n\n  constructor(name: string) {\n    this.name = name;\n  }\n}\n\n</pre></code>\n// 서로 다른 기능을 가진\n 2개의 다른 스프라이트 타입을 만듭니다:\n\n<code><pre>\nconst ModernDisplaySprite = Alpha(Scale(Sprite));\nconst EightBitSprite = Scale(Sprite);\n\n</pre></code>\n// 이런 클래스의 인스턴스를 생성하는 것은\n 믹스인 때문에 객체가 서로 다른\n 프로퍼티와 메서드의 모음을 가진다는 것을 나타냅니다:\n\n<code><pre>\nconst flappySprite = new ModernDisplaySprite(\"Bird\");\nflappySprite.x = 10;\nflappySprite.y = 20;\nflappySprite.setVisible();\nflappySprite.setScale(0.8);\nconsole.log(flappySprite.scale);\n\nconst gameBoySprite = new EightBitSprite(\"L block\");\ngameBoySprite.setScale(0.3);\n\n</pre></code>\n// EightBitSprite가 알파로 변경하기 위한\n 믹스인이 없으니 실패합니다:\n<code><pre>\ngameBoySprite.setAlpha(0.5);\n\n</pre></code>\n// 래핑한 클래스에 대해 더 많이 보장하길 원한다면,\n 제네릭과 함께 생성자를 사용할 수 있습니다.\n\n<code><pre>\ntype GConstructor<T = {}> = new (...args: any[]) => T;\n\n</pre></code>\n// 이제 이 믹스인이 기반 클래스가 특정한 형태일 때만\n 적용할 수 있도록 선언할 수 있습니다.\n\n<code><pre>\ntype Moveable = GConstructor<{ setXYAcceleration: (x: number, y: number) => void }>;\n\n</pre></code>\n// GConstructor에 대한 매개변수에 있는\n 함수 존재 여부에 따라서 믹스인을 생성할 수 있습니다.\n\n<code><pre>\nfunction Jumpable<TBase extends Moveable>(Base: TBase) {\n  return class extends Base {\n    jump() {\n      // 이 믹스인은 이제 setXYAcceleration에 대하여 알고 있습니다\n      this.setXYAcceleration(0, 20);\n    }\n  };\n}\n\n</pre></code>\n// 믹스인 계층에 setXYAcceleration를 추가하는 클래스가 \n 존재할 때까지 이 스프라이트를 생성할 수 없습니다:\n<code><pre>\nconst UserSprite = new Jumpable(ModernDisplaySprite);\n","redirectHref":"ko/play/?#example/mixins"}},"staticQueryHashes":[]}