{"componentChunkName":"component---src-templates-play-example-tsx","path":"/ko/play/javascript/functions-with-javascript/function-chaining.ts.html","result":{"pageContext":{"name":"Function Chaining","title":"Function Chaining","lang":"ko","html":"\n 함수 체이닝 API는 JavaScript에서 흔한 패턴으로,\n JavaScript 의 중첩 특성으로 인해\n 중간값을 줄이고 가독성을 높혀\n 코드를 집중시킬 수 있습니다.\n\n 체이닝으로 동작하는 흔한 API는 jQuery입니다.\n DefinitelyTyped의 타입과 함께 사용한\n jQuery 예시입니다.:\n\n<code><pre>\nimport $ from \"jquery\";\n\n// jQuery API 사용 예시:\n\n$(\"#navigation\").css(\"background\", \"red\").height(300).fadeIn(200);\n\n</pre></code>\n// 위 라인에 점을 추가해보면,\n 긴 함수 리스트를 보게 될 것입니다.\n 이 패턴은 JavaScript에서 쉽게 재현할 수 있습니다.\n 핵심은 반드시 항상 같은 오브젝트를 반환하는 것입니다.\n\n 여기 체이닝 API를 만드는 API 예시가 있습니다.\n 핵심은 내부 상태를 파악하고 있는 외부 함수와\n 항상 자신을 반환하는 API를\n 노출하는 오브젝트를 갖는 것입니다.\n\n<code><pre>\nconst addTwoNumbers = (start = 1) => {\n  let n = start;\n\n  const api = {\n    // API에 있는 각 함수를 실행하세요\n    add(inc: number = 1) {\n      n += inc;\n      return api;\n    },\n\n    print() {\n      console.log(n);\n      return api;\n    },\n  };\n  return api;\n};\n\n</pre></code>\n// jQuery에서 본 것처럼\n 같은 스타일의 API를 허용:\n\n<code><pre>\naddTwoNumbers(1).add(3).add().print().add(1);\n\n// 클래스를 사용하는 비슷한 예시:\n\nclass AddNumbers {\n  private n: number;\n\n  constructor(start = 0) {\n    this.n = start;\n  }\n\n  public add(inc = 1) {\n    this.n = this.n + inc;\n    return this;\n  }\n\n  public print() {\n    console.log(this.n);\n    return this;\n  }\n}\n\n// 여기에서 동작:\n\nnew AddNumbers(2).add(3).add().print().add(1);\n\n</pre></code>\n// 이 예시는 JavaScript 패턴에\n 도구를 제공하는 방법을 제공하기 위해서\n TypeScript 타입 추론을 사용했습니다.\n\n 더 많은 예시:\n\n  - example:code-flow\n","redirectHref":"ko/play/?esModuleInterop=true#example/function-chaining"}},"staticQueryHashes":[]}