{"componentChunkName":"component---src-templates-play-example-tsx","path":"/ko/play/javascript/functions-with-javascript/generic-functions.ts.html","result":{"pageContext":{"name":"Generic Functions","title":"Generic Functions","lang":"ko","html":" 제네릭(Generics)은 타입을 다른 타입의 변수로\n 사용하는 방법과 메타데이터를 제공합니다.\n\n 이 예제는 앞으로도 가볍게 유지될 것입니다.\n 여러분은 제네릭으로 많은 작업을 수행하게 될 수도 있고,\n 언젠가는 제네릭을 사용하는 매우 복잡한 코드를 볼 수도 있습니다.\n 그렇다고 제네릭이 복잡하다는 이야기는 아닙니다.\n\n 입력 객체를 배열로 감싸는 예부터 살펴보겠습니다.\n 이 경우 전달된 하나의 변수에 대한 타입만\n 고려하면 됩니다:\n\n<code><pre>\nfunction wrapInArray<Type>(input: Type): Type[] {\n  return [input];\n}\n\n</pre></code>\n// 참고: T 타입은 흔히 볼 수 있습니다.\n 이는 문화적으로 사람들이 for 루프에서\n 색인으로 i 변수를 사용하는 것과 유사합니다.\n T는 일반적으로 Type을 나타내므로 명확성을 위해서는 전체 이름을 사용합니다.\n\n 위 함수는 전달된 변수 타입을 항상 유지시켜\n (배열 형태지만) 같은 변수 타입으로 전달할 수 있도록\n 인터페이스를 사용합니다.\n\n<code><pre>\nconst stringArray = wrapInArray(\"hello generics\");\nconst numberArray = wrapInArray(123);\n\n</pre></code>\n// 객체 배열을 반환하는 함수에 string 배열을\n 할당할 수 있는지 확인하는 것을 통해\n 예상대로 동작하는지 확인할 수 있습니다:\n<code><pre>\nconst notStringArray: string[] = wrapInArray({});\n\n</pre></code>\n// 다음과 같이 타입을 직접 추가하여\n 제네릭 인터페이스를 건너 뛸 수도 있습니다:\n<code><pre>\nconst stringArray2 = wrapInArray<string>(\"\");\n\n</pre></code>\n// wrapInArray 함수에는\n 모든 타입이 사용될 수 있지만,\n 타입의 일정 부분만을 허용하는 경우도 있습니다.\n 이 경우 타입이 특정 타입을 확장해야 한다고 할 수 있습니다.\n\n<code><pre>\ninterface Drawable {\n  draw: () => void;\n}\n\n</pre></code>\n// 이 함수는 화면에 그리는 기능을 가진 함수가 있는\n 객체 집합을 취합니다.\n<code><pre>\nfunction renderToScreen<Type extends Drawable>(input: Type[]) {\n  input.forEach(i => i.draw());\n}\n\nconst objectsWithDraw = [{ draw: () => {} }, { draw: () => {} }];\nrenderToScreen(objectsWithDraw);\n\n// draw 함수가 누락되면 이 함수는 동작하지 않습니다:\n\nrenderToScreen([{}, { draw: () => {} }]);\n\n</pre></code>\n// 제네릭은 여러 변수를 다룰 때\n 복잡해 보일 수 있습니다.\n 다음은 다양한 입력 타입과\n 캐시의 집합을 가진 캐싱 함수의 예제입니다.\n\n<code><pre>\ninterface CacheHost {\n  save: (a: any) => void;\n}\n\nfunction addObjectToCache<Type, Cache extends CacheHost>(obj: Type, cache: Cache): Cache {\n  cache.save(obj);\n  return cache;\n}\n\n</pre></code>\n// 이는 위 예제와 동일하지만 추가 파라미터가 있습니다.\n 참고: 위에서는 동작을 수행하기 위해서 any 타입을 사용해야 했습니다.\n 이 문제는 제네릭 인터페이스를 사용하여 해결할 수 있습니다.\n\n<code><pre>\ninterface CacheHostGeneric<ContentType> {\n  save: (a: ContentType) => void;\n}\n\n</pre></code>\n// 이제 CacheHostGeneric을 사용할 때는\n ContentType이 무엇인지 명시해 주어야 합니다.\n\n<code><pre>\nfunction addTypedObjectToCache<Type, Cache extends CacheHostGeneric<Type>>(obj: Type, cache: Cache): Cache {\n  cache.save(obj);\n  return cache;\n}\n\n</pre></code>\n// 제네릭은 문법 측면에서 꽤 빠르게 내용이 확장되었지만,\n 더 많은 안전성을 제공합니다.\n 이는 상호 절충으로 더 많은 지식을 쌓을 수 있습니다.\n 다른 사용자에게 API를 제공할 때 제네릭은 사용자 고유의 타입을\n 전체 코드 인터페이스와 함께 사용할 수 있는 유연한 방법을 제공합니다.\n\n 클래스와 인터페이스가 있는 제네릭의 더 많은 예제는 여기서 볼 수 있습니다:\n\n example:advanced-classes\n example:typescript-with-react\n https://www.typescriptlang.org/docs/handbook/generics.html\n","redirectHref":"ko/play/?#example/generic-functions"}},"staticQueryHashes":[]}