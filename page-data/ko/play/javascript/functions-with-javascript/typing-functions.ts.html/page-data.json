{"componentChunkName":"component---src-templates-play-example-tsx","path":"/ko/play/javascript/functions-with-javascript/typing-functions.ts.html","result":{"pageContext":{"name":"Typing Functions","title":"Typing Functions","lang":"ko","html":" TypeScript의 추론으로 제공되는 정보로도 충분합니다만,\n 함수의 형태를 문서화하는\n 다양한 방법을 제공하는 많은 방식이 있습니다.\n\n 우선 좋은 위치는 선택적 매개변수를 살펴보는 것입니다.\n 이는 매개변수를 생략할 수 있다는 것을 알려주는 방법입니다.\n\n<code><pre>\nlet i = 0;\nconst incrementIndex = (value?: number) => {\n  i += value === undefined ? 1 : value;\n};\n\n// 이 함수는 다음과 같이 호출할 수 있습니다:\n\nincrementIndex();\nincrementIndex(0);\nincrementIndex(3);\n\n</pre></code>\n// 함수를 작성할 때 타입 추론을 제공하는\n 함수 매개변수를 입력할 수 있습니다.\n\n<code><pre>\nconst callbackWithIndex = (callback: (i: number) => void) => {\n  callback(i);\n};\n\n</pre></code>\n// 함수 인터페이스를 임베딩하면\n 화살표 때문에 읽기 어려울 수 있습니다.\n 타입 별칭을 사용하여 함수 매개변수에 이름을 지정하게 합니다.\n\n<code><pre>\ntype NumberCallback = (i: number) => void;\nconst callbackWithIndex2 = (callback: NumberCallback) => {\n  callback(i);\n};\n\n// 다음과 같이 호출할 수 있습니다:\n\ncallbackWithIndex(index => {\n  console.log(index);\n});\n\n</pre></code>\n// 위에 있는 index에 호버하면\n TypeScript가 index를 숫자로 정확히 추론한 것을 확인해볼 수 있습니다.\n\n 인스턴스 참조로 함수를 전달할 때도, TypeScript 추론은 동작합니다.\n 확인하기 위해,\n number를 string으로 변경했던 함수를 사용합니다:\n\n<code><pre>\nconst numberToString = (n: number) => {\n  return n.toString();\n};\n\n</pre></code>\n// 모든 number를 string으로 변환하기 위하여\n 배열에 map과 같은 함수에서 사용할 수 있으며,\n 아래에 있는 stringedNumbers에 호버해보면 예상된 타입을 확인할 수 있습니다.\n<code><pre>\nconst stringedNumbers = [1, 4, 6, 10].map(i => numberToString(i));\n\n</pre></code>\n// 코드를 간소화하여, 직접 함수를 전달할 수 있고\n 더 집중된 코드로 동일한 결과를 얻을 수 있습니다:\n<code><pre>\nconst stringedNumbersTerse = [1, 4, 6, 10].map(numberToString);\n\n</pre></code>\n// 많은 타입을 수용하는 함수가 있을 수도 있지만,\n 몇 개의 프로퍼티에만 관심이 있을 것입니다.\n 이것은 타입에서 색인 된 시그니처에 대한 유용한 사례입니다.\n 다음 타입은 이 함수가 프로퍼티 이름이 포함되어 있다면\n 어떠한 객체도 사용해도 괜찮다고 선언합니다:\n\n<code><pre>\ninterface AnyObjectButMustHaveName {\n  name: string;\n  [key: string]: any;\n}\n\nconst printFormattedName = (input: AnyObjectButMustHaveName) => {};\n\nprintFormattedName({ name: \"joey\" });\nprintFormattedName({ name: \"joey\", age: 23 });\n\n</pre></code>\n// index-signatures에 관해 더 배우고 싶다면\n 다음 내용을 권장합니다:\n\n https://www.typescriptlang.org/docs/handbook/interfaces.html#excess-property-checks\n https://basarat.gitbooks.io/typescript/docs/types/index-signatures.html\n\n tsconfig flag인 suppressExcessPropertyErrors를 통해\n 모든 곳에서 이런 종류의 동작을 또한 허용할 수 있다고\n 하지만, 여러분의 API를 사용하는 다른 사람이\n 이 설정을 해제했는지는 알 수 없습니다.\n\n JavaScript에 있는 함수는 다른 매개변수 모음을 허용합니다.\n 설명을 위한 두 가지 공통 패턴이 있습니다:\n 매개변수 또는 반환에 대한 유니언 타입과 함수 오버로드.\n\n 매개변수에 유니언 타입을 사용하는 것은\n 한 개 또는 두 개의 변경 점만 있고,\n 함수 간에 문서 변경이 필요하지 않는 경우에 의미 있습니다.\n\n<code><pre>\nconst boolOrNumberFunction = (input: boolean | number) => {};\n\nboolOrNumberFunction(true);\nboolOrNumberFunction(23);\n\n</pre></code>\n// 반면에 함수 오버로드는 매개변수와 반환 타입에 대한\n 더 다양한 구문을 제공합니다.\n\n<code><pre>\ninterface BoolOrNumberOrStringFunction {\n  /** bool 타입을 갖고, bool 타입을 반환 */\n  (input: boolean): boolean;\n  /** number 타입을 갖고, number 타입을 반환 */\n  (input: number): number;\n  /** string 타입을 갖고, bool 타입을 반환 */\n  (input: string): boolean;\n}\n\n</pre></code>\n// 처음 보는 선언이라면,\n TypeScript에 이 파일의 런타임에서는 존재하지 않더라도\n 무언가 존재한다고 알려줍니다.\n 부작용과 함께 매핑된 코드는 유용하지만,\n 많은 코드가 있는 구현을 만드는 데모에 매우 유용합니다.\n\n<code><pre>\ndeclare const boolOrNumberOrStringFunction: BoolOrNumberOrStringFunction;\n\nconst boolValue = boolOrNumberOrStringFunction(true);\nconst numberValue = boolOrNumberOrStringFunction(12);\nconst boolValue2 = boolOrNumberOrStringFunction(\"string\");\n\n</pre></code>\n// 위 값과 함수에 호버해보면\n 올바른 문서와 반환 값을 확인할 수 있습니다.\n\n 함수 오버로드를 사용하는 것으로도 충분합니다만,\n 입력과 반환 값의 다른 타입을 다루기 위한 다른 도구가 있으며\n 이는 제네릭입니다.\n\n 타입 정의에서 placeholder 변수로\n 타입을 가지는 방법을 제공합니다.\n\n example:generic-functions\n example:function-chaining\n","redirectHref":"ko/play/?#example/typing-functions"}},"staticQueryHashes":[]}