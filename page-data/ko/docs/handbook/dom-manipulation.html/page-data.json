{"componentChunkName":"component---src-templates-documentation-tsx","path":"/ko/docs/handbook/dom-manipulation.html","result":{"data":{"markdownRemark":{"id":"94b5e428-9605-5c68-aa0b-9eeab31d74b9","excerpt":"DOM 조작 (DOM Manipulation) HTMLElement 타입 탐구 (An exploration into the HTMLElement type) 표준화 이후 20여 년 동안, JavaScript는 많은 발전을 이루었습니다. 2020년에는 서버, 데이터 사이언스, 그리고 IoT…","html":"<h1 id=\"dom-조작-dom-manipulation\" style=\"position:relative;\"><a href=\"#dom-%EC%A1%B0%EC%9E%91-dom-manipulation\" aria-label=\"dom 조작 dom manipulation permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>DOM 조작 (DOM Manipulation)</h1>\n<h3 id=\"htmlelement-타입-탐구-an-exploration-into-the-htmlelement-type\" style=\"position:relative;\"><a href=\"#htmlelement-%ED%83%80%EC%9E%85-%ED%83%90%EA%B5%AC-an-exploration-into-the-htmlelement-type\" aria-label=\"htmlelement 타입 탐구 an exploration into the htmlelement type permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><em><code>HTMLElement</code> 타입 탐구</em> (<em>An exploration into the <code>HTMLElement</code> type</em>)</h3>\n<p>표준화 이후 20여 년 동안, JavaScript는 많은 발전을 이루었습니다. 2020년에는 서버, 데이터 사이언스, 그리고 IoT 기기에도 JavaScript를 사용할 수 있지만, 가장 인기 있는 활용 사례는 웹 브라우저인 것을 기억하는 것이 중요합니다.</p>\n<p>웹 사이트는 HTML 및/또는 XML 문서로 구성됩니다. 이러한 문서들은 정적이어서, 변하지 않습니다. <em>문서 객체 모델(DOM)은</em> 정적 웹 사이트를 기능적으로 작동시키기 위해 브라우저에 의해 구현된 프로그래밍 인터페이스입니다. DOM API를 사용하면 문서의 구조, 스타일, 그리고 내용을 변경할 수 있습니다. API는 매우 강력해서 이를 바탕으로 보다 쉽게 동적인 웹사이트들 개발하기 위해 수많은 프런트엔드 프레임워크(jQuery, React, Angular 등)가 개발되었습니다.</p>\n<p>TypeScript는 타입이 있는 JavaScript 상위 집합(superset)이며, DOM API에 대한 타입 정의를 제공합니다. 이러한 정의는 모든 기본 TypeScript 프로젝트에서 쉽게 사용 가능합니다. <em>lib.dom.d.ts</em> 에 있는 2만여 줄의 정의 중에서, 가장 눈에 띄는 것은 <code>HTMLElement</code>입니다. 이 타입은 TypeScript를 사용한 DOM 조작의 중축입니다.</p>\n<blockquote>\n<p><a href=\"https://github.com/microsoft/TypeScript/blob/master/lib/lib.dom.d.ts\">DOM 타입 정의</a>에 대한 소스코드는 이곳에서 볼 수 있습니다.</p>\n</blockquote>\n<h2 id=\"기본-예제-basic-example\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%B3%B8-%EC%98%88%EC%A0%9C-basic-example\" aria-label=\"기본 예제 basic example permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기본 예제 (Basic Example)</h2>\n<p>간단한 예시 파일 <em>index.html</em>:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class='code-container'><code><div class='line'><span style=\"color: undefined\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;&lt;title&gt;TypeScript Dom Manipulation&lt;/title&gt;&lt;/head&gt;\n  &lt;body&gt;\n    &lt;div id=\"app\"&gt;&lt;/div&gt;\n    &lt;!-- Assume index.js is the compiled output of index.ts --&gt;\n    &lt;script src=\"index.js\"&gt;&lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;</span></div></code></div></pre>\n<p><code>#app</code> 요소에 <code>&#x3C;p>Hello, World&#x3C;/p></code> 요소를 추가하는 TypeScript 스크립트를 살펴보겠습니다.</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// 1. id 프로퍼티를 사용하여 div 요소를 선택합니다.</span></div><div class='line'><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #0070C1\">app</span><span style=\"color: #000000\"> = </span><span style=\"color: #001080\">document</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">getElementById</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">\"app\"</span><span style=\"color: #000000\">);</span></div><div class='line'></div><div class='line'><span style=\"color: #008000\">// 2. 새로운 &lt;p&gt;&lt;/p&gt; 요소를 프로그래밍 방식으로 생성합니다.</span></div><div class='line'><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #0070C1\">p</span><span style=\"color: #000000\"> = </span><span style=\"color: #001080\">document</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">createElement</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">\"p\"</span><span style=\"color: #000000\">);</span></div><div class='line'></div><div class='line'><span style=\"color: #008000\">// 3. 텍스트 내용을 추가합니다.</span></div><div class='line'><span style=\"color: #001080\">p</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">textContent</span><span style=\"color: #000000\"> = </span><span style=\"color: #A31515\">\"Hello, World!\"</span><span style=\"color: #000000\">;</span></div><div class='line'></div><div class='line'><span style=\"color: #008000\">// 4. div 요소에 p 요소를 자식 노드로 추가합니다.</span></div><div class='line'><span style=\"color: #001080\">app</span><span style=\"color: #000000\">?.</span><span style=\"color: #795E26\">appendChild</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">p</span><span style=\"color: #000000\">);</span></div></code></div></pre>\n<p><em>index.html</em> 페이지를 컴파일하고 실행한 후, HTML 결과:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">html</div><div class='code-container'><code><div class='line'><span style=\"color: #800000\">&lt;div</span><span style=\"color: #000000\"> </span><span style=\"color: #EE0000\">id</span><span style=\"color: #000000\">=</span><span style=\"color: #0000FF\">\"app\"</span><span style=\"color: #800000\">&gt;</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #800000\">&lt;p&gt;</span><span style=\"color: #000000\">Hello, World!</span><span style=\"color: #800000\">&lt;/p&gt;</span></div><div class='line'><span style=\"color: #800000\">&lt;/div&gt;</span></div></code></div></pre>\n<h2 id=\"document-인터페이스-the-document-interface\" style=\"position:relative;\"><a href=\"#document-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-the-document-interface\" aria-label=\"document 인터페이스 the document interface permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>Document</code> 인터페이스 (The <code>Document</code> Interface)</h2>\n<p>TypeScript 코드의 첫 번째 줄은 전역변수 <code>document</code>를 사용하며, 그 변수를 검사하면 <em>lib.dom.d.ts</em> 파일의 <code>Document</code> 인터페이스에 의해 정의된 것으로 표시됩니다. 그 코드의 스니펫(snippet)에는 <code>getElementById</code>와 <code>createElement</code>라는 두 가지 메서드 호출이 포함되어 있습니다.</p>\n<h3 id=\"documentgetelementbyid\" style=\"position:relative;\"><a href=\"#documentgetelementbyid\" aria-label=\"documentgetelementbyid permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>Document.getElementById</code></h3>\n<p>이 메서드의 정의는 다음과 같습니다:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #795E26\">getElementById</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">elementId</span><span style=\"color: #000000\">: </span><span style=\"color: #001080\">string</span><span style=\"color: #000000\">): </span><span style=\"color: #001080\">HTMLElement</span><span style=\"color: #000000\"> | </span><span style=\"color: #0000FF\">null</span><span style=\"color: #000000\">;</span></div></code></div></pre>\n<p>문자열 id 요소가 전달되면 <code>HTMLElement</code> 또는 <code>null</code>이 반환됩니다. 이 메서드는 가장 중요한 타입들 중 하나인 <code>HTMLElement</code>를 도입합니다. 이 타입은 다른 모든 요소 인터페이스의 기본 인터페이스 역할을 합니다. 예를 들면, 예제 코드에서 <code>p</code> 변수는 <code>HTMLParagraphElement</code> 타입입니다. 다음으로, 이 메서드는 <code>null</code>을 반환할 수 있다는 점에 유의해야 합니다. 메서드가 실제로 지정된 요소를 찾을 수 있을지 없을지에 따라 확실한 사전 런타임이 될 수 없기 때문입니다. 스니펫 코드의 마지막 줄에는, <code>appendChild</code>를 호출하기 위해 새로운 <em>선택적 체이닝(optional chaining)</em> 연산자가 사용되고 있습니다.</p>\n<h3 id=\"documentcreateelement\" style=\"position:relative;\"><a href=\"#documentcreateelement\" aria-label=\"documentcreateelement permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>Document.createElement</code></h3>\n<p>이 메서드의 정의는 다음과 같습니다(<em>deprecated</em> 표기된 정의는 생략했습니다):</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #001080\">createElement</span><span style=\"color: #000000\">&lt;</span><span style=\"color: #1C6277\">K</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">keyof</span><span style=\"color: #000000\"> </span><span style=\"color: #1C6277\">HTMLElementTagNameMap</span><span style=\"color: #000000\">&gt;(</span><span style=\"color: #001080\">tagName</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">K</span><span style=\"color: #000000\">, </span><span style=\"color: #001080\">options</span><span style=\"color: #000000\">?: </span><span style=\"color: #1C6277\">ElementCreationOptions</span><span style=\"color: #000000\">): </span><span style=\"color: #1C6277\">HTMLElementTagNameMap</span><span style=\"color: #000000\">[</span><span style=\"color: #1C6277\">K</span><span style=\"color: #000000\">];</span></div><div class='line'><span style=\"color: #1C6277\">createElement</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">tagName</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">string</span><span style=\"color: #000000\">, </span><span style=\"color: #001080\">options</span><span style=\"color: #000000\">?: </span><span style=\"color: #1C6277\">ElementCreationOptions</span><span style=\"color: #000000\">): </span><span style=\"color: #1C6277\">HTMLElement</span><span style=\"color: #000000\">;</span></div></code></div></pre>\n<p>이는 오버 로드된 함수 정의입니다. 두 번째 오버로드는 가장 단순하며 <code>getElementById</code> 메서드와 매우 유사하게 작동합니다. 어떤 <code>문자열</code>이 전달되면 HTMLElement 표준이 반환됩니다. 이 정의는 개발자가 고유한 HTML 요소 태그를 생성할 수 있게 합니다.</p>\n<p>예를 들면 <code>document.createElement('xyz')</code>는 HTML 규격에 지정된 요소가 아닌 <code>&#x3C;xyz>&#x3C;/xyz></code> 요소를 반환합니다.</p>\n<blockquote>\n<p>관심 있는 사람들을 위해 언급하자면, <code>document.getElementsByTagName</code>를 사용해 사용자 정의 태그(custom tag) 요소와 상호작용할 수 있습니다.</p>\n</blockquote>\n<p><code>createElement</code>의 첫 번째 정의에는, 고급 제네릭 패턴들을 사용하고 있습니다. 이는 내용을 나누어 이해하는 것이 가장 좋습니다. 먼저 <code>&#x3C;K extends keyof HTMLElementTagNameMap></code>라는 제네릭 표현부터 시작합니다. 이 표현식은 <code>HTMLElementTagNameMap</code> 인터페이스의 키에 제약을 받는 제네릭 매개변수 <code>K</code>를 정의하고 있습니다. 그 맵 인터페이스는 모든 지정된 HTML 태그 이름과 해당 타입 인터페이스를 포함하고 있습니다. 예를 들면 여기 코드 초반에 5개의 매핑된 값이 있습니다:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #0000FF\">interface</span><span style=\"color: #000000\"> </span><span style=\"color: #1C6277\">HTMLElementTagNameMap</span><span style=\"color: #000000\"> {</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #A31515\">\"a\"</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">HTMLAnchorElement</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #A31515\">\"abbr\"</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">HTMLElement</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #A31515\">\"address\"</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">HTMLElement</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #A31515\">\"applet\"</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">HTMLAppletElement</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #A31515\">\"area\"</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">HTMLAreaElement</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #000000\">        ...</span></div><div class='line'><span style=\"color: #000000\">}</span></div></code></div></pre>\n<p>일부 요소들은 고유한 프로퍼티를 나타내지 않아 <code>HTMLElement</code>를 반환하기도 하지만, 그 외 타입 요소들은 고유한 프로퍼티와 메서드를 가지고 특정 인터페이스(<code>HTMLElement</code>에서 확장되거나 구현됨)를 반환합니다.</p>\n<p>이제, <code>createElement</code> 정의의 나머지 부분인 <code>(tagName: K, options?: ElementCreationOptions): HTMLElementTagNameMap[K]</code>를 살펴보겠습니다. 첫 번째 인수 <code>tagName</code>은 제네릭 매개변수 <code>K</code>로 정의됩니다. TypeScript 인터프리터는 이 인수로부터 제네릭 매개변수를 <em>추론</em> 할 수 있는 충분한 성능을 가지고 있습니다. 이는 개발자가 메서드를 사용할 때 실제로 제네릭 매개변수를 지정할 필요가 없음을 의미하며, 어떤 값이 <code>tagName</code>인수로 전달되든 간에 <code>K</code>로 추론되므로 정의의 나머지 부분에 사용할 수 있을 것입니다. 정확히 무슨 일이 일어나는지를 보면 반환값 <code>HTMLElementTagNameMap[K]</code>는 <code>tagName</code>인수를 가지고 해당 타입을 반환합니다. 이 정의는 스니펫 코드 <code>p</code> 변수에서 <code>HTMLParagraphElement</code>타입을 얻는 방법입니다. 그리고 코드가 <code>document.createElement('a')</code>였다면, <code>HTMLAnchorElement</code>타입의 요소가 됩니다.</p>\n<h2 id=\"node-인터페이스-the-node-interface\" style=\"position:relative;\"><a href=\"#node-%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4-the-node-interface\" aria-label=\"node 인터페이스 the node interface permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>Node</code> 인터페이스 (The <code>Node</code> interface)</h2>\n<p><code>document.getElementById</code> 함수는 <code>HTMLElement</code>를 반환합니다. <code>HTMLElement</code> 인터페이스는 <code>Node</code> 인터페이스를 확장한 <code>Element</code> 인터페이스를 확장합니다. 이러한 프로토타입 확장은 모든 <code>HTMLElements</code>가 표준 메서드의 하위 집합을 활용할 수 있도록 합니다. 코드 스니펫에서는 <code>Node</code> 인터페이스에 정의된 속성을 사용하여 웹 사이트에 새 <code>p</code> 요소를 추가합니다.</p>\n<h3 id=\"nodeappendchild\" style=\"position:relative;\"><a href=\"#nodeappendchild\" aria-label=\"nodeappendchild permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>Node.appendChild</code></h3>\n<p>코드 스니펫의 마지막 줄은 <code>app?.appendChild(p)</code>입니다. 이전 섹션(<code>document.getElementById</code>)에서는 <code>app</code>이 런타임에 null일 가능성이 있기 때문에 <em>선택적 체이닝(optional chaining)</em> 연산자가 여기에 사용된다고 설명했습니다. <code>appendChild</code>의 메서드는 다음과 같습니다:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #001080\">appendChild</span><span style=\"color: #000000\">&lt;</span><span style=\"color: #1C6277\">T</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> </span><span style=\"color: #1C6277\">Node</span><span style=\"color: #000000\">&gt;(</span><span style=\"color: #001080\">newChild</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">T</span><span style=\"color: #000000\">): </span><span style=\"color: #1C6277\">T</span><span style=\"color: #000000\">;</span></div></code></div></pre>\n<p>제네릭 매개변수 <code>T</code>가 <code>newChild</code> 인수로부터 나온 것이기 때문에 이 메서드는 <code>createElement</code> 메서드와 유사하게 작동합니다. <code>T</code>는 또 다른 기본 인터페이스인 <code>노드</code>로 <em>제한</em>됩니다.</p>\n<h2 id=\"children과-childnodes의-차이점-difference-between-children-and-childnodes\" style=\"position:relative;\"><a href=\"#children%EA%B3%BC-childnodes%EC%9D%98-%EC%B0%A8%EC%9D%B4%EC%A0%90-difference-between-children-and-childnodes\" aria-label=\"children과 childnodes의 차이점 difference between children and childnodes permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>children</code>과 <code>childNodes</code>의 차이점 (Difference between <code>children</code> and <code>childNodes</code>)</h2>\n<p>이전에 이 문서는 <code>HTMLElement</code> 인터페이스가 <code>Node</code>로부터 확장된 <code>Element</code>에서 확장된 개념이라고 설명했습니다. DOM API에는 <em>자식(children)</em> 요소 개념이 있습니다. 예를 들어 HTML에서 <code>p</code> 태그는 <code>div</code> 요소의 자식입니다.</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">tsx</div><div class='code-container'><code><div class='line'><span style=\"color: #800000\">&lt;div&gt;</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #800000\">&lt;p&gt;</span><span style=\"color: #000000\">Hello, World</span><span style=\"color: #800000\">&lt;/p&gt;</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #800000\">&lt;p&gt;</span><span style=\"color: #000000\">TypeScript!</span><span style=\"color: #800000\">&lt;/p&gt;</span></div><div class='line'><span style=\"color: #800000\">&lt;/div&gt;</span><span style=\"color: #000000\">;</span></div><div class='line'></div><div class='line'><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #0070C1\">div</span><span style=\"color: #000000\"> = </span><span style=\"color: #001080\">document</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">getElementByTagName</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">\"div\"</span><span style=\"color: #000000\">)[</span><span style=\"color: #098658\">0</span><span style=\"color: #000000\">];</span></div><div class='line'></div><div class='line'><span style=\"color: #001080\">div</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">children</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #008000\">// HTMLCollection(2) [p, p]</span></div><div class='line'></div><div class='line'><span style=\"color: #001080\">div</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">childNodes</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #008000\">// NodeList(2) [p, p]</span></div></code></div></pre>\n<p><code>div</code> 요소를 찾아낸 후 <code>children</code> 프로퍼티는 <code>HTMLParagraphElements</code>를 포함하는 <code>HTMLCollection</code> 리스트를 반환합니다. <code>childNodes</code> 프로퍼티는 위와 유사하게 노드 리스트인 <code>NodeList</code>를 반환합니다. 각 <code>p</code> 태그는 여전히 <code>HTMLParagraphElements</code> 타입이지만, <code>NodeList</code>는 추가적으로 <code>HTMLCollection</code> 리스트에는 없는 <em>HTML 노드</em> 를 포함할 수 있습니다.</p>\n<p><code>p</code> 태그 중 하나를 제거하여 html을 수정하되 텍스트는 그대로 유지하십시오.</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">tsx</div><div class='code-container'><code><div class='line'><span style=\"color: #800000\">&lt;div&gt;</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #800000\">&lt;p&gt;</span><span style=\"color: #000000\">Hello, World</span><span style=\"color: #800000\">&lt;/p&gt;</span></div><div class='line'><span style=\"color: #000000\">  TypeScript!</span></div><div class='line'><span style=\"color: #800000\">&lt;/div&gt;</span><span style=\"color: #000000\">;</span></div><div class='line'></div><div class='line'><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #0070C1\">div</span><span style=\"color: #000000\"> = </span><span style=\"color: #001080\">document</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">getElementByTagName</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">\"div\"</span><span style=\"color: #000000\">)[</span><span style=\"color: #098658\">0</span><span style=\"color: #000000\">];</span></div><div class='line'></div><div class='line'><span style=\"color: #001080\">div</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">children</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #008000\">// HTMLCOllection(1) [p]</span></div><div class='line'></div><div class='line'><span style=\"color: #001080\">div</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">childNodes</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #008000\">// NodeList(2) [p, text]</span></div></code></div></pre>\n<p>어떻게 두 개의 리스트가 변했는지 보겠습니다. <code>children</code>은 현재 <code>&#x3C;p>Hello, World&#x3C;/p></code> 요소만을 포함하고 있고, <code>childNodes</code>는 두 개의 <code>p</code> 노드가 아닌 <code>text</code> 노드를 포함하고 있습니다. <code>NodeList</code>에서 <code>text</code> 부분은 <code>TypeScript!</code> 텍스트를 포함하는 문자 그대로의 <code>Node</code>입니다. <code>children</code> 리스트는 이 <code>Node</code>를 포함하지 않습니다. 왜냐하면 <code>HTMLElement</code>로 간주하지 않기 때문입니다.</p>\n<h2 id=\"queryselector와-queryselectorall-메서드-the-queryselector-and-queryselectorall-methods\" style=\"position:relative;\"><a href=\"#queryselector%EC%99%80-queryselectorall-%EB%A9%94%EC%84%9C%EB%93%9C-the-queryselector-and-queryselectorall-methods\" aria-label=\"queryselector와 queryselectorall 메서드 the queryselector and queryselectorall methods permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>querySelector</code>와 <code>querySelectorAll</code> 메서드 (The <code>querySelector</code> and <code>querySelectorAll</code> methods)</h2>\n<p>두 개의 메서드 모두 고유한 제약 조건 집합에 적합한 돔 요소 리스트를 가져오는 데 좋은 도구입니다. 메서드들은 <em>lib.dom.d.ts</em> 에 다음과 같이 정의되어 있습니다:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">/**</span></div><div class='line'><span style=\"color: #008000\"> * 선택자와 일치하는 노드의 자식 중 첫 번째 요소를 반환합니다.</span></div><div class='line'><span style=\"color: #008000\"> */</span></div><div class='line'><span style=\"color: #001080\">querySelector</span><span style=\"color: #000000\">&lt;</span><span style=\"color: #1C6277\">K</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">keyof</span><span style=\"color: #000000\"> </span><span style=\"color: #1C6277\">HTMLElementTagNameMap</span><span style=\"color: #000000\">&gt;(</span><span style=\"color: #001080\">selectors</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">K</span><span style=\"color: #000000\">): </span><span style=\"color: #1C6277\">HTMLElementTagNameMap</span><span style=\"color: #000000\">[</span><span style=\"color: #1C6277\">K</span><span style=\"color: #000000\">] | </span><span style=\"color: #1C6277\">null</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #1C6277\">querySelector</span><span style=\"color: #000000\">&lt;</span><span style=\"color: #1C6277\">K</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">keyof</span><span style=\"color: #000000\"> </span><span style=\"color: #1C6277\">SVGElementTagNameMap</span><span style=\"color: #000000\">&gt;(</span><span style=\"color: #001080\">selectors</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">K</span><span style=\"color: #000000\">): </span><span style=\"color: #1C6277\">SVGElementTagNameMap</span><span style=\"color: #000000\">[</span><span style=\"color: #1C6277\">K</span><span style=\"color: #000000\">] | </span><span style=\"color: #1C6277\">null</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #1C6277\">querySelector</span><span style=\"color: #000000\">&lt;</span><span style=\"color: #1C6277\">E</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> </span><span style=\"color: #1C6277\">Element</span><span style=\"color: #000000\"> = </span><span style=\"color: #1C6277\">Element</span><span style=\"color: #000000\">&gt;(</span><span style=\"color: #001080\">selectors</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">string</span><span style=\"color: #000000\">): </span><span style=\"color: #1C6277\">E</span><span style=\"color: #000000\"> | </span><span style=\"color: #1C6277\">null</span><span style=\"color: #000000\">;</span></div><div class='line'></div><div class='line'><span style=\"color: #008000\">/**</span></div><div class='line'><span style=\"color: #008000\"> * 선택자와 일치하는 모든 노드 자식 요소를 반환합니다.</span></div><div class='line'><span style=\"color: #008000\"> */</span></div><div class='line'><span style=\"color: #1C6277\">querySelectorAll</span><span style=\"color: #000000\">&lt;</span><span style=\"color: #1C6277\">K</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">keyof</span><span style=\"color: #000000\"> </span><span style=\"color: #1C6277\">HTMLElementTagNameMap</span><span style=\"color: #000000\">&gt;(</span><span style=\"color: #001080\">selectors</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">K</span><span style=\"color: #000000\">): </span><span style=\"color: #1C6277\">NodeListOf</span><span style=\"color: #000000\">&lt;</span><span style=\"color: #1C6277\">HTMLElementTagNameMap</span><span style=\"color: #000000\">[</span><span style=\"color: #1C6277\">K</span><span style=\"color: #000000\">]&gt;;</span></div><div class='line'><span style=\"color: #1C6277\">querySelectorAll</span><span style=\"color: #000000\">&lt;</span><span style=\"color: #1C6277\">K</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">keyof</span><span style=\"color: #000000\"> </span><span style=\"color: #1C6277\">SVGElementTagNameMap</span><span style=\"color: #000000\">&gt;(</span><span style=\"color: #001080\">selectors</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">K</span><span style=\"color: #000000\">): </span><span style=\"color: #1C6277\">NodeListOf</span><span style=\"color: #000000\">&lt;</span><span style=\"color: #1C6277\">SVGElementTagNameMap</span><span style=\"color: #000000\">[</span><span style=\"color: #1C6277\">K</span><span style=\"color: #000000\">]&gt;;</span></div><div class='line'><span style=\"color: #1C6277\">querySelectorAll</span><span style=\"color: #000000\">&lt;</span><span style=\"color: #1C6277\">E</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> </span><span style=\"color: #1C6277\">Element</span><span style=\"color: #000000\"> = </span><span style=\"color: #1C6277\">Element</span><span style=\"color: #000000\">&gt;(</span><span style=\"color: #001080\">selectors</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">string</span><span style=\"color: #000000\">): </span><span style=\"color: #1C6277\">NodeListOf</span><span style=\"color: #000000\">&lt;</span><span style=\"color: #1C6277\">E</span><span style=\"color: #000000\">&gt;;</span></div></code></div></pre>\n<p><code>querySelectorAll</code> 정의는 <code>NodeListOf</code>라는 새로운 타입을 반환한다는 점을 제외하면 <code>getElementByTagName</code>과 유사합니다. 이 반환 타입은 기본적으로 표준 JavaScript 리스트 요소의 맞춤형으로 구현되었습니다. <code>NodeListOf&#x3C;E></code>를 <code>E[]</code>로 바꿔보면 틀림없이 매우 유사한 사용자 경험을 제공할 것입니다. <code>NodeListOf</code>는 <code>length</code> , <code>item(index)</code>, <code>forEach((value, key, parent) => void)</code> , 그리고 숫자 인덱스 생성과 같은 프로퍼티 및 메서드만을 구현합니다. 또한, 메서드는 <em>노드</em> 가 아닌 <em>요소</em> 리스트를 반환하며 이는 <code>.childNodes</code> 메서드에서 <code>NodeList</code>가 반환한 것입니다. 모순처럼 보일 수 있지만, <code>Element</code> 인터페이스는 <code>Node</code>에서 확장된 점에 유의해야 합니다.</p>\n<p>두 개의 메서드가 동작하는 것을 보려면 기존 코드를 다음과 같이 수정하십시오:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">tsx</div><div class='code-container'><code><div class='line'><span style=\"color: #800000\">&lt;ul&gt;</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #800000\">&lt;li&gt;</span><span style=\"color: #000000\">First :)</span><span style=\"color: #800000\">&lt;/li&gt;</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #800000\">&lt;li&gt;</span><span style=\"color: #000000\">Second!</span><span style=\"color: #800000\">&lt;/li&gt;</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #800000\">&lt;li&gt;</span><span style=\"color: #000000\">Third times a charm.</span><span style=\"color: #800000\">&lt;/li&gt;</span></div><div class='line'><span style=\"color: #800000\">&lt;/ul&gt;</span><span style=\"color: #000000\">;</span></div><div class='line'></div><div class='line'><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #0070C1\">first</span><span style=\"color: #000000\"> = </span><span style=\"color: #001080\">document</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">querySelector</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">\"li\"</span><span style=\"color: #000000\">); </span><span style=\"color: #008000\">// 첫 번째 li 요소를 반환합니다.</span></div><div class='line'><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #0070C1\">all</span><span style=\"color: #000000\"> = </span><span style=\"color: #001080\">document</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">querySelectorAll</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">\"li\"</span><span style=\"color: #000000\">); </span><span style=\"color: #008000\">// 모든 li 요소를 포함하는 리스트를 반환합니다.</span></div></code></div></pre>\n<h2 id=\"더-자세히-알고-싶으십니까-interested-in-learning-more\" style=\"position:relative;\"><a href=\"#%EB%8D%94-%EC%9E%90%EC%84%B8%ED%9E%88-%EC%95%8C%EA%B3%A0-%EC%8B%B6%EC%9C%BC%EC%8B%AD%EB%8B%88%EA%B9%8C-interested-in-learning-more\" aria-label=\"더 자세히 알고 싶으십니까 interested in learning more permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>더 자세히 알고 싶으십니까? (Interested in learning more?)</h2>\n<p><em>lib.dom.d.ts</em> 타입 정의에서 가장 좋은 부분은 Mozilla Developer Network (MDN) 문서 사이트에 표기된 타입들을 반영했다는 것입니다. 예를 들어, <code>HTMLElement</code> 인터페이스는 MDN에서 <a href=\"https://developer.mozilla.org/docs/Web/API/HTMLElement\">HTMLElement 페이지</a>에 문서화 되어 있습니다. 이 페이지에는 사용 가능한 모든 프로퍼티, 메서드, 때로는 예시까지 제공합니다. 해당 페이지가 훌륭한 다른 면은 표준 문서에 맞는 링크를 제공한다는 것입니다. 다음은 <a href=\"https://www.w3.org/TR/html52/dom.html#htmlelement\">HTMLElement의 W3C 권장사항</a>에 대한 링크입니다.</p>\n<p>소스코드 참조:</p>\n<ul>\n<li><a href=\"http://www.ecma-international.org/ecma-262/10.0/index.html\">ECMA-262 Standard</a></li>\n<li><a href=\"https://developer.mozilla.org/docs/Web/API/Document_Object_Model/Introduction\">Introduction to the DOM</a></li>\n</ul>","headings":[{"value":"DOM 조작 (DOM Manipulation)","depth":1},{"value":"HTMLElement 타입 탐구 (An exploration into the HTMLElement type)","depth":3},{"value":"기본 예제 (Basic Example)","depth":2},{"value":"Document 인터페이스 (The Document Interface)","depth":2},{"value":"Document.getElementById","depth":3},{"value":"Document.createElement","depth":3},{"value":"Node 인터페이스 (The Node interface)","depth":2},{"value":"Node.appendChild","depth":3},{"value":"children과 childNodes의 차이점 (Difference between children and childNodes)","depth":2},{"value":"querySelector와 querySelectorAll 메서드 (The querySelector and querySelectorAll methods)","depth":2},{"value":"더 자세히 알고 싶으십니까? (Interested in learning more?)","depth":2}],"frontmatter":{"permalink":"/ko/docs/handbook/dom-manipulation.html","title":"DOM Manipulation","disable_toc":null,"handbook":null,"oneline":"Using the DOM with TypeScript","preamble":null,"deprecated_by":null,"deprecation_redirects":null,"experimental":null}},"prev":null,"next":null},"pageContext":{"id":"4-dom-manipulation","slug":"/ko/docs/handbook/dom-manipulation.html","repoPath":"/packages/documentation/copy/ko/tutorials/DOM Manipulation.md","lang":"ko","modifiedTime":"2024-10-21T12:35:09.565Z"}},"staticQueryHashes":[]}