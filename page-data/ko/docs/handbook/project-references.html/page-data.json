{"componentChunkName":"component---src-templates-documentation-tsx","path":"/ko/docs/handbook/project-references.html","result":{"data":{"markdownRemark":{"id":"0301a9bd-44df-5c75-885c-a29949e54e5f","excerpt":"프로젝트 레퍼런스는 TypeScript 프로그램을 더 작은 조각으로 구성할 수 있는 TypeScript 3.…","html":"<p>프로젝트 레퍼런스는 TypeScript 프로그램을 더 작은 조각으로 구성할 수 있는 TypeScript 3.0의 새로운 기능입니다.</p>\n<p>이를 통해, 빌드 시간을 크게 개선하고, 컴포넌트 사이의 논리적인 분리를 강제하여 코드를 새롭고 더 나은 방법으로 구성할 수 있습니다.</p>\n<p>또한, 빠른 TypeScript 빌드를 위해 프로젝트 레퍼런스와 함께 동작하는 <code>tsc</code> 의 새로운 모드인 <code>--build</code> 플래그를 도입했습니다.</p>\n<h1 id=\"예제-프로젝트-an-example-project\" style=\"position:relative;\"><a href=\"#%EC%98%88%EC%A0%9C-%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-an-example-project\" aria-label=\"예제 프로젝트 an example project permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>예제 프로젝트 (An Example Project)</h1>\n<p>꽤 일반적인 프로그램을 보고 프로젝트 레퍼런스가 이 프로그램을 더 잘 구성하는데 어떻게 도움이 될 수 있는지 살펴보겠습니다.\n<code>converter</code>와 <code>units</code>이라는 두 모듈이 프로젝트 안에 있고, 각 모듈에 대응되는 테스트 파일이 있다고 상상해봅시다:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">shell</div><div class='code-container'><code><div class='line'><span style=\"color: #000000\">/src/converter.ts</span></div><div class='line'><span style=\"color: #000000\">/src/units.ts</span></div><div class='line'><span style=\"color: #000000\">/test/converter-tests.ts</span></div><div class='line'><span style=\"color: #000000\">/test/units-tests.ts</span></div><div class='line'><span style=\"color: #000000\">/tsconfig.json</span></div></code></div></pre>\n<p>테스트 파일은 구현 파일을 import 하고 테스트를 진행합니다:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// converter-tests.ts</span></div><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">*</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">as</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">converter</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"../converter\"</span><span style=\"color: #000000\">;</span></div><div class='line'></div><div class='line'><span style=\"color: #001080\">assert</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">areEqual</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">converter</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">celsiusToFahrenheit</span><span style=\"color: #000000\">(</span><span style=\"color: #098658\">0</span><span style=\"color: #000000\">), </span><span style=\"color: #098658\">32</span><span style=\"color: #000000\">);</span></div></code></div></pre>\n<p>이전에는, 단일 tsconfig 파일을 사용한 경우 이 구조가 어색하게 동작했습니다:</p>\n<ul>\n<li>구현 파일에서 테스트 파일을 import 하는 것이 가능합니다</li>\n<li>아마도 원치 않았겠지만 <code>src</code>가 출력 폴더 이름에 나타나지 않고는 <code>test</code>와 <code>src</code>를 동시에 빌드 하는 것이 불가능합니다</li>\n<li>구현 파일 안에 <em>내용물</em> 만 바꿔도 새로운 오류를 절대 발생시키지 않지만 테스트 파일에 대한 <em>타입 검사</em>를 다시 해야 합니다</li>\n<li>테스트 파일만 바꿔도 아무 변화 없지만 구현 파일의 타입 검사를 다시 해야 합니다</li>\n</ul>\n<p>여러 개의 tsconfig 파일을 사용하여 이 문제들 중 <em>몇 가지</em>는 해결할 수 있지만, 새로운 문제가 발생합니다:</p>\n<ul>\n<li>내장된 최신 검사가 없기 때문에, 항상 <code>tsc</code>를 두 번 실행해야 합니다</li>\n<li><code>tsc</code>를 두 번 호출하면 시작 시간 오버헤드가 더 많이 발생합니다</li>\n<li><code>tsc-w</code>는 한 번에 여러 config 파일을 실행할 수 없습니다</li>\n</ul>\n<p>프로젝트 레퍼런스는 이 모든 문제를 해결할 수 있습니다.</p>\n<h1 id=\"프로젝트-레퍼런스는-무엇인가-what-is-a-project-reference\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-what-is-a-project-reference\" aria-label=\"프로젝트 레퍼런스는 무엇인가 what is a project reference permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로젝트 레퍼런스는 무엇인가? (What is a Project Reference?)</h1>\n<p><code>tsconfig.json</code> 파일은 새로운 최상위-레벨 프로퍼티 <code>reference</code>를 가집니다. 이는 참조할 프로젝트를 지정하는 객체의 배열입니다:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">js</div><div class='code-container'><code><div class='line'><span style=\"color: #000000\">{</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #A31515\">\"compilerOptions\"</span><span style=\"color: #000000\">: {</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #008000\">// The usual</span></div><div class='line'><span style=\"color: #000000\">    },</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #A31515\">\"references\"</span><span style=\"color: #000000\">: [</span></div><div class='line'><span style=\"color: #000000\">        { </span><span style=\"color: #A31515\">\"path\"</span><span style=\"color: #001080\">:</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"../src\"</span><span style=\"color: #000000\"> }</span></div><div class='line'><span style=\"color: #000000\">    ]</span></div><div class='line'><span style=\"color: #000000\">}</span></div></code></div></pre>\n<p>각 참조의 <code>path</code> 프로퍼티는 <code>tsconfig.json</code> 파일을 가지는 디렉터리를 가리키거나, config 파일 자체(어떤 이름도 가질 수 있음)를 가리킵니다.</p>\n<p>프로젝트를 참조하면, 새로운 일이 일어납니다:</p>\n<ul>\n<li>참조된 프로젝트에서 모듈을 import 하면 모듈의 <em>출력</em> 선언 파일을 대신 로드합니다 (<code>.d.ts</code>)</li>\n<li>만약 참조된 프로젝트가 <code>outFile</code>를 생성하면, 출력 파일 <code>.d.ts</code> 파일의 선언은 이 프로젝트 안에서 노출됩니다</li>\n<li>빌드 모드(아래 참조)는 필요하다면 자동으로 참조된 프로젝트를 빌드 합니다</li>\n</ul>\n<p>여러 프로젝트로 분리하는 것은, 타입 검사와 컴파일 속도를 크게 향상시키고, 에디터를 사용할 때 메모리 사용량을 줄이며, 프로그램의 논리적 그룹화를 향상시킵니다.</p>\n<h1 id=\"composite\" style=\"position:relative;\"><a href=\"#composite\" aria-label=\"composite permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>composite</code></h1>\n<p>참조 된 프로젝트는 반드시 새로운 <code>composite</code> 설정이 활성화되어야 합니다.\n이 설정은 TypeScript가 참조된 프로젝트의 출력을 어디서 찾아야 할지 빠르게 결정하도록 하기 위해 필요합니다.\n<code>composite</code> 플래그를 활성화하면 몇 가지가 변합니다:</p>\n<ul>\n<li>만약 <code>rootDir</code> 설정이 명시적으로 지정되지 않으면, 기본 값은 <code>tsconfig</code> 파일을 가진 디렉터리입니다</li>\n<li>모든 구현 파일은 반드시 <code>include</code> 패턴에 맞거나 <code>files</code> 배열 안에 있어야 합니다. 만약 이 제약조건을 위반하면, <code>tsc</code>는 어떤 파일이 지정되지 않았는지 알려줍니다</li>\n<li><code>declaration</code>은 반드시 켜져 있어야 합니다</li>\n</ul>\n<h1 id=\"declarationmaps\" style=\"position:relative;\"><a href=\"#declarationmaps\" aria-label=\"declarationmaps permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>declarationMap</code>s</h1>\n<p><a href=\"https://github.com/Microsoft/TypeScript/issues/14479\">선언 소스 맵</a>에 대한 지원도 추가했습니다.\n만약 <code>--declarationMap</code>을 활성화하면, “정의로 이동”과 이름 변경과 같은 에디터 기능을 사용하여 지원하는 에디터에서 투명하게 탐색하고 프로젝트 경계를 넘어 코드를 수정할 수 있습니다.</p>\n<h1 id=\"prepend와-outfile-prepend-with-outfile\" style=\"position:relative;\"><a href=\"#prepend%EC%99%80-outfile-prepend-with-outfile\" aria-label=\"prepend와 outfile prepend with outfile permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>prepend</code>와 <code>outFile</code> (<code>prepend</code> with <code>outFile</code>)</h1>\n<p>레퍼런스에서 <code>prepend</code> 옵션을 사용하여 의존성의 출력을 덧붙이는 것을 활성화할 수 있습니다:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">js</div><div class='code-container'><code><div class='line'><span style=\"color: #000000\">   </span><span style=\"color: #A31515\">\"references\"</span><span style=\"color: #000000\">: [</span></div><div class='line'><span style=\"color: #000000\">       { </span><span style=\"color: #A31515\">\"path\"</span><span style=\"color: #001080\">:</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"../utils\"</span><span style=\"color: #000000\">, </span><span style=\"color: #A31515\">\"prepend\"</span><span style=\"color: #001080\">:</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">true</span><span style=\"color: #000000\"> }</span></div><div class='line'><span style=\"color: #000000\">   ]</span></div></code></div></pre>\n<p>프로젝트를 덧붙이는 것은 프로젝트의 출력을 현재 프로젝트의 출력 위에 포함시킵니다.\n이는 <code>.js</code> 파일과 <code>.d.ts</code> 파일에 모두 동작하고, 소스맵 파일 역시 올바르게 방출됩니다.</p>\n<p><code>tsc</code>는 이 작업을 위해 디스크에 있는 기존 파일만 사용합니다, 그래서 어떤 프로젝트의 출력이 결과 파일에 한 번 이상 나타날 수 있기 때문에, 올바른 출력 파일이 생성될 수 없는 프로젝트를 생성하는 것이 가능합니다.\n예를 들어:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">txt</div><div class='code-container'><code><div class='line'><span style=\"color: undefined\">   A\n  ^ ^\n /   \\\nB     C\n ^   ^\n  \\ /\n   D</span></div></code></div></pre>\n<p>이 상황에서 각 레퍼런스에 덧붙이지 않는 것이 중요한데, 왜냐하면 <code>D</code>의 출력에 <code>A</code>의 두 가지 복사본이 나오기 때문입니다 - 이는 예상치 못한 결과를 초래할 수 있습니다.</p>\n<h1 id=\"프로젝트-레퍼런스에-대한-주의사항-caveats-for-project-references\" style=\"position:relative;\"><a href=\"#%ED%94%84%EB%A1%9C%EC%A0%9D%ED%8A%B8-%EB%A0%88%ED%8D%BC%EB%9F%B0%EC%8A%A4%EC%97%90-%EB%8C%80%ED%95%9C-%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD-caveats-for-project-references\" aria-label=\"프로젝트 레퍼런스에 대한 주의사항 caveats for project references permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>프로젝트 레퍼런스에 대한 주의사항 (Caveats for Project References)</h1>\n<p>프로젝트 레퍼런스는 반드시 주의해야 할 몇 가지 트레이드오프가 있습니다.</p>\n<p>왜냐하면 의존성 있는 프로젝트는 의존성으로부터 빌드 된 <code>.d.ts</code> 파일을 사용하기 때문에, 에디터에서 잘못된 오류를 보지 않고 프로젝트를 탐색할 수 있기 전에 특정 빌드 출력을 검사하거나 <em>혹은</em> 클론 후 프로젝트를 빌드 해야 합니다.\n이를 개선할 수 있는 .d.ts 생성 과정을 작업하고 있습니다만, 지금은 클론 이후에 빌드 하는 것을 개발자분들에게 추천드립니다.</p>\n<p>추가적으로, 기존 빌드 작업 흐름과의 호환성을 유지하기 위해, <code>tsc</code>는 <code>--build</code> 스위치를 호출하지 않는 한 자동으로 의존성 빌드를 하지 <em>않습니다</em>.\n<code>--build</code>에 대해 배워봅시다.</p>\n<h1 id=\"typescript를-위한-빌드-모드-build-mode-for-typescript\" style=\"position:relative;\"><a href=\"#typescript%EB%A5%BC-%EC%9C%84%ED%95%9C-%EB%B9%8C%EB%93%9C-%EB%AA%A8%EB%93%9C-build-mode-for-typescript\" aria-label=\"typescript를 위한 빌드 모드 build mode for typescript permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TypeScript를 위한 빌드 모드 (Build Mode for TypeScript)</h1>\n<p>오래 기다린 기능은 TypeScript 프로젝트를 위한 똑똑한 증분 빌드입니다.\n3.0에서 <code>tsc</code>에서 <code>--build</code> 플래그를 사용할 수 있게 되었습니다.\n이것은 단순한 컴파일러보다 빌드 관리자처럼 동작하는 <code>tsc</code>의 새로운 진입점입니다.</p>\n<p><code>tsc --build</code> (약식은 <code>tsc -b</code>)를 실행하면 다음의 작업을 합니다:</p>\n<ul>\n<li>참조된 모든 프로젝트를 찾습니다</li>\n<li>최신 상태인지 감지합니다</li>\n<li>올바른 순서로 최신 상태가 아닌 프로젝트를 빌드 합니다</li>\n</ul>\n<p><code>tsc -b</code>에 여러 config 파일 경로를 제공할 수 있습니다 (예를 들어. <code>tsc -b src test</code>).\n<code>tsc -p</code>처럼, 만약 config 파일 이름이 <code>tsconfig.json</code>이라면 이름을 지정하지 않아도 됩니다.</p>\n<h2 id=\"tsc--b-명령줄-tsc--b-commandline\" style=\"position:relative;\"><a href=\"#tsc--b-%EB%AA%85%EB%A0%B9%EC%A4%84-tsc--b-commandline\" aria-label=\"tsc  b 명령줄 tsc  b commandline permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>tsc -b</code> 명령줄 (<code>tsc -b</code> Commandline)</h2>\n<p>config 파일을 원하는 만큼 지정할 수 있습니다:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">shell</div><div class='code-container'><code><div class='line'><span style=\"color: #000000\"> &gt; tsc -b                            </span><span style=\"color: #008000\"># 현재 디렉터리에 있는 tsconfig.json 사용</span></div><div class='line'><span style=\"color: #000000\"> &gt; tsc -b src                        </span><span style=\"color: #008000\"># src/tsconfig.json 사용</span></div><div class='line'><span style=\"color: #000000\"> &gt; tsc -b foo/prd.tsconfig.json bar  </span><span style=\"color: #008000\"># foo/prd.tsconfig.json 와 bar/tsconfig.json 사용</span></div></code></div></pre>\n<p>명령줄에 전달한 파일의 순서에 대해서는 걱정하지 마세요 - 필요하면 <code>tsc</code>가 재배열하기 때문에 의존성이 언제나 먼저 빌드 됩니다.</p>\n<p><code>tsc -b</code>에 지정할 수 있는 몇 가지 플래그들이 더 있습니다:</p>\n<ul>\n<li><code>--verbose</code>: 어떻게 진행되고 있는지 자세한 로그를 출력해 줍니다 (다른 플래그와 결합할 수 있습니다)</li>\n<li><code>--dry</code>: 실제로 빌드 하지 않지만 어떻게 될지 보여줍니다</li>\n<li><code>--clean</code>: 지정된 프로젝트의 출력을 제거합니다 (<code>--dry</code>와 결합할 수 있습니다)</li>\n<li><code>--force</code>: 모든 프로젝트가 최신이 아닌 것처럼 동작합니다</li>\n<li><code>--watch</code>: 감시 모드 (<code>--verbose</code>를 제외한 다른 플래그와는 결합할 수 없습니다)</li>\n</ul>\n<h1 id=\"주의사항-caveats\" style=\"position:relative;\"><a href=\"#%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD-caveats\" aria-label=\"주의사항 caveats permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>주의사항 (Caveats)</h1>\n<p>일반적으로, <code>tsc</code>는 <code>noEmitOnError</code>가 활성화되어있지 않으면, 구문 또는 타입 오류가 있을 때 출력 (<code>.js</code>와 <code>.d.ts</code>)을 생성합니다.\n이것을 증분 빌드 시스템에서 하는 것은 매우 안 좋습니다 - 만약 최신 상태가 아닌 의존성 중 하나가 새로운 오류가 있으면, 다음 빌드가 현재 최신 상태인 프로젝트를 빌드 하는 것을 건너뛸 것이기 때문에, <em>한번</em> 만 볼 수 있습니다.\n이 이유로, <code>tsc -b</code>는 <code>noEmitOnError</code>가 모든 프로젝트에서 활성화된 것처럼 효과적으로 동작합니다.</p>\n<p>아무 빌드 출력 (<code>.js</code>, <code>.d.ts</code>, <code>.d.ts.map</code>, 등)을 검사하는 경우, 소스 제어 도구가 로컬 사본과 원격 사본 사이의 타임스탬프를 보존하는지에 따라 특정 소스 제어 연산 후에 <code>--force</code> 빌드를 실행해야 할 수도 있습니다.</p>\n<h1 id=\"msbuild\" style=\"position:relative;\"><a href=\"#msbuild\" aria-label=\"msbuild permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>MSBuild</h1>\n<p>만약 msbuild 프로젝트가 있으면, 다음을 추가하여 빌드 모드를 proj 파일에</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">xml</div><div class='code-container'><code><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #800000\">&lt;TypeScriptBuildMode&gt;</span><span style=\"color: #000000\">true</span><span style=\"color: #800000\">&lt;/TypeScriptBuildMode&gt;</span></div></code></div></pre>\n<p>활성화할 수 있습니다. 이는 제거뿐만 아니라 자동 증분 빌드를 활성화합니다.</p>\n<p><code>tsconfig.json</code> / <code>-p</code>와 마찬가지로, 기존 TypeScript 프로젝트 프로퍼티는 고려되지 않음에 유의하십시오 - 모든 설정은 tsconfig 파일을 사용하여 관리해야 합니다.</p>\n<p>일부 팀들은 tsconfig 파일들이 함께 병행하여 관리되는 프로젝트와 같은 <em>암시적</em> 그래프 순서를 가지며 msbuild 기반의 작업 흐름을 설정했습니다.\n만약 해결책이 이와 같다면, 프로젝트 레퍼런스와 함께 <code>msbuild</code>를 <code>tsc -p</code>와 계속 사용할 수 있습니다; 이들은 완전히 상호 운용 가능합니다.</p>\n<h1 id=\"안내-guidance\" style=\"position:relative;\"><a href=\"#%EC%95%88%EB%82%B4-guidance\" aria-label=\"안내 guidance permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>안내 (Guidance)</h1>\n<h2 id=\"전체-구조-overall-structure\" style=\"position:relative;\"><a href=\"#%EC%A0%84%EC%B2%B4-%EA%B5%AC%EC%A1%B0-overall-structure\" aria-label=\"전체 구조 overall structure permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>전체 구조 (Overall Structure)</h2>\n<p>더 많은 <code>tsconfig.json</code> 파일과 함께, 공통의 컴파일러 옵션들을 중앙 통제하기 위해 <a href=\"https://www.typescriptlang.org/docs/handbook/tsconfig-json.html\">구성 파일 상속</a>을 사용하고 싶으실 겁니다.\n이 방법으로 여러 파일을 수정하지 않고 한 파일에서 설정을 변경할 수 있습니다.</p>\n<p>또 다른 좋은 방법은 단순히 모든 리프-노드 프로젝트에 <code>references</code>를 가지고 <code>files</code>를 빈 배열로 설정하는 “솔루션” <code>tsconfig.json</code> 파일을 갖는 것입니다 (그렇지 않으면 솔루션 파일 때문에 파일이 두 번 컴파일됩니다). 3.0부터 적어도 하나의 <code>reference</code>가 <code>tsconfig.json</code>에 있으면, 빈 <code>files</code> 배열을 갖는 것은 더 이상 오류가 아님에 유의하세요.</p>\n<p>이는 간단한 진입점을 제공합니다; 예를 들어, TypeScript 저장소에서 <code>src/tsconfig.json</code> 안에 모든 하위 프로젝트를 나열하기 때문에 단순히 <code>tsc -b src</code> 실행하여 모든 엔드포인트를 빌드 합니다.</p>\n<p>이 패턴들은 TypeScript 저장소에서 볼 수 있습니다 - 주 예제로 <code>src/tsconfig_base.json</code>, <code>src/tsconfig.json</code>, 그리고 <code>src/tsc/tsconfig.json</code>를 보세요.</p>\n<h2 id=\"상대-모듈-구조화하기-structuring-for-relative-modules\" style=\"position:relative;\"><a href=\"#%EC%83%81%EB%8C%80-%EB%AA%A8%EB%93%88-%EA%B5%AC%EC%A1%B0%ED%99%94%ED%95%98%EA%B8%B0-structuring-for-relative-modules\" aria-label=\"상대 모듈 구조화하기 structuring for relative modules permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>상대 모듈 구조화하기 (Structuring for relative modules)</h2>\n<p>일반적으로, 상대 모듈을 사용하여 저장소를 전환하는 데에는 별 다른 것이 필요 없습니다.\n간단하게 부모 폴더의 <code>tsconfig.json</code> 파일을 각 하위 디렉터리 안에 위치시키고, 프로그램의 의도된 계층과 일치하도록 <code>reference</code>를 이 config 파일에 추가하십시오.\n<code>outDir</code>을 출력 폴더의 명시적인 하위 폴더로 설정하거나, <code>rootDir</code>을 모든 프로젝트 폴더의 공통 루트로 설정해야 합니다.</p>\n<h2 id=\"outfiles-구조화하기-structuring-for-outfiles\" style=\"position:relative;\"><a href=\"#outfiles-%EA%B5%AC%EC%A1%B0%ED%99%94%ED%95%98%EA%B8%B0-structuring-for-outfiles\" aria-label=\"outfiles 구조화하기 structuring for outfiles permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>outFiles 구조화하기 (Structuring for outFiles)</h2>\n<p><code>outFile</code>을 사용한 컴파일의 레이아웃은 상대 경로가 크게 중요하지 않기 때문에 더 유연합니다.\n기억해야 할 한 가지는 “마지막” 프로젝트 전까지는 <code>prepend</code>를 사용하고 싶지 않다는 것입니다 - 이는 빌드 시간을 개선하고 주어진 빌드에 필요한 I/O 숫자를 줄여줄 것입니다.\nTypeScript 저장소 자체는 여기서 좋은 레퍼런스입니다 - 몇 가지 “라이브러리” 프로젝트와 “엔드포인트” 프로젝트가 있습니다; “엔드포인트” 프로젝트는 가능한 작게 유지되고 있고 필요한 라이브러리만 pull 합니다.</p>\n<!--\n## Structuring for monorepos\n\nTODO: Experiment more and figure this out. Rush and Lerna seem to have different models that imply different things on our end\n-->","headings":[{"value":"예제 프로젝트 (An Example Project)","depth":1},{"value":"프로젝트 레퍼런스는 무엇인가? (What is a Project Reference?)","depth":1},{"value":"composite","depth":1},{"value":"declarationMaps","depth":1},{"value":"prepend와 outFile (prepend with outFile)","depth":1},{"value":"프로젝트 레퍼런스에 대한 주의사항 (Caveats for Project References)","depth":1},{"value":"TypeScript를 위한 빌드 모드 (Build Mode for TypeScript)","depth":1},{"value":"tsc -b 명령줄 (tsc -b Commandline)","depth":2},{"value":"주의사항 (Caveats)","depth":1},{"value":"MSBuild","depth":1},{"value":"안내 (Guidance)","depth":1},{"value":"전체 구조 (Overall Structure)","depth":2},{"value":"상대 모듈 구조화하기 (Structuring for relative modules)","depth":2},{"value":"outFiles 구조화하기 (Structuring for outFiles)","depth":2}],"frontmatter":{"permalink":"/ko/docs/handbook/project-references.html","title":"Project References","disable_toc":null,"handbook":null,"oneline":"How to split up a large TypeScript project","preamble":null,"deprecated_by":null,"deprecation_redirects":null,"experimental":null}},"prev":null,"next":null},"pageContext":{"id":"8-project-references","slug":"/ko/docs/handbook/project-references.html","repoPath":"/packages/documentation/copy/ko/project-config/Project References.md","lang":"ko","modifiedTime":"2024-10-21T12:35:09.561Z"}},"staticQueryHashes":[]}