{"componentChunkName":"component---src-templates-documentation-tsx","path":"/ko/docs/handbook/release-notes/typescript-3-8.html","result":{"data":{"markdownRemark":{"id":"8d575db5-4c58-5a52-88be-da1ffccb3d52","excerpt":"타입-전용 Imports 와 Exports (Type-Only Imports and Exports) 이 기능은 대부분의 사용자에겐 생각할 필요가 없을 수도 있지만; --isolatedModules, TypeScript의 transpileModule API, 또는 Babel…","html":"<h2 id=\"타입-전용-imports-와-exports-type-only-imports-and-exports\" style=\"position:relative;\"><a href=\"#%ED%83%80%EC%9E%85-%EC%A0%84%EC%9A%A9-imports-%EC%99%80-exports-type-only-imports-and-exports\" aria-label=\"타입 전용 imports 와 exports type only imports and exports permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>타입-전용 Imports 와 Exports (Type-Only Imports and Exports)</h2>\n<p>이 기능은 대부분의 사용자에겐 생각할 필요가 없을 수도 있지만; <code>--isolatedModules</code>, TypeScript의 <code>transpileModule</code> API, 또는 Babel에서 문제가 발생하면 이 기능과 관련이 있을 수 있습니다.</p>\n<p>TypeScript 3.8은 타입-전용 imports, exports를 위한 새로운 구문이 추가되었습니다.</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">type</span><span style=\"color: #000000\"> { </span><span style=\"color: #001080\">SomeThing</span><span style=\"color: #000000\"> } </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./some-module.js\"</span><span style=\"color: #000000\">;</span></div><div class='line'></div><div class='line'><span style=\"color: #AF00DB\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">type</span><span style=\"color: #000000\"> { </span><span style=\"color: #001080\">SomeThing</span><span style=\"color: #000000\"> };</span></div></code></div></pre>\n<p><code>import type</code>은 타입 표기와 선언에 사용될 선언만 import 합니다.\n이는 <em>항상</em> 완전히 제거되므로, 런타임에 남아있는 것은 없습니다.\n마찬가지로, <code>export type</code>은 타입 문맥에 사용할 export만 제공하며, 이 또한 TypeScript의 출력물에서 제거됩니다.</p>\n<p>클래스는 런타임에 값을 가지고 있고 디자인-타임에 타입이 있으며 사용은 상황에-따라 다르다는 것을 유의해야 합니다.\n클래스를 import 하기 위해 <code>import type</code>을 사용하면, 확장 같은 것은 할 수 없습니다.</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">type</span><span style=\"color: #000000\"> { </span><span style=\"color: #001080\">Component</span><span style=\"color: #000000\"> } </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"react\"</span><span style=\"color: #000000\">;</span></div><div class='line'></div><div class='line'><span style=\"color: #0000FF\">interface</span><span style=\"color: #000000\"> </span><span style=\"color: #1C6277\">ButtonProps</span><span style=\"color: #000000\"> {</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #008000\">// ...</span></div><div class='line'><span style=\"color: #000000\">}</span></div><div class='line'></div><div class='line'><span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> </span><span style=\"color: #1C6277\">Button</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> </span><span style=\"color: #1C6277\">Component</span><span style=\"color: #000000\">&lt;</span><span style=\"color: #1C6277\">ButtonProps</span><span style=\"color: #000000\">&gt; {</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #008000\">//               ~~~~~~~~~</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #008000\">// error! 'Component' only refers to a type, but is being used as a value here.</span></div><div class='line'></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #008000\">// ...</span></div><div class='line'><span style=\"color: #000000\">}</span></div></code></div></pre>\n<p>이전에 Flow를 사용해본 적이 있다면, 이 구문은 상당히 유사합니다.\n한 가지 차이점은 코드가 모호해 보이지 않도록 몇 가지 제한을 두었다는 것입니다.</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// 'Foo'만 타입인가? 혹은 모든 import 선언이 타입인가?</span></div><div class='line'><span style=\"color: #008000\">// 이는 명확하지 않기 때문에 오류로 처리합니다.</span></div><div class='line'></div><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">type</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">Foo</span><span style=\"color: #000000\">, { </span><span style=\"color: #001080\">Bar</span><span style=\"color: #000000\">, </span><span style=\"color: #001080\">Baz</span><span style=\"color: #000000\"> } </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"some-module\"</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #008000\">//     ~~~~~~~~~~~~~~~~~~~~~~</span></div><div class='line'><span style=\"color: #008000\">// error! A type-only import can specify a default import or named bindings, but not both.</span></div></code></div></pre>\n<p><code>import type</code>과 함께, TypeScript 3.8은 런타임 시 사용되지 않는 import에서 발생하는 작업을 제어하기 위해 새로운 컴파일러 플래그를 추가합니다: <code>importsNotUsedAsValues</code>.\n이 플래그는 3 가지 다른 값을 가집니다:</p>\n<ul>\n<li><code>remove</code>: 이는 imports를 제거하는 현재 동작이며, 계속 기본값으로 작동할 것이며, 기존 동작을 바꾸는 변화가 아닙니다.</li>\n<li><code>preserve</code>: 이는 사용되지 않는 값들을 모두 <em>보존</em>합니다. 이로 인해 imports/side-effects가 보존될 수 있습니다.</li>\n<li><code>error</code>: 이는 모든 (<code>preserve</code> option 처럼) 모든 imports를 보존하지만, import 값이 타입으로만 사용될 경우 오류를 발생시킵니다. 이는 실수로 값을 import하지 않지만 사이드 이팩트 import를 명시적으로 만들고 싶을 때 유용합니다.</li>\n</ul>\n<p>이 기능에 대한 더 자세한 정보는, <code>import type</code>선언이 사용될수 있는 범위를 확대하는 <a href=\"https://github.com/microsoft/TypeScript/pull/35200\">pull request</a>, 와 <a href=\"https://github.com/microsoft/TypeScript/pull/36092/\">관련된 변경 사항</a>에서 찾을 수 있습니다.</p>\n<h2 id=\"ecmascript-비공개-필드-ecmascript-private-fields\" style=\"position:relative;\"><a href=\"#ecmascript-%EB%B9%84%EA%B3%B5%EA%B0%9C-%ED%95%84%EB%93%9C-ecmascript-private-fields\" aria-label=\"ecmascript 비공개 필드 ecmascript private fields permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>ECMAScript 비공개 필드 (ECMAScript Private Fields)</h2>\n<p>TypeScript 3.8 은 ECMAScript의 <a href=\"https://github.com/tc39/proposal-class-fields/\">stage-3 클래스 필드 제안</a>의 비공개 필드를 지원합니다.</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> </span><span style=\"color: #1C6277\">Person</span><span style=\"color: #000000\"> {</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #001080\">#name</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">string</span></div><div class='line'></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">constructor</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">name</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">string</span><span style=\"color: #000000\">) {</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">#name</span><span style=\"color: #000000\"> = </span><span style=\"color: #001080\">name</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #000000\">    }</span></div><div class='line'></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #795E26\">greet</span><span style=\"color: #000000\">() {</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">`Hello, my name is </span><span style=\"color: #0000FF\">${</span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000FF\">.</span><span style=\"color: #001080\">#name</span><span style=\"color: #0000FF\">}</span><span style=\"color: #A31515\">!`</span><span style=\"color: #000000\">);</span></div><div class='line'><span style=\"color: #000000\">    }</span></div><div class='line'><span style=\"color: #000000\">}</span></div><div class='line'></div><div class='line'><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">jeremy</span><span style=\"color: #000000\"> = </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">Person</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">\"Jeremy Bearimy\"</span><span style=\"color: #000000\">);</span></div><div class='line'></div><div class='line'><span style=\"color: #001080\">jeremy</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">#name</span></div><div class='line'><span style=\"color: #008000\">//     ~~~~~</span></div><div class='line'><span style=\"color: #008000\">// 프로퍼티 '#name'은 'Person' 클래스 외부에서 접근할 수 없습니다.</span></div><div class='line'><span style=\"color: #008000\">// 이는 비공개 식별자를 가지기 때문입니다.</span></div></code></div></pre>\n<p>일반적인 프로퍼티들(<code>private</code> 지정자로 선언한 것도)과 달리, 비공개 필드는 몇 가지 명심해야 할 규칙이 있습니다.\n그중 몇몇은:</p>\n<ul>\n<li>비공개 필드는 <code>#</code> 문자로 시작합니다. 때때로 이를 <em>비공개 이름(private names)</em> 이라고 부릅니다.</li>\n<li>모든 비공개 필드 이름은 이를 포함한 클래스 범위에서 유일합니다.</li>\n<li><code>public</code> 또는 <code>private</code> 같은 TypeScript 접근 지정자는 비공개 필드로 사용될 수 없습니다.</li>\n<li>JS 사용자로부터도 비공개 필드는 이를 포함한 클래스 밖에서 접근하거나 탐지할 수 없습니다! 때때로 이를 <em>강한 비공개(hard privacy)</em> 라고 부릅니다.</li>\n</ul>\n<p>“강한” 비공개와 별도로, 비공개 필드의 또 다른 장점은 유일하다는 것입니다.\n예를 들어, 일반적인 프로퍼티 선언은 하위클래스에서 덮어쓰기 쉽습니다.</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> </span><span style=\"color: #1C6277\">C</span><span style=\"color: #000000\"> {</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #001080\">foo</span><span style=\"color: #000000\"> = </span><span style=\"color: #098658\">10</span><span style=\"color: #000000\">;</span></div><div class='line'></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #795E26\">cHelper</span><span style=\"color: #000000\">() {</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #AF00DB\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">foo</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #000000\">    }</span></div><div class='line'><span style=\"color: #000000\">}</span></div><div class='line'></div><div class='line'><span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> </span><span style=\"color: #1C6277\">D</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> </span><span style=\"color: #1C6277\">C</span><span style=\"color: #000000\"> {</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #001080\">foo</span><span style=\"color: #000000\"> = </span><span style=\"color: #098658\">20</span><span style=\"color: #000000\">;</span></div><div class='line'></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #795E26\">dHelper</span><span style=\"color: #000000\">() {</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #AF00DB\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">foo</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #000000\">    }</span></div><div class='line'><span style=\"color: #000000\">}</span></div><div class='line'></div><div class='line'><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">instance</span><span style=\"color: #000000\"> = </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">D</span><span style=\"color: #000000\">();</span></div><div class='line'><span style=\"color: #008000\">// 'this.foo' 는 각 인스턴스마다 같은 프로퍼티를 참조합니다.</span></div><div class='line'><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">instance</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">cHelper</span><span style=\"color: #000000\">()); </span><span style=\"color: #008000\">// '20' 출력</span></div><div class='line'><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">instance</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">dHelper</span><span style=\"color: #000000\">()); </span><span style=\"color: #008000\">// '20' 출력</span></div></code></div></pre>\n<p>비공개 필드에서는, 포함하고 있는 클래스에서 각각의 필드 이름이 유일하기 때문에 이에 대해 걱정하지 않아도 됩니다.</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> </span><span style=\"color: #1C6277\">C</span><span style=\"color: #000000\"> {</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #001080\">#foo</span><span style=\"color: #000000\"> = </span><span style=\"color: #098658\">10</span><span style=\"color: #000000\">;</span></div><div class='line'></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #795E26\">cHelper</span><span style=\"color: #000000\">() {</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #AF00DB\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">#foo</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #000000\">    }</span></div><div class='line'><span style=\"color: #000000\">}</span></div><div class='line'></div><div class='line'><span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> </span><span style=\"color: #1C6277\">D</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">extends</span><span style=\"color: #000000\"> </span><span style=\"color: #1C6277\">C</span><span style=\"color: #000000\"> {</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #001080\">#foo</span><span style=\"color: #000000\"> = </span><span style=\"color: #098658\">20</span><span style=\"color: #000000\">;</span></div><div class='line'></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #795E26\">dHelper</span><span style=\"color: #000000\">() {</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #AF00DB\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">#foo</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #000000\">    }</span></div><div class='line'><span style=\"color: #000000\">}</span></div><div class='line'></div><div class='line'><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">instance</span><span style=\"color: #000000\"> = </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">D</span><span style=\"color: #000000\">();</span></div><div class='line'><span style=\"color: #008000\">// 'this.#foo' 는 각 클래스안의 다른 필드를 참조합니다.</span></div><div class='line'><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">instance</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">cHelper</span><span style=\"color: #000000\">()); </span><span style=\"color: #008000\">// '10' 출력</span></div><div class='line'><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">instance</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">dHelper</span><span style=\"color: #000000\">()); </span><span style=\"color: #008000\">// '20' 출력</span></div></code></div></pre>\n<p>알아 두면 좋은 또 다른 점은 다른 타입으로 비공개 필드에 접근하면 <code>TypeError</code> 를 발생한다는 것입니다.</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> </span><span style=\"color: #1C6277\">Square</span><span style=\"color: #000000\"> {</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #001080\">#sideLength</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">number</span><span style=\"color: #000000\">;</span></div><div class='line'></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">constructor</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">sideLength</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">number</span><span style=\"color: #000000\">) {</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">#sideLength</span><span style=\"color: #000000\"> = </span><span style=\"color: #001080\">sideLength</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #000000\">    }</span></div><div class='line'></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #795E26\">equals</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">other</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">any</span><span style=\"color: #000000\">) {</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #AF00DB\">return</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">#sideLength</span><span style=\"color: #000000\"> === </span><span style=\"color: #001080\">other</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">#sideLength</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #000000\">    }</span></div><div class='line'><span style=\"color: #000000\">}</span></div><div class='line'></div><div class='line'><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #0070C1\">a</span><span style=\"color: #000000\"> = </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">Square</span><span style=\"color: #000000\">(</span><span style=\"color: #098658\">100</span><span style=\"color: #000000\">);</span></div><div class='line'><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #0070C1\">b</span><span style=\"color: #000000\"> = { </span><span style=\"color: #001080\">sideLength:</span><span style=\"color: #000000\"> </span><span style=\"color: #098658\">100</span><span style=\"color: #000000\"> };</span></div><div class='line'></div><div class='line'><span style=\"color: #008000\">// Boom!</span></div><div class='line'><span style=\"color: #008000\">// TypeError: attempted to get private field on non-instance</span></div><div class='line'><span style=\"color: #008000\">// 이는 `b` 가 `Square`의 인스턴스가 아니기 때문에 실패 합니다.</span></div><div class='line'><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">a</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">equals</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">b</span><span style=\"color: #000000\">));</span></div></code></div></pre>\n<p>마자막으로, 모든 일반 <code>.js</code> 파일 사용자들의 경우, 비공개 필드는 <em>항상</em> 할당되기 전에 선언되어야 합니다.</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">js</div><div class='code-container'><code><div class='line'><span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> </span><span style=\"color: #1C6277\">C</span><span style=\"color: #000000\"> {</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #008000\">// '#foo' 선언이 없습니다.</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #008000\">// :(</span></div><div class='line'></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">constructor</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">foo</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">number</span><span style=\"color: #000000\">) {</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #008000\">// SyntaxError!</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #008000\">// '#foo'는 쓰여지기 전에 선언되어야 합니다.</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">#foo</span><span style=\"color: #000000\"> = </span><span style=\"color: #001080\">foo</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #000000\">    }</span></div><div class='line'><span style=\"color: #000000\">}</span></div></code></div></pre>\n<p>JavaScript는 항상 사용자들에게 선언되지 않은 프로퍼티에 접근을 허용했지만, TypeScript는 항상 클래스 프로퍼티 선언을 요구했습니다.\n비공개 필드는, <code>.js</code> 또는 <code>.ts</code> 파일에서 동작하는지 상관없이 항상 선언이 필요합니다.</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">js</div><div class='code-container'><code><div class='line'><span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> </span><span style=\"color: #1C6277\">C</span><span style=\"color: #000000\"> {</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #008000\">/** </span><span style=\"color: #0000FF\">@type</span><span style=\"color: #008000\"> </span><span style=\"color: #1C6277\">{number}</span><span style=\"color: #008000\"> */</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #001080\">#foo</span><span style=\"color: #000000\">;</span></div><div class='line'></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">constructor</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">foo</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">number</span><span style=\"color: #000000\">) {</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #008000\">// 동작합니다.</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">#foo</span><span style=\"color: #000000\"> = </span><span style=\"color: #001080\">foo</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #000000\">    }</span></div><div class='line'><span style=\"color: #000000\">}</span></div></code></div></pre>\n<p>구현에 대한 더 많은 정보는, <a href=\"https://github.com/Microsoft/TypeScript/pull/30829\">the original pull request</a>를 참고하세요</p>\n<h3 id=\"어떤-것을-사용해야-할까요-which-should-i-use\" style=\"position:relative;\"><a href=\"#%EC%96%B4%EB%96%A4-%EA%B2%83%EC%9D%84-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%95%BC-%ED%95%A0%EA%B9%8C%EC%9A%94-which-should-i-use\" aria-label=\"어떤 것을 사용해야 할까요 which should i use permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>어떤 것을 사용해야 할까요? (Which should I use?)</h3>\n<p>이미 TypeScript 유저로서 어떤 종류의 비공개를 사용해야 하는지에 대한 많은 질문을 받았습니다: 주로, ”<code>private</code> 키워드를 사용해야 하나요 아니면 ECMAScript의 해시/우물 (<code>#</code>) 비공개 필드를 사용해야 하나요?”\n상황마다 다릅니다!</p>\n<p>프로퍼티에서, TypeScript의 <code>private</code> 지정자는 완전히 지워집니다 - 이는 런타임에서는 완전히 일반 프로퍼티처럼 동작하며 이것이 <code>private</code> 지정자로 선언되었다고 알릴 방법이 없습니다.\n<code>private</code> 키워드를 사용할 때, 비공개는 오직 컴파일-타임/디자인-타임에만 시행되며, JavaScript 사용자에게는 전적으로 의도-기반입니다.</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> </span><span style=\"color: #1C6277\">C</span><span style=\"color: #000000\"> {</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">private</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">foo</span><span style=\"color: #000000\"> = </span><span style=\"color: #098658\">10</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #000000\">}</span></div><div class='line'></div><div class='line'><span style=\"color: #008000\">// 이는 컴파일 타임에 오류이지만</span></div><div class='line'><span style=\"color: #008000\">// TypeScript 가 .js 파일로 출력했을 때는</span></div><div class='line'><span style=\"color: #008000\">// 잘 동작하며 '10'을 출력합니다.</span></div><div class='line'><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">C</span><span style=\"color: #000000\">().</span><span style=\"color: #001080\">foo</span><span style=\"color: #000000\">);    </span><span style=\"color: #008000\">// '10' 출력</span></div><div class='line'><span style=\"color: #008000\">//                  ~~~</span></div><div class='line'><span style=\"color: #008000\">// error! Property 'foo' is private and only accessible within class 'C'.</span></div><div class='line'></div><div class='line'><span style=\"color: #008000\">// TypeScript 오류를 피하기 위한 \"해결 방법\" 으로</span></div><div class='line'><span style=\"color: #008000\">// 캄파일 타임에 이것을 허용합니다.</span></div><div class='line'><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">C</span><span style=\"color: #000000\">()[</span><span style=\"color: #A31515\">\"foo\"</span><span style=\"color: #000000\">]); </span><span style=\"color: #008000\">// prints '10'</span></div></code></div></pre>\n<p>이 같은 종류의 “약한 비공개(soft privacy)“는 사용자가 API에 접근할 수 없는 상태에서 일시적으로 작업을 하는 데 도움이 되며, 어떤 런타임에서도 동작합니다.</p>\n<p>반면에, ECMAScript의 <code>#</code> 비공개는 완벽하게 클래스 밖에서 접근 불가능합니다.</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> </span><span style=\"color: #1C6277\">C</span><span style=\"color: #000000\"> {</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #001080\">#foo</span><span style=\"color: #000000\"> = </span><span style=\"color: #098658\">10</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #000000\">}</span></div><div class='line'></div><div class='line'><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">C</span><span style=\"color: #000000\">().</span><span style=\"color: #001080\">#foo</span><span style=\"color: #000000\">); </span><span style=\"color: #008000\">// SyntaxError</span></div><div class='line'><span style=\"color: #008000\">//                  ~~~~</span></div><div class='line'><span style=\"color: #008000\">// TypeScript 는 오류를 보고 하며 *또한*</span></div><div class='line'><span style=\"color: #008000\">// 런타임에도 동작하지 않습니다.</span></div><div class='line'></div><div class='line'><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">C</span><span style=\"color: #000000\">()[</span><span style=\"color: #A31515\">\"#foo\"</span><span style=\"color: #000000\">]); </span><span style=\"color: #008000\">// undefined 출력</span></div><div class='line'><span style=\"color: #008000\">//          ~~~~~~~~~~~~~~~</span></div><div class='line'><span style=\"color: #008000\">// TypeScript 는 'noImplicitAny' 하에서 오류를 보고하며</span></div><div class='line'><span style=\"color: #008000\">// `undefined`를 출력합니다.</span></div></code></div></pre>\n<p>이런 강한 비공개(hard privacy)는 아무도 내부를 사용할 수 없도록 엄격하게 보장하는데 유용합니다.\n만약 라이브러리 작성자일 경우, 비공개 필드를 제거하거나 이름을 바꾸는 것이 급격한 변화를 초래서는 안됩니다.</p>\n<p>언급했듯이, 다른 장점은 ECMAScript의 <code>#</code> 비공개가 <em>진짜</em> 비공개이기 때문에 서브클래싱을 쉽게 할 수 있다는 것입니다.\nECMAScript <code>#</code> 비공개 필드를 사용하면, 어떤 서브 클래스도 필드 네이밍 충돌에 대해 걱정할 필요가 없습니다.\nTypeScript의 <code>private</code>프로퍼티 선언에서는, 사용자는 여전히 상위 클래스에 선언된 프로퍼티를 짓밟지  않도록 주의해야 합니다.</p>\n<p>한 가지 더 생각해봐야 할 것은 코드가 실행되기를 의도하는 곳입니다.\n현재 TypeScript는 이 기능을 ECMAScript 2015 (ES6) 이상 버전을 대상으로 하지 않으면 지원할 수 없습니다.\n이는 하위 레벨 구현이 비공개를 강제하기 위해 <code>WeakMap</code>을 사용하는데, <code>WeakMap</code>은 메모리 누수를 잃으키지 않도록 폴리필될 수 없기 때문입니다.\n반면, TypeScript의 <code>private</code>-선언 프로퍼티는 모든 대상에서 동작합니다- ECMAScript3에서도!</p>\n<p>마지막 고려 사항은 속도 일수 있습니다: <code>private</code> 프로퍼티는 다른 어떤 프로퍼티와 다르지 않기 때문에, 어떤 런타임을 대상으로 하단 다른 프로퍼티와 마찬가지로 접근 속도가 빠를 수 있습니다.\n반면에, <code>#</code> 비공개 필드는 <code>WeakMap</code>을 이용해 다운 레벨 되기 때문에 사용 속도가 느려질 수 있습니다.\n어떤 런타임은 <code>#</code> 비공개 필드 구현을 최적화 하고, 더 빠른 <code>WeakMap</code>을 구현하고 싶을 수 있지만, 모든 런타임에서 그렇지 않을 수 있습니다.</p>\n<h2 id=\"export--as-ns-구문-export--as-ns-syntax\" style=\"position:relative;\"><a href=\"#export--as-ns-%EA%B5%AC%EB%AC%B8-export--as-ns-syntax\" aria-label=\"export  as ns 구문 export  as ns syntax permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>export * as ns</code> 구문 (<code>export * as ns</code> Syntax)</h2>\n<p>다른 모듈의 모든 멤버를 하나의 멤버로 내보내는 단일 진입점을 갖는 것은 종종 일반적입니다.</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">*</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">as</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">utilities</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./utilities.js\"</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #AF00DB\">export</span><span style=\"color: #000000\"> { </span><span style=\"color: #001080\">utilities</span><span style=\"color: #000000\"> };</span></div></code></div></pre>\n<p>이는 매우 일반적이어서 ECMAScript2020은 최근에 이 패턴을 지원하기 위해서 새로운 구문을 추가했습니다.</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #AF00DB\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">*</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">as</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">utilities</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"./utilities.js\"</span><span style=\"color: #000000\">;</span></div></code></div></pre>\n<p>이것은 JavaScript에 대한 훌륭한 삶의 질의 향상이며, TypeScript 3.8은 이 구문을 지원합니다.\n모듈 대상이 <code>es2020</code> 이전인 경우, TypeScript는 첫 번째 줄의 코드 스니펫을 따라서 무언가를 출력할 것입니다.</p>\n<h2 id=\"최상위-레벨-await-top-level-await\" style=\"position:relative;\"><a href=\"#%EC%B5%9C%EC%83%81%EC%9C%84-%EB%A0%88%EB%B2%A8-await-top-level-await\" aria-label=\"최상위 레벨 await top level await permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>최상위-레벨 <code>await</code> (Top-Level <code>await</code>)</h2>\n<p>TypeScript 3.8은 “최상위-레벨 <code>await</code>“이라는 편리한 ECMAScript 기능을 지원합니다.</p>\n<p>JavaScript 사용자는 <code>await</code>을 사용하기 위해 <code>async</code> 함수를 도입하는 경우가 많으며, 이를 정의한 후 즉시 함수를 호출합니다.</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">js</div><div class='code-container'><code><div class='line'><span style=\"color: #0000FF\">async</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">main</span><span style=\"color: #000000\">() {</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #0070C1\">response</span><span style=\"color: #000000\"> = </span><span style=\"color: #AF00DB\">await</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">fetch</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">\"...\"</span><span style=\"color: #000000\">);</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #0070C1\">greeting</span><span style=\"color: #000000\"> = </span><span style=\"color: #AF00DB\">await</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">response</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">text</span><span style=\"color: #000000\">();</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">greeting</span><span style=\"color: #000000\">);</span></div><div class='line'><span style=\"color: #000000\">}</span></div><div class='line'></div><div class='line'><span style=\"color: #795E26\">main</span><span style=\"color: #000000\">()</span></div><div class='line'><span style=\"color: #000000\">    .</span><span style=\"color: #795E26\">catch</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">e</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">=&gt;</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">error</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">e</span><span style=\"color: #000000\">))</span></div></code></div></pre>\n<p>이전의 JavaScript(유사한 기능을 가진 대부분의 다른 언어들과 함께)에서 <code>await</code>은 <code>async</code> 함수 내에서 만 허용되었기 때문입니다.\n하지만 최상위-레벨 <code>await</code>로, 우리는 모듈의 최상위 레벨에서 <code>await</code>을 사용할 수 있습니다.</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #0070C1\">response</span><span style=\"color: #000000\"> = </span><span style=\"color: #AF00DB\">await</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">fetch</span><span style=\"color: #000000\">(</span><span style=\"color: #A31515\">\"...\"</span><span style=\"color: #000000\">);</span></div><div class='line'><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #0070C1\">greeting</span><span style=\"color: #000000\"> = </span><span style=\"color: #AF00DB\">await</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">response</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">text</span><span style=\"color: #000000\">();</span></div><div class='line'><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">greeting</span><span style=\"color: #000000\">);</span></div><div class='line'></div><div class='line'><span style=\"color: #008000\">// 모듈인지 확인</span></div><div class='line'><span style=\"color: #AF00DB\">export</span><span style=\"color: #000000\"> {};</span></div></code></div></pre>\n<p>유의할 점이 있습니다: 최상위-레벨 <code>await</code>은 <em>module</em>의 최상위 레벨에서만 동작하며, 파일은 TypeScript가 <code>import</code>나 <code>export</code>를 찾을 때에만 모듈로 간주됩니다.\n일부 기본적인 경우에 <code>export {}</code>와 같은 보일러 플레이트를 작성하여 이를 확인할 필요가 있습니다.</p>\n<p>이러한 경우가 예상되는 모든 환경에서 최상위 레벨 <code>await</code>은 동작하지 않을 수 있습니다.\n현재, <code>target</code> 컴파일러 옵션이 <code>es2017</code> 이상이고, <code>module</code>이 <code>esnext</code> 또는 <code>system</code>인 경우에만 최상위 레벨 <code>await</code>을 사용할 수 있습니다.\n몇몇 환경과 번들러내에서의 지원은 제한적으로 작동하거나 실험적 지원을 활성화해야 할 수도 있습니다.</p>\n<p>구현에 관한 더 자세한 정보는 <a href=\"https://github.com/microsoft/TypeScript/pull/35813\">the original pull request을 확인하세요</a>.</p>\n<h2 id=\"es2020용-target과-module---es2020-for-target-and-module\" style=\"position:relative;\"><a href=\"#es2020%EC%9A%A9-target%EA%B3%BC-module---es2020-for-target-and-module\" aria-label=\"es2020용 target과 module   es2020 for target and module permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>es2020</code>용 <code>target</code>과 <code>module</code>   (<code>es2020</code> for <code>target</code> and <code>module</code>)</h2>\n<p>TypeScript 3.8은 <code>es2020</code>을 <code>module</code>과 <code>target</code> 옵션으로 지원합니다.\n이를 통해 선택적 체이닝 (optional chaining), nullish 병합 (nullish coalescing), <code>export * as ns</code> 그리고 동적인 <code>import(...)</code> 구문과 같은 ECMAScript 2020 기능이 유지됩니다.\n또한 <code>bigint</code> 리터럴이 <code>esnext</code> 아래에 안정적인 <code>target</code>을 갖는 것을 의미합니다.</p>\n<h2 id=\"jsdoc-프로퍼티-지정자-jsdoc-property-modifiers\" style=\"position:relative;\"><a href=\"#jsdoc-%ED%94%84%EB%A1%9C%ED%8D%BC%ED%8B%B0-%EC%A7%80%EC%A0%95%EC%9E%90-jsdoc-property-modifiers\" aria-label=\"jsdoc 프로퍼티 지정자 jsdoc property modifiers permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>JSDoc 프로퍼티 지정자 (JSDoc Property Modifiers)</h2>\n<p>TypeScript 3.8는 <code>allowJs</code> 플래그를 사용하여 JavaScript 파일을 지원하고 <code>checkJs</code> 옵션이나 <code>// @ts-check</code> 주석을 <code>.js</code> 파일 맨 위에 추가하여 JavaScript 파일의 <em>타입-검사</em>를 지원합니다.</p>\n<p>JavaScript 파일에는 타입-검사를 위한 전용 구문이 없기 때문에 TypeScript는 JSDoc을 활용합니다.\nTypeScript 3.8은 프로퍼티에 대한 몇 가지 새로운 JSDoc 태그를 인식합니다.</p>\n<p>먼저 접근 지정자입니다: <code>@public</code>, <code>@private</code> 그리고 <code>@protected</code>입니다.\n이 태그들은 TypeScript 내에서 각각 <code>public</code>, <code>private</code>, <code>protected</code>와 동일하게 동작합니다.</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">js</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// @ts-check</span></div><div class='line'></div><div class='line'><span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> </span><span style=\"color: #1C6277\">Foo</span><span style=\"color: #000000\"> {</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">constructor</span><span style=\"color: #000000\">() {</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #008000\">/** </span><span style=\"color: #0000FF\">@private</span><span style=\"color: #008000\"> */</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">stuff</span><span style=\"color: #000000\"> = </span><span style=\"color: #098658\">100</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #000000\">    }</span></div><div class='line'></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #795E26\">printStuff</span><span style=\"color: #000000\">() {</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">stuff</span><span style=\"color: #000000\">);</span></div><div class='line'><span style=\"color: #000000\">    }</span></div><div class='line'><span style=\"color: #000000\">}</span></div><div class='line'></div><div class='line'><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">Foo</span><span style=\"color: #000000\">().</span><span style=\"color: #001080\">stuff</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #008000\">//        ~~~~~</span></div><div class='line'><span style=\"color: #008000\">// 오류! 'stuff' 프로퍼티는 private 이기 때문에 오직 'Foo' 클래스 내에서만 접근이 가능합니다.</span></div></code></div></pre>\n<ul>\n<li><code>@public</code>은 항상 암시적이며 생략될 수 있지만, 어디서든 해당 프로퍼티에 접근 가능을 의미합니다.</li>\n<li><code>@private</code>은 오직 프로퍼티를 포함하는 클래스 내에서 해당 프로퍼티 사용 가능을 의미합니다.</li>\n<li><code>@protected</code>는 프로퍼티를 포함하는 클래스와 파생된 모든 하위 클래스내에서 해당 프로퍼티를 사용할 수 있지만, 포함하는 클래스의 인스턴스는 해당 프로퍼티를 사용할 수 없습니다.</li>\n</ul>\n<p>다음으로 <code>@readonly</code> 지정자를 추가하여 프로퍼티가 초기화 과정 내에서만 값이 쓰이는 것을 보장합니다.</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">js</div><div class='code-container'><code><div class='line'><span style=\"color: #008000\">// @ts-check</span></div><div class='line'></div><div class='line'><span style=\"color: #0000FF\">class</span><span style=\"color: #000000\"> </span><span style=\"color: #1C6277\">Foo</span><span style=\"color: #000000\"> {</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0000FF\">constructor</span><span style=\"color: #000000\">() {</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #008000\">/** </span><span style=\"color: #0000FF\">@readonly</span><span style=\"color: #008000\"> */</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">stuff</span><span style=\"color: #000000\"> = </span><span style=\"color: #098658\">100</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #000000\">    }</span></div><div class='line'></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #795E26\">writeToStuff</span><span style=\"color: #000000\">() {</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #0000FF\">this</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">stuff</span><span style=\"color: #000000\"> = </span><span style=\"color: #098658\">200</span><span style=\"color: #000000\">;</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #008000\">//   ~~~~~</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #008000\">// 'stuff'는 읽기-전용(read-only) 프로퍼티이기 때문에 할당할 수 없습니다.</span></div><div class='line'><span style=\"color: #000000\">    }</span></div><div class='line'><span style=\"color: #000000\">}</span></div><div class='line'></div><div class='line'><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">Foo</span><span style=\"color: #000000\">().</span><span style=\"color: #001080\">stuff</span><span style=\"color: #000000\">++;</span></div><div class='line'><span style=\"color: #008000\">//        ~~~~~</span></div><div class='line'><span style=\"color: #008000\">// 'stuff'는 읽기-전용(read-only) 프로퍼티이기 때문에 할당할 수 없습니다.</span></div></code></div></pre>\n<h2 id=\"리눅스에서-더-나은-디렉터리-감시와-watchoptions\" style=\"position:relative;\"><a href=\"#%EB%A6%AC%EB%88%85%EC%8A%A4%EC%97%90%EC%84%9C-%EB%8D%94-%EB%82%98%EC%9D%80-%EB%94%94%EB%A0%89%ED%84%B0%EB%A6%AC-%EA%B0%90%EC%8B%9C%EC%99%80-watchoptions\" aria-label=\"리눅스에서 더 나은 디렉터리 감시와 watchoptions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>리눅스에서 더 나은 디렉터리 감시와 <code>watchOptions</code></h2>\n<p>TypeScript 3.8에서는 <code>node_modules</code>의 변경사항을 효율적으로 수집하는데 중요한 새로운 디렉터리 감시 전략을 제공합니다.</p>\n<p>리눅스와 같은 운영체제에서 TypeScript는 <code>node_modules</code>에 디렉터리 왓쳐(파일 왓쳐와는 반대로)를 설치하고, 의존성 변화를 감지하기 위해 많은 하위 디렉터리를 설치합니다.\n왜냐하면 사용 가능한 파일 왓쳐의 수는 종종 <code>node_modules</code>의 파일 수에 의해 가려지기 때문이고, 추적할 디렉터리 수가 적기 때문입니다.</p>\n<p>TypeScript의 이전 버전은 폴더에 디렉터리 왓쳐를 <em>즉시</em> 설치하며, 초기에는 괜찮을 겁니다; 하지만, npm install 할 때, <code>node_modules</code>안에서 많은 일들이 발생할 것이고, TypeScript를 압도하여, 종종 에디터 세션을 아주 느리게 만듭니다.\n이를 방지하기 위해, TypeScript 3.8은 디렉터리 왓쳐를 설치하기 전에 조금 기다려서 변동성이 높은 디렉터리에게 안정될 수 있는 시간을 줍니다.</p>\n<p>왜냐하면 모든 프로젝트는 다른 전략에서 더 잘 작동할 수 있고, 이 새로운 방법은 당신의 작업 흐름에서는 잘 맞지 않을 수 있습니다. TypeScript 3.8은 파일과 디렉터리를 감시하는데 어떤 감시 전략을 사용할지 컴파일러/언어 서비스에 알려줄 수 있도록 <code>tsconfig.json</code>과 <code>jsconfig.json</code>에 <code>watchOptions</code>란 새로운 필드를 제공합니다.</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">json</div><div class='code-container'><code><div class='line'><span style=\"color: #000000\">{</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #008000\">// 일반적인 컴파일러 옵션들</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"compilerOptions\"</span><span style=\"color: #000000\">: {</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #0451A5\">\"target\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"es2020\"</span><span style=\"color: #000000\">,</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #0451A5\">\"moduleResolution\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"node\"</span><span style=\"color: #000000\">,</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #008000\">// ...</span></div><div class='line'><span style=\"color: #000000\">    },</span></div><div class='line'></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #008000\">// NEW: 파일/디렉터리 감시를 위한 옵션</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"watchOptions\"</span><span style=\"color: #000000\">: {</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #008000\">// 파일과 디렉터리에 네이티브 파일 시스템 이벤트 사용</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #0451A5\">\"watchFile\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"useFsEvents\"</span><span style=\"color: #000000\">,</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #0451A5\">\"watchDirectory\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"useFsEvents\"</span><span style=\"color: #000000\">,</span></div><div class='line'></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #008000\">// 업데이트가 빈번할 때</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #008000\">// 업데이트하기 위해 더 자주 파일을 폴링</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #0451A5\">\"fallbackPolling\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\"dynamicPriority\"</span></div><div class='line'><span style=\"color: #000000\">    }</span></div><div class='line'><span style=\"color: #000000\">}</span></div></code></div></pre>\n<p><code>watchOptions</code>는 구성할 수 있는 4가지 새로운 옵션이 포함되어 있습니다.</p>\n<ul>\n<li><code>watchFile</code>: 각 파일의 감시 방법 전략. 다음과 같이 설정할 수 있습니다:\n<ul>\n<li><code>fixedPollingInterval</code>: 고정된 간격으로 모든 파일의 변경을 1초에 여러 번 검사합니다.</li>\n<li><code>priorityPollingInterval</code>: 모든 파일의 변경을 1초에 여러 번 검사합니다, 하지만 휴리스틱을 사용하여 특정 타입의 파일은 다른 타입의 파일보다 덜 자주 검사합니다.</li>\n<li><code>dynamicPriorityPolling</code>: 동적 큐를 사용하여 덜-자주 수정된 파일은 적게 검사합니다.</li>\n<li><code>useFsEvents</code> (디폴트): 파일 변화에 운영체제/파일 시스템의 네이티브 이벤트를 사용합니다.</li>\n<li><code>useFsEventsOnParentDirectory</code>: 파일을 포함하고 있는 디렉터리 변경을 감지할 때, 운영체제/파일 시스템의 네이티브 이벤트를 사용합니다. 파일 왓쳐를 적게 사용할 수 있지만, 덜 정확할 수 있습니다.</li>\n</ul>\n</li>\n<li><code>watchDirectory</code>: 재귀적인 파일-감시 기능이 없는 시스템 안에서 전체 디렉터리 트리가 감시되는 전략. 다음과 같이 설정할 수 있습니다:\n<ul>\n<li><code>fixedPollingInterval</code>: 고정된 간격으로 모든 디렉터리의 변경을 1초에 여러 번 검사합니다.</li>\n<li><code>dynamicPriorityPolling</code>: 동적 큐를 사용하여 덜-자주 수정된 디렉터리는 적게 검사합니다.</li>\n<li><code>useFsEvents</code> (디폴트): 디렉터리 변경에 운영체제/파일 시스템의 네이티브 이벤트를 사용합니다.</li>\n</ul>\n</li>\n<li><code>fallbackPolling</code>: 파일 시스템 이벤트를 사용할 때, 이 옵션은 시스템이 네이티브 파일 왓쳐가 부족하거나/혹은 지원하지 않을 때, 사용되는 폴링 전략을 지정합니다. 다음과 같이 설정할 수 있습니다.\n<ul>\n<li><code>fixedPollingInterval</code>: <em>(위를 참조하세요.)</em></li>\n<li><code>priorityPollingInterval</code>: <em>(위를 참조하세요.)</em></li>\n<li><code>dynamicPriorityPolling</code>: <em>(위를 참조하세요.)</em></li>\n</ul>\n</li>\n<li><code>synchronousWatchDirectory</code>: 디렉터리의 연기된 감시를 비활성화합니다. 연기된 감시는 많은 파일이 한 번에 변경될 때 유용합니다 (예를 들어, <code>npm install</code>을 실행하여 <code>node_modules</code>의 변경), 하지만 덜-일반적인 설정을 위해 비활성화할 수도 있습니다.</li>\n</ul>\n<p>이 변경의 더 자세한 내용은 Github으로 이동하여 <a href=\"https://github.com/microsoft/TypeScript/pull/35615\">the pull request</a>를 읽어보세요.</p>\n<h2 id=\"빠르고-느슨한-증분-검사\" style=\"position:relative;\"><a href=\"#%EB%B9%A0%EB%A5%B4%EA%B3%A0-%EB%8A%90%EC%8A%A8%ED%95%9C-%EC%A6%9D%EB%B6%84-%EA%B2%80%EC%82%AC\" aria-label=\"빠르고 느슨한 증분 검사 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>“빠르고 느슨한” 증분 검사</h2>\n<p>TypeScript 3.8은 새로운 컴파일러 옵션 <code>assumeChangesOnlyAffectDirectDepencies</code>을 제공합니다.\n이 옵션이 활성화되면, TypeScript는 정말로 영향을 받은 파일들은 재검사/재빌드하지않고, 변경된 파일뿐만 아니라 직접 import 한 파일만 재검사/재빌드 합니다.</p>\n<p>예를 들어, 다음과 같이 <code>fileA.ts</code>를 import 한 <code>fileB.ts</code>를 import 한 <code>fileC.ts</code>를 import 한 <code>fileD.ts</code>를 살펴봅시다:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">text</div><div class='code-container'><code><div class='line'><span style=\"color: undefined\">fileA.ts &lt;- fileB.ts &lt;- fileC.ts &lt;- fileD.ts</span></div></code></div></pre>\n<p><code>--watch</code> 모드에서는, <code>fileA.ts</code>의 변경이 <code>fileB.ts</code>, <code>fileC.ts</code> 그리고 <code>fileD.ts</code>를 TypeScript가 재-검사해야 한다는 의미입니다.\n<code>assumeChangesOnlyAffectDirectDependencies</code>에서는 <code>fileA.ts</code>의 변경은 <code>fileA.ts</code>와 <code>fileB.ts</code>만 재-검사하면 됩니다.</p>\n<p>Visual Studio Code와 같은 코드 베이스에서는, 특정 파일의 변경에 대해 약 14초에서 약 1초로 재빌드 시간을 줄여주었습니다.\n이 옵션을 모든 코드 베이스에서 추천하는 것은 아니지만, 큰 코드 베이스를 가지고 있고, 나중까지 전체 프로젝트 오류를 기꺼이 연기하겠다면 (예를 들어, <code>tsconfig.fullbuild.json</code>이나 CI를 통한 전용 빌드) 흥미로울 것입니다.</p>\n<p>더 자세한 내용은 <a href=\"https://github.com/microsoft/TypeScript/pull/35711\">the original pull request</a>에서 보실 수 있습니다.</p>","headings":[{"value":"타입-전용 Imports 와 Exports (Type-Only Imports and Exports)","depth":2},{"value":"ECMAScript 비공개 필드 (ECMAScript Private Fields)","depth":2},{"value":"어떤 것을 사용해야 할까요? (Which should I use?)","depth":3},{"value":"export * as ns 구문 (export * as ns Syntax)","depth":2},{"value":"최상위-레벨 await (Top-Level await)","depth":2},{"value":"es2020용 target과 module   (es2020 for target and module)","depth":2},{"value":"JSDoc 프로퍼티 지정자 (JSDoc Property Modifiers)","depth":2},{"value":"리눅스에서 더 나은 디렉터리 감시와 watchOptions","depth":2},{"value":"“빠르고 느슨한” 증분 검사","depth":2}],"frontmatter":{"permalink":"/ko/docs/handbook/release-notes/typescript-3-8.html","title":"TypeScript 3.8","disable_toc":null,"handbook":null,"oneline":"TypeScript 3.8 Release Notes","preamble":null,"deprecated_by":null,"deprecation_redirects":null,"experimental":null}},"prev":null,"next":null},"pageContext":{"id":"5-typescript-3.8","slug":"/ko/docs/handbook/release-notes/typescript-3-8.html","repoPath":"/packages/documentation/copy/ko/release-notes/TypeScript 3.8.md","lang":"ko","modifiedTime":"2024-10-21T12:35:09.565Z"}},"staticQueryHashes":[]}