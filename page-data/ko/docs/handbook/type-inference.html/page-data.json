{"componentChunkName":"component---src-templates-documentation-tsx","path":"/ko/docs/handbook/type-inference.html","result":{"data":{"markdownRemark":{"id":"02c5047b-e2b3-558c-a5f5-429ecd684bfb","excerpt":"TypeScript에는 명시적인 타입 표기가 없을 때 타입 정보를 제공하기 위해 타입 추론이 사용되는 여러 위치가 있습니다. 예를 들어, 이 코드에서 보면 x 변수의 타입은 number…","html":"<p>TypeScript에는 명시적인 타입 표기가 없을 때 타입 정보를 제공하기 위해 타입 추론이 사용되는 여러 위치가 있습니다. 예를 들어, 이 코드에서 보면</p>\n<pre class=\"shiki light-plus twoslash lsp\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\"><data-lsp lsp='let x: number' style='border-bottom: solid 2px lightgrey;'>x</data-lsp></span><span style=\"color: #000000\"> = </span><span style=\"color: #098658\">3</span><span style=\"color: #000000\">;</span></div><div class='meta-line'><span class='popover-prefix'>   </span><span class='popover'><div class='arrow'></div>let x: number</span></div></code><a class='playground-link' href='https://www.typescriptlang.org/play/#code/DYUwLgBAHhC8EGYDcAoA9GiEB6B+IA'>Try</a></div></pre>\n<p><code>x</code> 변수의 타입은 <code>number</code> 로 추론됩니다.\n이러한 종류의 추론은 변수와 멤버를 초기화하고 매개변수 기본값을 설정하며, 함수 반환 타입을 결정할 때 발생합니다.</p>\n<p>대부분의 유형 추론은 간단합니다.\n다음 부분에서는 유형을 추론하는 방법에 대한 몇 가지 뉘앙스를 살펴보겠습니다.</p>\n<h2 id=\"최적-공통-타입\" style=\"position:relative;\"><a href=\"#%EC%B5%9C%EC%A0%81-%EA%B3%B5%ED%86%B5-%ED%83%80%EC%9E%85\" aria-label=\"최적 공통 타입 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>최적 공통 타입</h2>\n<p>여러 표현 식에서 타입을 추론할 때, 표현식들의 타입을 이용해 “최적 공통 타입”을 계산합니다. 예를 들어서:</p>\n<pre class=\"shiki light-plus twoslash lsp\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\"><data-lsp lsp='let x: (number | null)[]' style='border-bottom: solid 2px lightgrey;'>x</data-lsp></span><span style=\"color: #000000\"> = [</span><span style=\"color: #098658\">0</span><span style=\"color: #000000\">, </span><span style=\"color: #098658\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #0000FF\">null</span><span style=\"color: #000000\">];</span></div><div class='meta-line'><span class='popover-prefix'>   </span><span class='popover'><div class='arrow'></div>let x: (number | null)[]</span></div></code><a class='playground-link' href='https://www.typescriptlang.org/play/#code/DYUwLgBAHhC8EG0AMAaCBGNA7ArsYAugNwBQA9GRBAHoD8QA'>Try</a></div></pre>\n<p>위의 예에서 <code>x</code> 의 타입을 추론하려면 각 배열 요소의 타입들을 고려해야 합니다.\n여기서 배열 타입에 대해 이 두 가지의 선택 사항을 제공합니다:  <code>number</code> 와 <code>null</code>.\n가장 일반적인 타입 알고리즘은 각 후보 타입을 고려해서, 다른 모든 후보와 호환되는 타입을 결정합니다.</p>\n<p>제공된 후보 타입에서 최적의 공통 타입을 선택해야 하므로 타입이 공통적인 구조를 공유하지만, 한 타입이 모든 후보 타입의 슈퍼 타입이 아닐 수가 있습니다. 예를 들면:</p>\n<pre class=\"shiki light-plus twoslash lsp\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\"><data-lsp lsp='let zoo: (Rhino | Elephant | Snake)[]' style='border-bottom: solid 2px lightgrey;'>zoo</data-lsp></span><span style=\"color: #000000\"> = [</span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\"><data-lsp lsp='constructor Rhino(): Rhino' >Rhino</data-lsp></span><span style=\"color: #000000\">(), </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\"><data-lsp lsp='constructor Elephant(): Elephant' >Elephant</data-lsp></span><span style=\"color: #000000\">(), </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\"><data-lsp lsp='constructor Snake(): Snake' >Snake</data-lsp></span><span style=\"color: #000000\">()];</span></div><div class='meta-line'><span class='popover-prefix'>    </span><span class='popover'><div class='arrow'></div>let zoo: (Rhino | Elephant | Snake)[]</span></div></code><a class='playground-link' href='https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgCCAdvALY6gDeAvkSWaAEoAW8VA9qDwAPaHioATctToNGBUKG6kAEv1hU0cAK54A3AVbFS5AKLY8AB2VVoQ0eKmUa9bEwVLSAFVjaqAay1ffUM2E1AAZSpMfzx7MUlpFzkPZUgAGTwAc0g0LFwQ1hBQAFoyxG1oMpKCCzsAL35BAF5QAG0qPAB3Ll4BAAoASgAaUE6e8ysbaCHR8cjo2KGAXQNixVAAPQB+IA'>Try</a></div></pre>\n<p>이상적으로는, <code>zoo</code> 가 <code>Animal[]</code> 로 추론되기를 원할 수 있지만, 배열에 <code>Animal</code> 타입의 객체가 없으므로 엄격하게 판단하여, 배열 요소 타입으로 추론하지 않습니다.\n이를 수정하려면, 한 타입이 다른 모든 후보의 상위 타입이 아닌 경우 유형을 명시적으로 제공해야합니다:</p>\n<pre class=\"shiki light-plus twoslash lsp\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\"><data-lsp lsp='let zoo: Animal[]' style='border-bottom: solid 2px lightgrey;'>zoo</data-lsp></span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\"><data-lsp lsp='class Animal' >Animal</data-lsp></span><span style=\"color: #000000\">[] = [</span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\"><data-lsp lsp='constructor Rhino(): Rhino' >Rhino</data-lsp></span><span style=\"color: #000000\">(), </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\"><data-lsp lsp='constructor Elephant(): Elephant' >Elephant</data-lsp></span><span style=\"color: #000000\">(), </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\"><data-lsp lsp='constructor Snake(): Snake' >Snake</data-lsp></span><span style=\"color: #000000\">()];</span></div><div class='meta-line'><span class='popover-prefix'>    </span><span class='popover'><div class='arrow'></div>let zoo: Animal[]</span></div></code><a class='playground-link' href='https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgCCAdvALY6gDeAvkSWaAEoAW8VA9qDwAPaHioATctToNGBUKG6kAEv1hU0cAK54A3AVbFS5AKLY8AB2VVoQ0eKmUa9bEwVLSAFVjaqAay1ffUM2E1AAZSpMfzx7MUlpFzkPZUgAGTwAc0g0LFwQ1hBQAFoyxG1oMpKCCzsAL35+NBlXAG0AXVAAXlA2qjwAdy5eAQAKAEoAGlAB4fMrG2hJmbnI6NjJjoNixVAAPQB+IA'>Try</a></div></pre>\n<p>최적 공통 타입이 발견되지 않으면, 추론 결과는 유니언 배열 타입 <code>(Rhino | Elephant | Snake)[]</code> 입니다.</p>\n<h2 id=\"문맥상-타이핑\" style=\"position:relative;\"><a href=\"#%EB%AC%B8%EB%A7%A5%EC%83%81-%ED%83%80%EC%9D%B4%ED%95%91\" aria-label=\"문맥상 타이핑 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>문맥상 타이핑</h2>\n<p>TypeScript의 타입 추론은 때에 따라 “다른 방향”에서도 작동합니다.\n이를 “문맥상 타이핑”이라고 합니다. 문맥상 타이핑은 표현식의 타입이 위치에 의해 암시될 때 발생합니다. 예를 들면:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #001080\">window</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">onmousedown</span><span style=\"color: #000000\"> = </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> (</span><span style=\"color: #001080\">mouseEvent</span><span style=\"color: #000000\">) {</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">mouseEvent</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">button</span><span style=\"color: #000000\">); </span><span style=\"color: #008000\">//&lt;- OK</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">mouseEvent</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">kangaroo</span><span style=\"color: #000000\">); </span><span style=\"color: #008000\">//&lt;- Error!</span></div><div class='line'><span style=\"color: #000000\">};</span></div></code></div></pre>\n<p>여기서, TypeScript 타입 검사기는 <code>Window.onmousedown</code> 함수의 타입을 사용하여 오른쪽에 할당된 함수 표현식의 타입을 추론했습니다.\n여기선, <code>button</code>이 포함된 <code>mouseEvent</code> 매개변수의 <a href=\"https://developer.mozilla.org/docs/Web/API/MouseEvent\">타입</a> 을 추론할 수 있었습니다. 그러나 <code>kangaroo</code> 는 아닙니다.</p>\n<p>TypeScript는 다른 문맥에서도 타입을 추론할 수 있을 만큼 똑똑합니다:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #001080\">window</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">onscroll</span><span style=\"color: #000000\"> = </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> (</span><span style=\"color: #001080\">uiEvent</span><span style=\"color: #000000\">) {</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">uiEvent</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">button</span><span style=\"color: #000000\">); </span><span style=\"color: #008000\">//&lt;- Error!</span></div><div class='line'><span style=\"color: #000000\">};</span></div></code></div></pre>\n<p>위의 함수가 <code>Window.onscroll</code> 에 할당된다는 사실을 바탕으로, TypeScript는 <code>uiEvent</code> 가 이전 예제와 같은 <a href=\"https://developer.mozilla.org/docs/Web/API/MouseEvent\">MouseEvent</a> 가 아니라 <a href=\"https://developer.mozilla.org/docs/Web/API/UIEvent\">UIEvent</a> 임을 알고 있습니다. <code>UIEvent</code> 객체에는 <code>button</code> 프로퍼티가 없으므로, TypeScript에서 오류가 발생합니다.</p>\n<p>이 함수가 컨텍스트 타입 위치에 있지 않았을 때 함수의 인수는 암시적으로 <code>any</code> 타입을 가지며, 오류가 발생하지 않습니다. ( <code>--noImplicitAny</code> 옵션을 사용하지 않는다면):</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">handler</span><span style=\"color: #000000\"> = </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> (</span><span style=\"color: #001080\">uiEvent</span><span style=\"color: #000000\">) {</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">uiEvent</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">button</span><span style=\"color: #000000\">); </span><span style=\"color: #008000\">//&lt;- OK</span></div><div class='line'><span style=\"color: #000000\">};</span></div></code></div></pre>\n<p>또한, 함수의 인수에 타입 정보를 명시적으로 제공하여 컨텍스트 타입을 재정의할 수도 있습니다.</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #001080\">window</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">onscroll</span><span style=\"color: #000000\"> = </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> (</span><span style=\"color: #001080\">uiEvent</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">any</span><span style=\"color: #000000\">) {</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">uiEvent</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">button</span><span style=\"color: #000000\">); </span><span style=\"color: #008000\">//&lt;- Now, no error is given</span></div><div class='line'><span style=\"color: #000000\">};</span></div></code></div></pre>\n<p>그러나 이 코드는 <code>uiEvent</code> 에 <code>button</code> 이라는 프로퍼티가 없으므로 <code>undefined</code> 을 기록합니다.</p>\n<p>문맥상 타이핑은 많은 경우에 적용됩니다.\n일반적으로는 함수 호출에 대한 인수, 오른쪽에 할당된 것, 타입 어셜션(assertions), 개체 및 배열 리터럴의 멤버, 반환문이 포함됩니다.\n컨텍스트 타입은 또한 가장 일반적인 타입에서 후보 타입으로 작동합니다. 예를 들면:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">createZoo</span><span style=\"color: #000000\">(): </span><span style=\"color: #1C6277\">Animal</span><span style=\"color: #000000\">[] {</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #AF00DB\">return</span><span style=\"color: #000000\"> [</span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">Rhino</span><span style=\"color: #000000\">(), </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">Elephant</span><span style=\"color: #000000\">(), </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">Snake</span><span style=\"color: #000000\">()];</span></div><div class='line'><span style=\"color: #000000\">}</span></div></code></div></pre>\n<p>이 예에서 가장 일반적인 타입에는, 이와 같은 네 가지의 후보 셋이 있습니다: <code>Animal</code>, <code>Rhino</code>, <code>Elephant</code>, and <code>Snake</code>.\n이 중에서, <code>Animal</code> 은 최적 공통 타입 알고리즘으로 선택할 수 있습니다.</p>","headings":[{"value":"최적 공통 타입","depth":2},{"value":"문맥상 타이핑","depth":2}],"frontmatter":{"permalink":"/ko/docs/handbook/type-inference.html","title":"Type Inference","disable_toc":null,"handbook":null,"oneline":"How code flow analysis works in TypeScript","preamble":null,"deprecated_by":null,"deprecation_redirects":null,"experimental":null}},"prev":null,"next":null},"pageContext":{"id":"2-type-inference","slug":"/ko/docs/handbook/type-inference.html","repoPath":"/packages/documentation/copy/ko/reference/Type Inference.md","lang":"ko","modifiedTime":"2024-10-21T12:35:09.561Z"}},"staticQueryHashes":[]}