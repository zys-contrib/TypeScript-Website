{"componentChunkName":"component---src-templates-documentation-tsx","path":"/ko/docs/handbook/module-resolution.html","result":{"data":{"markdownRemark":{"id":"e3a7478e-866b-5854-9025-206d773149c5","excerpt":"이번 섹션은 모듈에 대한 기초적인 지식을 전제로 합니다.\n더 많은 정보는 모듈을 보도록 하세요. 모듈 해석 (module resolution) 은 컴파일러가 import가 무엇을 참조하는지 알아내기 위해 사용하는 프로세스입니다.\nimport { a } from \"moduleA…","html":"<blockquote>\n<p>이번 섹션은 모듈에 대한 기초적인 지식을 전제로 합니다.\n더 많은 정보는 <a href=\"./modules.md\">모듈</a>을 보도록 하세요.</p>\n</blockquote>\n<p><em>모듈 해석 (module resolution)</em> 은 컴파일러가 import가 무엇을 참조하는지 알아내기 위해 사용하는 프로세스입니다.\n<code>import { a } from \"moduleA\"</code>같은 import 문을 생각해보세요;\n<code>a</code>의 모든 사용을 검사하기 위해, 컴파일러는 무엇을 참조하는지 정확히 알아야 할 필요가 있습니다, 그리고 <code>moduleA</code> 정의를 검사해야 할 필요가 있습니다.</p>\n<p>이 시점에, 컴파일러는 ”<code>moduleA</code>의 형태가 뭘까?”라고 질문할 것입니다.\n간단해 보이지만, <code>moduleA</code>는 <code>.ts</code>/<code>.tsx</code> 파일에 정의되어 있거나 혹은 코드가 의존하는 <code>.d.ts</code>에 정의되어 있을 수 있습니다.</p>\n<p>첫 번째로, 컴파일러는 가져온 모듈을 나타내는 파일의 위치를 찾으려고 할 것입니다.\n그렇게 하기 위해 컴파일러는 두 가지 다른 전략 중 하나를 따릅니다: <a href=\"#%ED%81%B4%EB%9E%98%EC%8B%9D-classic\">클래식</a> 혹은 <a href=\"#%EB%85%B8%EB%93%9C-node\">노드</a>.\n이 전략들은 컴파일러가 <code>moduleA</code>를 찾기 위해 <em>어디</em>를 봐야 할지 알려줍니다.</p>\n<p>만약 이 방법이 잘 안되고 모듈 이름이 비-상대적이라면 (<code>\"moduleA</code>의 경우가 그렇습니다), 컴파일러는 <a href=\"./modules.md#Ambient-%EB%AA%A8%EB%93%88-Ambient-Modules\">ambient 모듈 선언</a>을 찾으려고 할 것입니다.\n비-상대적 import는 다음에 다룰 것입니다.</p>\n<p>마지막으로, 컴파일러가 모듈을 해석할 수 없다면, 오류 로그가 발생합니다.\n이 경우에, 오류는 <code>error TS2307: Cannot find module 'moduleA'</code>와 같습니다.</p>\n<h2 id=\"상대적-vs-비-상대적-모듈-import-relative-vs-non-relative-module-imports\" style=\"position:relative;\"><a href=\"#%EC%83%81%EB%8C%80%EC%A0%81-vs-%EB%B9%84-%EC%83%81%EB%8C%80%EC%A0%81-%EB%AA%A8%EB%93%88-import-relative-vs-non-relative-module-imports\" aria-label=\"상대적 vs 비 상대적 모듈 import relative vs non relative module imports permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>상대적 vs. 비-상대적 모듈 import (Relative vs. Non-relative module imports)</h2>\n<p>모듈 참조가 상대적 혹은 비-상대적이냐에 따라 모듈 import는 다르게 해석됩니다.</p>\n<p><em>상대적 import</em> 는 <code>/</code>, <code>./</code> 혹은 <code>../</code>. 중에 하나로 시작합니다.\n일부 예제는 다음과 같습니다:</p>\n<ul>\n<li><code>import Entry from \"./components/Entry\";</code></li>\n<li><code>import { DefaultHeaders } from \"../constants/http\";</code></li>\n<li><code>import \"/mod\";</code></li>\n</ul>\n<p>다른 모든 import는 <strong>비-상대적</strong> 으로 간주됩니다.\n일부 예제는 다음과 같습니다:</p>\n<ul>\n<li><code>import * as $ from \"jquery\";</code></li>\n<li><code>import { Component } from \"@angular/core\";</code></li>\n</ul>\n<p>상대적 import는 가져온 파일에 상대적으로 해석되고 ambient 모듈 선언으로 해석 <em>될 수 없습니다</em>.\n자신의 모듈에 대해서는 런타임에 상대적 위치를 유지하는 것을 보장하는 상대적 import를 사용해야 합니다.</p>\n<p>비-상대적 import는 <code>baseUrl</code>로 해석되거나, 밑에서 다루게 될 경로 매핑으로 해석될 수 있습니다.\n<a href=\"./modules.md#Ambient-%EB%AA%A8%EB%93%88-Ambient-modules\">ambient 모듈 선언</a>으로도 해석될 수 있습니다.\n외부 의존성을 import 할 때, 비-상대적 경로를 사용하세요.</p>\n<h2 id=\"모듈-해석-전략-module-resolution-strategies\" style=\"position:relative;\"><a href=\"#%EB%AA%A8%EB%93%88-%ED%95%B4%EC%84%9D-%EC%A0%84%EB%9E%B5-module-resolution-strategies\" aria-label=\"모듈 해석 전략 module resolution strategies permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>모듈 해석 전략 (Module Resolution Strategies)</h2>\n<p>두 가지 가능한 모듈 해석 전략이 있습니다: <a href=\"#%EB%85%B8%EB%93%9C-node\">노드</a>와 <a href=\"#%ED%81%B4%EB%9E%98%EC%8B%9D-classic\">클래식</a>.\n<code>--moduleResolution</code> 플래그를 사용하여 모듈 해석 전략을 지정할 수 있습니다.\n지정되지 않았으면, 디폴트는 <code>--module AMD | System | ES2015</code>에서는 [클래식][#클래식-classic]이고 나머지는 <a href=\"#%EB%85%B8%EB%93%9C-node\">노드</a>입니다.</p>\n<h3 id=\"클래식-classic\" style=\"position:relative;\"><a href=\"#%ED%81%B4%EB%9E%98%EC%8B%9D-classic\" aria-label=\"클래식 classic permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>클래식 (Classic)</h3>\n<p>TypeScript의 디폴트 해석 전략으로 사용됩니다.\n요즘에, 이 전략은 주로 이전 버전과의 호환성을 위해 제공됩니다.</p>\n<p>상대적 import는 import하는 파일에 상대적으로 해석됩니다.\n그래서 소스 파일 <code>/root/src/folder/A.ts</code>안에 import { b } from “./moduleB”`는 다음과 같이 조회합니다:</p>\n<ol>\n<li><code>/root/src/folder/moduleB.ts</code></li>\n<li><code>/root/src/folder/moduleB.d.ts</code></li>\n</ol>\n<p>그러나, 비-상대적 모듈 import에서는, 컴파일러가 가져온 파일을 갖고 있는 디렉터리부터 시작해서 디렉터리 트리를 거슬러 올라가 맞는 정의 파일의 위치를 찾으려고 합니다.</p>\n<p>예를 들어:</p>\n<p>소스 파일 <code>/root/src/folder/A.ts</code>안에 <code>import { b } from \"moduleB\"</code>처럼 <code>moduleB</code>의 비-상대적 import은 <code>\"moduleB\"</code>의 위치를 찾기 위해 다음과 같은 위치를 찾습니다.</p>\n<ol>\n<li><code>/root/src/folder/moduleB.ts</code></li>\n<li><code>/root/src/folder/moduleB.d.ts</code></li>\n<li><code>/root/src/moduleB.ts</code></li>\n<li><code>/root/src/moduleB.d.ts</code></li>\n<li><code>/root/moduleB.ts</code></li>\n<li><code>/root/moduleB.d.ts</code></li>\n<li><code>/moduleB.ts</code></li>\n<li><code>/moduleB.d.ts</code></li>\n</ol>\n<h3 id=\"노드-node\" style=\"position:relative;\"><a href=\"#%EB%85%B8%EB%93%9C-node\" aria-label=\"노드 node permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>노드 (Node)</h3>\n<p>이 해석 전략은 런타임에 <a href=\"https://nodejs.org/\">Node.js</a>의 모듈 해석 메커니즘을 모방하려고 시도합니다.\n전체 Node.js 해석 알고리즘은 <a href=\"https://nodejs.org/api/modules.html#modules_all_together\">Node.js 모듈 문서</a>에 요약되어 있습니다.</p>\n<h4 id=\"nodejs가-모듈을-해석하는-방법-how-nodejs-resolves-modules\" style=\"position:relative;\"><a href=\"#nodejs%EA%B0%80-%EB%AA%A8%EB%93%88%EC%9D%84-%ED%95%B4%EC%84%9D%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-how-nodejs-resolves-modules\" aria-label=\"nodejs가 모듈을 해석하는 방법 how nodejs resolves modules permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Node.js가 모듈을 해석하는 방법 (How Node.js resolves modules)</h4>\n<p>TS 컴파일러가 어떤 과정을 따를지 이해하기 위해서는, Node.js 모듈을 이해하는 것이 중요합니다.\n전통적으로, Node.js의 import는 <code>require</code> 함수를 호출해 수행합니다.\nNode.js의 동작은 <code>require</code>에 상대적 경로 혹은 비-상대적 경로가 주어지는지에 따라 달라집니다.</p>\n<p>상대적 경로는 아주 간단합니다.\n예를 들어, <code>var x = require(\"./moduleB\");</code>라는 import 문을 포함한 <code>/root/src/moduleA.js</code>에 위치한 파일을 생각해봅시다.\nNode.js는 다음 순서로 import를 해석합니다:</p>\n<ol>\n<li>\n<p><code>/root/src/moduleB.js</code>라는 파일이 존재하는지 확인.</p>\n</li>\n<li>\n<p>만약 <code>\"main\"</code> 모듈을 지정하는 <code>package.json</code>라는 파일을 포함하고 있으면, <code>/root/src/moduleB</code> 폴더 확인하기.</p>\n</li>\n</ol>\n<p>이 예제에서는, 만약 Node.js가 <code>{ \"main\": \"lib/mainModule.js\" }</code>을 포함하는 <code>/root/src/moduleB/package.json</code>파일을 찾았다면, Node.js가 <code>/root/src/moduleB/lib/mainModule.js</code>를 참조할 것입니다.</p>\n<ol start=\"3\">\n<li><code>index.js</code> 라는 파일을 포함하고 있으면, <code>/root/src/moduleB</code> 확인하기.\n이 파일은 폴더의 “main” 모듈임을 암시적으로 나타냅니다.</li>\n</ol>\n<p>자세한 내용은 Node.js 문서 <a href=\"https://nodejs.org/api/modules.html#modules_file_modules\">파일 모듈</a>과 <a href=\"https://nodejs.org/api/modules.html#modules_folders_as_modules\">폴더 모듈</a>에서 더 읽어보실 수 있습니다.</p>\n<p>그러나, <a href=\"#relative-vs-non-relative-module-imports\">비-상대적 모듈 이름</a>에 대한 해석은 다르게 수행합니다.\nNode는 <code>node_modules</code>로 불리는 특별한 폴더에서 모듈을 찾을 것입니다.\n<code>node_modules</code> 폴더는 현재 파일과 동일한 레벨이거나, 디렉터리 체인에서 더 높을 수도 있습니다.\nNode는 디렉터리 체인을 올라가, 로드하려는 모듈을 찾을 때까지 각 <code>node_modules</code>을 찾습니다.</p>\n<p>위의 예제를 따라서, <code>/root/src/moduleA.js</code>가 대신 비-상대적 경로를 사용하고 <code>var x = require(\"moduleB\");</code> import를 가지고 있다고 생각해봅시다.\nNode는 하나가 일치할 때까지 각 위치에서 <code>moduleB</code>를 해석하려고 시도합니다.</p>\n<ol>\n<li><code>/root/src/node_modules/moduleB.js</code></li>\n<li><code>/root/src/node_modules/moduleB/package.json</code> (<code>\"main\"</code> 항목을 지정했다면)</li>\n<li><code>/root/src/node_modules/moduleB/index.js</code>\n<br /><br /></li>\n<li><code>/root/node_modules/moduleB.js</code></li>\n<li><code>/root/node_modules/moduleB/package.json</code> (<code>\"main\"</code> 항목을 지정했다면)</li>\n<li><code>/root/node_modules/moduleB/index.js</code>\n<br /><br /></li>\n<li><code>/node_modules/moduleB.js</code></li>\n<li><code>/node_modules/moduleB/package.json</code> (<code>\"main\"</code> 항목을 지정했다면)</li>\n<li><code>/node_modules/moduleB/index.js</code></li>\n</ol>\n<p>Node.js가 (4) 와 (7)에서 디렉터리를 점프했다는 것에 주목하세요.</p>\n<p>프로세스에 대한 더 많은 정보는 Node.js 문서 <a href=\"https://nodejs.org/api/modules.html#modules_loading_from_node_modules_folders\"><code>node_modules</code>에서 모듈 로드하기</a>에서 읽어보실 수 있습니다.</p>\n<h4 id=\"typescript가-모듈을-해석하는-방법-how-typescript-resolves-modules\" style=\"position:relative;\"><a href=\"#typescript%EA%B0%80-%EB%AA%A8%EB%93%88%EC%9D%84-%ED%95%B4%EC%84%9D%ED%95%98%EB%8A%94-%EB%B0%A9%EB%B2%95-how-typescript-resolves-modules\" aria-label=\"typescript가 모듈을 해석하는 방법 how typescript resolves modules permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TypeScript가 모듈을 해석하는 방법 (How TypeScript resolves modules)</h4>\n<p>TypeScript는 컴파일-타임에 모듈의 정의 파일 위치를 찾기 위해 Node.js의 런타임 해석 전략을 모방합니다.\n이를 달성하기 위해, TypeScript는 TypeScript 소스 파일 확장자 (<code>.ts</code>, <code>.tsx</code> 와 <code>.d.ts</code>)를 Node의 해석 로직 위에 씌웁니다.\nTypeScript는 <code>\"main\"</code>의 목적 - 컴파일러가 이를 사용하여 참조할 “main” 정의 파일을 찾음. 을 반영하기 위해 <code>\"types\"</code>라는 <code>package.json</code>안에 필드를 사용합니다</p>\n<p>예를 들어, <code>/root/src/moduleA.ts</code>안에 <code>import { b } from \"./moduleB\"</code> 같은 import 문은 <code>\"./moduleB\"</code>의 위치를 찾기 위해 다음과 같은 위치를 찾습니다.</p>\n<ol>\n<li><code>/root/src/moduleB.ts</code></li>\n<li><code>/root/src/moduleB.tsx</code></li>\n<li><code>/root/src/moduleB.d.ts</code></li>\n<li><code>/root/src/moduleB/package.json</code> (<code>\"types\"</code> 항목을 지정했다면)</li>\n<li><code>/root/src/moduleB/index.ts</code></li>\n<li><code>/root/src/moduleB/index.tsx</code></li>\n<li><code>/root/src/moduleB/index.d.ts</code></li>\n</ol>\n<p>Node.js가 <code>moduleB.js</code> 파일을 찾고 나서, 해당하는 <code>package.json</code>을 찾고, <code>index.js</code>를 찾았다는 것을 상기해봅시다.</p>\n<p>비슷하게, 비-상대적 import는 Node.js 해석 로직을 따릅니다, 첫 번째로 파일을 찾고, 그러고 나서 해당하는 폴더를 찾습니다.\n그래서 <code>/root/src/moduleA.ts</code> 소스 파일 안에 <code>import { b } from \"moduleB\"</code>는 다음과 같은 조회를 합니다.</p>\n<ol>\n<li><code>/root/src/node_modules/moduleB.ts</code></li>\n<li><code>/root/src/node_modules/moduleB.tsx</code></li>\n<li><code>/root/src/node_modules/moduleB.d.ts</code></li>\n<li><code>/root/src/node_modules/moduleB/package.json</code> (<code>\"types\"</code> 프로퍼티를 지정했다면)</li>\n<li><code>/root/src/node_modules/@types/moduleB.d.ts</code></li>\n<li><code>/root/src/node_modules/moduleB/index.ts</code></li>\n<li><code>/root/src/node_modules/moduleB/index.tsx</code></li>\n<li><code>/root/src/node_modules/moduleB/index.d.ts</code>\n<br /><br /></li>\n<li><code>/root/node_modules/moduleB.ts</code></li>\n<li><code>/root/node_modules/moduleB.tsx</code></li>\n<li><code>/root/node_modules/moduleB.d.ts</code></li>\n<li><code>/root/node_modules/moduleB/package.json</code> (<code>\"types\"</code> 항목을 지정했다면)</li>\n<li><code>/root/node_modules/@types/moduleB.d.ts</code></li>\n<li><code>/root/node_modules/moduleB/index.ts</code></li>\n<li><code>/root/node_modules/moduleB/index.tsx</code></li>\n<li><code>/root/node_modules/moduleB/index.d.ts</code>\n<br /><br /></li>\n<li><code>/node_modules/moduleB.ts</code></li>\n<li><code>/node_modules/moduleB.tsx</code></li>\n<li><code>/node_modules/moduleB.d.ts</code></li>\n<li><code>/node_modules/moduleB/package.json</code> (<code>\"types\"</code> 항목을 지정했다면)</li>\n<li><code>/node_modules/@types/moduleB.d.ts</code></li>\n<li><code>/node_modules/moduleB/index.ts</code></li>\n<li><code>/node_modules/moduleB/index.tsx</code></li>\n<li><code>/node_modules/moduleB/index.d.ts</code></li>\n</ol>\n<p>스텝 수 때문에 두려워하지 마세요 - TypeScript가 여전히 디렉터리를 (9)와 (17)에서 두 번 점프합니다.</p>\n<p>Node.js가 하는 것보다 더 복잡하지 않습니다.</p>\n<h2 id=\"추가-모듈-해석-플래그-additional-module-resolution-flags\" style=\"position:relative;\"><a href=\"#%EC%B6%94%EA%B0%80-%EB%AA%A8%EB%93%88-%ED%95%B4%EC%84%9D-%ED%94%8C%EB%9E%98%EA%B7%B8-additional-module-resolution-flags\" aria-label=\"추가 모듈 해석 플래그 additional module resolution flags permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>추가 모듈 해석 플래그 (Additional module resolution flags)</h2>\n<p>프로젝트 소스 레이아웃이 출력과 일치하지 않을 때도 있습니다.\n일반적으로 일련의 빌드 스텝이 생성된 최종 출력을 만듭니다.\n<code>.ts</code>파일을 <code>.js</code>로 컴파일하고, 다른 소스 위치에서 하나의 출력 위치로 의존성을 복사하는 것을 포함합니다.\n최종 결과는 런타임의 모듈이 해당 정의를 포함하는 소스 파일과 다른 이름을 가질 수 있다는 것이다.\n혹은 최종 출력의 모듈 경로가 컴파일 타임에 해당하는 소스 파일 경로와 일치하지 않을 수 있습니다.</p>\n<p>TypeScript 컴파일러는 추가 플래그를 갖고 있습니다.\nThe TypeScript compiler has a set of additional flags to <em>inform</em> the compiler of transformations that are expected to happen to the sources to generate the final output.\nTypeScript 컴파일러는 최종 출력을 생성하기위해 소스에 발생할 것으로 예상되는 변환을 컴파일러에게 <em>알리기</em> 위한 추가 플래그 세트가 있습니다.</p>\n<p>컴파일러가 이러한 변환도 수행하지 <em>않는</em> 다는 것에 유의하십시오;\n정의 파일로 모듈 import를 해석하는 과정을 안내하기 위해 이러한 정보를 사용합니다.</p>\n<h3 id=\"기본-url-base-url\" style=\"position:relative;\"><a href=\"#%EA%B8%B0%EB%B3%B8-url-base-url\" aria-label=\"기본 url base url permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>기본 URL (Base URL)</h3>\n<p><code>baseUrl</code>을 사용하는 것은 모듈들이 런타임에 단일 폴더로 “배포”되는 AMD 모듈 로더를 사용하는 애플리케이션에서 일반적인 방법입니다.\n이 모듈들의 소스는 다른 디렉터리 안에 있을 수 있지만, 빌드 스크립트가 모두 하나로 만들 것입니다.</p>\n<p><code>baseUrl</code>을 설정하는 것은 컴파일러에게 어디에서 모듈을 찾을지 알려주는 것입니다.\n모든 비-상대적 이름의 모듈 import는 <code>baseUrl</code>에 상대적이라고 가정합니다.</p>\n<p><em>baseUrl</em>의 값은 다음 중 하나로 결정됩니다:</p>\n<ul>\n<li><em>baseUrl</em> 명령 줄 인수 값 (만약 주어진 경로가 상대적이면, 현재 디렉터리를 기준으로 계산됨)</li>\n<li>‘tsconfig.json’안에 <em>baseUrl</em> 프로퍼티 값 (만약 주어진 경로가 상대적이면, ‘tsconfig.json’의 위치를 기준으로 계산됨)</li>\n</ul>\n<p>상대적 모듈 import는 항상 가져온 파일의 상대적으로 해석되기 때문에, baseUrl을 설정하는 것에 영향을 받지 않는 점에 유의하십시오.</p>\n<p>baseUrl에 대한 더 많은 문서는 <a href=\"http://requirejs.org/docs/api.html#config-baseUrl\">RequireJS</a>와 <a href=\"https://github.com/systemjs/systemjs/blob/master/docs/config-api.md#baseurl\">SystemJS</a> 문서에서 찾으실 수 있습니다.</p>\n<h3 id=\"경로-매핑-path-mapping\" style=\"position:relative;\"><a href=\"#%EA%B2%BD%EB%A1%9C-%EB%A7%A4%ED%95%91-path-mapping\" aria-label=\"경로 매핑 path mapping permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>경로 매핑 (Path mapping)</h3>\n<p>가끔 모듈이 <em>baseUrl</em> 아래에 위치하지 않는 경우가 있습니다.\n예를 들어, <code>\"jquery\"</code> 모듈의 import는 런타임에 <code>\"node_modules/jquery/dist/jquery.slim.min.js\"</code>로 번역됩니다.\n로더는 런타임에 모듈 이름을 파일에 매핑하기 위해 매핑 구성을 사용합니다, <a href=\"http://requirejs.org/docs/api.html#config-paths\">RequireJs 문서</a>와 <a href=\"https://github.com/systemjs/systemjs/blob/master/docs/config-api.md#paths\">SystemJS 문서</a>를 보세요.</p>\n<p>TypeScript 컴파일러는 <code>tsconfig.json</code> 파일 안에 <code>\"paths\"</code> 프로퍼티를 사용한 매핑의 선언을 지원합니다.\n<code>jquery</code>를 위한 <code>\"paths\"</code> 프로퍼티를 지정하는 방법에 대한 예제가 있습니다.</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">json</div><div class='code-container'><code><div class='line'><span style=\"color: #000000\">{</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #0451A5\">\"compilerOptions\"</span><span style=\"color: #000000\">: {</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"baseUrl\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\".\"</span><span style=\"color: #000000\">, </span><span style=\"color: #008000\">// \"paths\"가 있는 경우 반드시 지정되어야함.</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"paths\"</span><span style=\"color: #000000\">: {</span></div><div class='line'><span style=\"color: #000000\">      </span><span style=\"color: #0451A5\">\"jquery\"</span><span style=\"color: #000000\">: [</span><span style=\"color: #A31515\">\"node_modules/jquery/dist/jquery\"</span><span style=\"color: #000000\">] </span><span style=\"color: #008000\">// 이 매핑은 \"baseUrl\"에 상대적임.</span></div><div class='line'><span style=\"color: #000000\">    }</span></div><div class='line'><span style=\"color: #000000\">  }</span></div><div class='line'><span style=\"color: #000000\">}</span></div></code></div></pre>\n<p><code>\"paths\"</code>가 <code>\"baseUrl\"</code>에 상대적으로 해석된다는 점에 주목하세요.\n<code>\"baseUrl\"</code>을 <code>\".\"</code>가 아닌 다른 값, 예 <code>tsconfig.json</code>의 디렉터리,으로 설정하면, 그에 따라 매핑도 바뀝니다.\n만약 위 예제에서 “baseUrl”: “./src” 로 설정한다면, jquery는 “../node_modules/jquery/dist/jquery” 로 매핑되어야 합니다.</p>\n<p><code>\"paths\"</code>를 사용하는 것은 여러 개의 이전 위치를 포함한 정교한 매핑이 가능합니다.\n일부 모듈만 한 위치에서 사용 가능하고, 나머지는 다른 곳에 있는 프로젝트 구성을 생각해보세요.\n빌드 스텝이 한곳으로 모을 것입니다.\n프로젝트의 레이아웃은 다음과 같이 보입니다:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class='code-container'><code>projectRoot\n├── folder1\n│   ├── file1.ts (imports 'folder1/file2' and 'folder2/file3')\n│   └── file2.ts\n├── generated\n│   ├── folder1\n│   └── folder2\n│       └── file3.ts\n└── tsconfig.json</code></div></pre><!-- Note from shiki-twoslash: the language tree was not set up for Shiki to use, and so there is no code highlighting --!>\n<p><code>tsconfig.json</code>는 다음과 같이 보일 것입니다:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">json</div><div class='code-container'><code><div class='line'><span style=\"color: #000000\">{</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #0451A5\">\"compilerOptions\"</span><span style=\"color: #000000\">: {</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"baseUrl\"</span><span style=\"color: #000000\">: </span><span style=\"color: #A31515\">\".\"</span><span style=\"color: #000000\">,</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"paths\"</span><span style=\"color: #000000\">: {</span></div><div class='line'><span style=\"color: #000000\">      </span><span style=\"color: #0451A5\">\"*\"</span><span style=\"color: #000000\">: [</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #A31515\">\"*\"</span><span style=\"color: #000000\">,</span></div><div class='line'><span style=\"color: #000000\">        </span><span style=\"color: #A31515\">\"generated/*\"</span></div><div class='line'><span style=\"color: #000000\">      ]</span></div><div class='line'><span style=\"color: #000000\">    }</span></div><div class='line'><span style=\"color: #000000\">  }</span></div><div class='line'><span style=\"color: #000000\">}</span></div></code></div></pre>\n<p>이는 컴파일러에게 두 위치에서 패턴 <code>\"*\"</code> (i.e. 모든 값) 과 일치하는 모든 모듈 import를 알려줍니다</p>\n<ol>\n<li><code>\"*\"</code>: 같은 이름은 바뀌지 않음을 의미, 그래서 <code>&#x3C;moduleName></code> => <code>&#x3C;baseUrl>/&#x3C;moduleName></code>으로 매핑</li>\n<li><code>\"generated/*\"</code> 접두사 “generated”가 추가된 모듈 이름을 의미, 그래서 <code>&#x3C;moduleName></code> => <code>&#x3C;baseUrl>/generated/&#x3C;moduleName></code>로 매핑</li>\n</ol>\n<p>이 로직을 따르면, 컴파일러는 다음과 같은 두 가지 import를 해석하려고 할 것입니다:</p>\n<p>import ‘folder1/file2’:</p>\n<ol>\n<li>모듈 ’*‘은 일치하고 와일드카드가 전체 모듈 이름을 캡처함</li>\n<li>목록에서 첫 번째 대체 시도: ’*’ -> <code>folder1/file2</code></li>\n<li>대체의 결과가 비-상대적 이름 - <em>baseUrl</em>과 결합 -> <code>projectRoot/folder1/file2.ts</code></li>\n<li>파일이 존재. 완료.</li>\n</ol>\n<p>import ‘folder2/file3’:</p>\n<ol>\n<li>모듈 ’*‘은 일치하고 와일드카드가 전체 모듈 이름을 캡처함</li>\n<li>목록에서 첫 번째 대체 시도: ’*’ -> <code>folder2/file3</code></li>\n<li>대체의 결과가 비-상대적 이름 - <em>baseUrl</em>과 결합 -> <code>projectRoot/folder2/file3.ts</code></li>\n<li>파일이 존재하지 않음, 두 번째 대체로 이동</li>\n<li>두 번째 대체 ‘generated/*’ -> <code>generated/folder2/file3</code></li>\n<li>대체의 결과가 비-상대적 이름 - <em>baseUrl</em>과 결합 -> <code>projectRoot/generated/folder2/file3.ts</code></li>\n<li>파일이 존재. 완료.</li>\n</ol>\n<h3 id=\"rootdirs-가상-디렉터리-virtual-directories-with-rootdirs\" style=\"position:relative;\"><a href=\"#rootdirs-%EA%B0%80%EC%83%81-%EB%94%94%EB%A0%89%ED%84%B0%EB%A6%AC-virtual-directories-with-rootdirs\" aria-label=\"rootdirs 가상 디렉터리 virtual directories with rootdirs permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>rootDirs</code> 가상 디렉터리 (Virtual Directories with <code>rootDirs</code>)</h3>\n<p>때때로 컴파일 타임에 여러 디렉터리의 프로젝트 소스가 모두 결합되어 단일 출력 디렉터리를 생성합니다.\n여러 소스 디렉터리가 “가상” 디렉터리를 생성하는 것으로 보입니다.</p>\n<p>‘rootDirs’를 사용하면, 컴파일러에게 이 “가상” 디렉터리를 구성하는 <em>roots</em>를 알릴 수 있습니다;\n따라서 컴파일러는 이러한 “가상”디렉터리 내에서 상대적 모듈 import를 <em>마치</em> 하나의 디렉터리에 같이 병합 한 것처럼 해석할 수 있습니다.</p>\n<p>예를 들어 이 프로젝트 구조를 생각해보세요:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class='code-container'><code> src\n └── views\n     └── view1.ts (imports './template1')\n     └── view2.ts\n\n generated\n └── templates\n         └── views\n             └── template1.ts (imports './view2')</code></div></pre><!-- Note from shiki-twoslash: the language tree was not set up for Shiki to use, and so there is no code highlighting --!>\n<p><code>src/views</code> 안의 파일들은 UI 컨트롤을 위한 유저 코드입니다.\n<code>generated/templated</code> 안의 파일들은, 빌드의 일부로써 템플릿 생성기에 의해 자동-생성된 UI 템플릿 바인딩 코드입니다.\n빌드 스텝은 <code>/src/view</code>와 <code>/generated/templates/views</code>를 출력에서 같은 디렉터리로 복사합니다.\n런타임에서, 뷰는 템플릿이 옆에 있다고 기대할 것이기 때문에, <code>\"./template\"</code>처럼 상대적인 이름을 import에서 사용해야 합니다.</p>\n<p>컴파일러에게 이 관계를 지정하기 위해서, <code>\"rootDirs\"</code>를 사용합니다.\n<code>\"rootDirs\"</code>는 내용물이 런타임에 병합할 것으로 예상되는 <em>roots</em> 의 목록을 지정합니다.\n그래서 다음의 예제에서, <code>tsconfig.json</code> 파일은 다음과 같아야 합니다:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">json</div><div class='code-container'><code><div class='line'><span style=\"color: #000000\">{</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #0451A5\">\"compilerOptions\"</span><span style=\"color: #000000\">: {</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"rootDirs\"</span><span style=\"color: #000000\">: [</span></div><div class='line'><span style=\"color: #000000\">      </span><span style=\"color: #A31515\">\"src/views\"</span><span style=\"color: #000000\">,</span></div><div class='line'><span style=\"color: #000000\">      </span><span style=\"color: #A31515\">\"generated/templates/views\"</span></div><div class='line'><span style=\"color: #000000\">    ]</span></div><div class='line'><span style=\"color: #000000\">  }</span></div><div class='line'><span style=\"color: #000000\">}</span></div></code></div></pre>\n<p>컴파일러가 <code>rootDirs</code> 중 하나의 하위 폴더에서 상대적 모듈 import를 볼 때마다, 각 <code>rootDirs</code>의 엔트리에서 이 import를 찾으려고 할 것입니다.</p>\n<p><code>rootDirs</code>의 유연함은 논리적으로 병합되는 물리적 소스 디렉터리의 목록을 지정하는데 제한되지 않습니다. 제공되는 배열은 아마 존재 여부에 관계없이 임의의 수의 ad hoc, 임의의 디렉터리 이름을 포함할 수 있습니다. 이는 컴파일러에게 조건부 포함과 프로젝트 전용 로더 플러그인과 같은 복잡한 번들링과 런타임 기능을 안전한 방법으로 캡처할 수 있게 해줍니다.</p>\n<p><code>./#{locale}/messages</code>와 같은 상대 모듈 경로의 일부로 <code>#{locale}</code>와 같은 특수 경로 토큰을 보간하여 빌드 툴이 로케일 전용 번들을 자동으로 생성하는 국제화 시나리오를 고려해봅시다. 이 가상의 설정에서 툴이 지원하는 로케일을 열거하고, 추상 경로를 <code>./zh/messages</code>, <code>./de/messages</code> 등으로 매핑 합니다.</p>\n<p>각 모듈은 문자열 배열을 export 한다고 가정합니다. 예를 들어 <code>./zh/messages</code>는 다음을 포함합니다:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #AF00DB\">export</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">default</span><span style=\"color: #000000\"> [</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #A31515\">\"您好吗\"</span><span style=\"color: #000000\">,</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #A31515\">\"很高兴认识你\"</span></div><div class='line'><span style=\"color: #000000\">];</span></div></code></div></pre>\n<p><code>rootDirs</code>를 활용하여 컴파일러에게 이 매핑에 대해 알려주어 심지어 디렉터리가 존재하지 않아도 안전하게 <code>./#{locale}/messages</code>를 해석할 수 있도록 합니다. 예를 들어, 다음과 같은 <code>tsconfig.json</code>를 보십시오:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">json</div><div class='code-container'><code><div class='line'><span style=\"color: #000000\">{</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #0451A5\">\"compilerOptions\"</span><span style=\"color: #000000\">: {</span></div><div class='line'><span style=\"color: #000000\">    </span><span style=\"color: #0451A5\">\"rootDirs\"</span><span style=\"color: #000000\">: [</span></div><div class='line'><span style=\"color: #000000\">      </span><span style=\"color: #A31515\">\"src/zh\"</span><span style=\"color: #000000\">,</span></div><div class='line'><span style=\"color: #000000\">      </span><span style=\"color: #A31515\">\"src/de\"</span><span style=\"color: #000000\">,</span></div><div class='line'><span style=\"color: #000000\">      </span><span style=\"color: #A31515\">\"src/#{locale}\"</span></div><div class='line'><span style=\"color: #000000\">    ]</span></div><div class='line'><span style=\"color: #000000\">  }</span></div><div class='line'><span style=\"color: #000000\">}</span></div></code></div></pre>\n<p>컴파일러는 이제 ‘./#{locale}/messages’<code>를 './zh/messages'</code>로 해석하여 설계 시간 지원을 타협하지 않고 로케일에 관계없는 방법으로 개발할 수 있습니다.</p>\n<h2 id=\"모듈-해석-추적-tracing-module-resolution\" style=\"position:relative;\"><a href=\"#%EB%AA%A8%EB%93%88-%ED%95%B4%EC%84%9D-%EC%B6%94%EC%A0%81-tracing-module-resolution\" aria-label=\"모듈 해석 추적 tracing module resolution permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>모듈 해석 추적 (Tracing module resolution)</h2>\n<p>앞에서 논의한 바와 같이 컴파일러는 모듈을 해석할 때 현재 폴더 외부의 파일을 방문할 수 있습니다.\n이는 모듈이 해석되지 않거나 잘못된 정의로 해석된 이유를 진단할 때 어려울 수 있습니다.\n‘—traceResolution’을 사용하여 컴파일러 모듈 해석 추적을 활성화하면 모듈 해석 과정 중에 발생한 작업에 대한 인사이트를 얻을 수 있습니다.</p>\n<p><code>typescript</code> 모듈을 사용하는 예제 애플리케이션이 있다고 해봅시다.\n<code>app.ts</code>는 <code>import * as ts from \"typescript\"</code> 같은 import가 있습니다.</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class='code-container'><code>│   tsconfig.json\n├───node_modules\n│   └───typescript\n│       └───lib\n│               typescript.d.ts\n└───src\n        app.ts</code></div></pre><!-- Note from shiki-twoslash: the language tree was not set up for Shiki to use, and so there is no code highlighting --!>\n<p><code>--traceResolution</code>으로 컴파일러를 호출</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">shell</div><div class='code-container'><code><div class='line'><span style=\"color: #000000\">tsc --traceResolution</span></div></code></div></pre>\n<p>다음과 같은 출력이 발생:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">txt</div><div class='code-container'><code><div class='line'><span style=\"color: undefined\">======== Resolving module 'typescript' from 'src/app.ts'. ========\nModule resolution kind is not specified, using 'NodeJs'.\nLoading module 'typescript' from 'node_modules' folder.\nFile 'src/node_modules/typescript.ts' does not exist.\nFile 'src/node_modules/typescript.tsx' does not exist.\nFile 'src/node_modules/typescript.d.ts' does not exist.\nFile 'src/node_modules/typescript/package.json' does not exist.\nFile 'node_modules/typescript.ts' does not exist.\nFile 'node_modules/typescript.tsx' does not exist.\nFile 'node_modules/typescript.d.ts' does not exist.\nFound 'package.json' at 'node_modules/typescript/package.json'.\n'package.json' has 'types' field './lib/typescript.d.ts' that references 'node_modules/typescript/lib/typescript.d.ts'.\nFile 'node_modules/typescript/lib/typescript.d.ts' exist - use it as a module resolution result.\n======== Module name 'typescript' was successfully resolved to 'node_modules/typescript/lib/typescript.d.ts'. ========</span></div></code></div></pre>\n<h4 id=\"주의사항-things-to-look-out-for\" style=\"position:relative;\"><a href=\"#%EC%A3%BC%EC%9D%98%EC%82%AC%ED%95%AD-things-to-look-out-for\" aria-label=\"주의사항 things to look out for permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>주의사항 (Things to look out for)</h4>\n<ul>\n<li>import의 이름과 위치</li>\n</ul>\n<blockquote>\n<p>======== <strong>‘src/app.ts’</strong> 에서 <strong>‘typesciprt’</strong> 모듈 해석. ========</p>\n</blockquote>\n<ul>\n<li>컴파일러가 따르는 전략</li>\n</ul>\n<blockquote>\n<p>모듈 해석 종류가 지정되지 않으면, <strong>‘NodeJs</strong> 사용.</p>\n</blockquote>\n<ul>\n<li>npm 패키지에서 types 로딩</li>\n</ul>\n<blockquote>\n<p>‘package.json’은 ‘node_modules/typescript/lib/typescript.d.ts’를 참조하는 <strong>‘types’</strong> 필드 ‘./lib/typescript.d.ts’가 있습니다.</p>\n</blockquote>\n<ul>\n<li>최종 결과</li>\n</ul>\n<blockquote>\n<p>======== 모듈 이름 ‘typescript’는 ‘node_modules/typescript/lib/typescript.d.ts’로 <strong>성공적으로 해석</strong> 되었습니다. ========</p>\n</blockquote>\n<h2 id=\"--noresolve-사용하기-using---noresolve\" style=\"position:relative;\"><a href=\"#--noresolve-%EC%82%AC%EC%9A%A9%ED%95%98%EA%B8%B0-using---noresolve\" aria-label=\"  noresolve 사용하기 using   noresolve permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a><code>--noResolve</code> 사용하기 (Using <code>--noResolve</code>)</h2>\n<p>일반적으로 컴파일러는 컴파일 과정을 시작하기 전에 모든 모듈 import를 해석하려고 합니다.\n파일의 <code>import</code>를 성공적으로 해석할 때마다, 파일은 나중에 컴파일러가 처리할 파일 세트에 추가됩니다.</p>\n<p><code>--noResolve</code> 컴파일러 옵션은 명령 줄에 전달하지 않은 파일은 컴파일에 “추가” 하지 않도록 지시합니다.\n여전히 파일에 모듈을 해석하려고 하지만, 파일이 지정되지 않았으면, 그 파일은 포함하지 않습니다.</p>\n<p>예를 들어:</p>\n<h4 id=\"appts\" style=\"position:relative;\"><a href=\"#appts\" aria-label=\"appts permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>app.ts</h4>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">*</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">as</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">A</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"moduleA\"</span><span style=\"color: #000000\"> </span><span style=\"color: #008000\">// 성공, 'moduleA'가 명령줄로 전달됨</span></div><div class='line'><span style=\"color: #AF00DB\">import</span><span style=\"color: #000000\"> </span><span style=\"color: #0000FF\">*</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">as</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\">B</span><span style=\"color: #000000\"> </span><span style=\"color: #AF00DB\">from</span><span style=\"color: #000000\"> </span><span style=\"color: #A31515\">\"moduleB\"</span><span style=\"color: #000000\"> </span><span style=\"color: #008000\">// Error TS2307: Cannot find module 'moduleB.</span></div></code></div></pre>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">shell</div><div class='code-container'><code><div class='line'><span style=\"color: #000000\">tsc app.ts moduleA.ts --noResolve</span></div></code></div></pre>\n<p><code>--noResolve</code>를 사용한 <code>app.ts</code>의 컴파일은 다음과 같은 결과가 나옵니다:</p>\n<ul>\n<li>명령 줄로 전달했기 때문에 <code>moduleA</code>는 정확하게 찾음.</li>\n<li>전달하지 않았기 때문에 <code>moduleB</code>를 찾는데 실패함.</li>\n</ul>\n<h2 id=\"공통-질문-common-questions\" style=\"position:relative;\"><a href=\"#%EA%B3%B5%ED%86%B5-%EC%A7%88%EB%AC%B8-common-questions\" aria-label=\"공통 질문 common questions permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>공통 질문 (Common Questions)</h2>\n<h3 id=\"제외-목록에-있는-모듈을-여전히-컴파일러가-선택하는-이유는-무엇인가-why-does-a-module-in-the-exclude-list-still-get-picked-up-by-the-compiler\" style=\"position:relative;\"><a href=\"#%EC%A0%9C%EC%99%B8-%EB%AA%A9%EB%A1%9D%EC%97%90-%EC%9E%88%EB%8A%94-%EB%AA%A8%EB%93%88%EC%9D%84-%EC%97%AC%EC%A0%84%ED%9E%88-%EC%BB%B4%ED%8C%8C%EC%9D%BC%EB%9F%AC%EA%B0%80-%EC%84%A0%ED%83%9D%ED%95%98%EB%8A%94-%EC%9D%B4%EC%9C%A0%EB%8A%94-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80-why-does-a-module-in-the-exclude-list-still-get-picked-up-by-the-compiler\" aria-label=\"제외 목록에 있는 모듈을 여전히 컴파일러가 선택하는 이유는 무엇인가 why does a module in the exclude list still get picked up by the compiler permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>제외 목록에 있는 모듈을 여전히 컴파일러가 선택하는 이유는 무엇인가? (Why does a module in the exclude list still get picked up by the compiler?)</h3>\n<p><code>tsconfig.json</code>은 폴더를 “프로젝트”로 바꿉니다.\n<code>\"exclude\"</code> 나 <code>\"files\"</code> 엔트리를 지정하지 않으면, <code>tsconfig.json</code>를 포함하는 폴더 안의 모든 파일과 모든 하위-디렉터리가 컴파일에 포함됩니다.\n만약 일부 파일을 제외하고 싶으면 <code>\"exclude\"</code>를 사용하고, 컴파일러가 찾도록 하게 하는 대신 모든 파일을 지정하고 싶으면, <code>\"files\"</code>를 사용하십시오.</p>\n<p><code>tsconfig.json</code>의 자동 포함입니다.\n위에서 논의한 내장 모듈 해석이 아닙니다.\n컴파일러는 파일을 모듈 import 대상으로 식별한 경우, 이전 단계에서 제외되었는지에 관계없이 컴파일에 포함하게 됩니다.</p>\n<p>그래서 컴파일에 파일은 제외하기 위해서는, 그 파일을 제외하고 그 파일에 <code>import</code>나 <code>/// &#x3C;reference path=\"...\"\" /></code> 지시문이 있는 <strong>모든</strong> 파일을 제외해야 합니다.</p>","headings":[{"value":"상대적 vs. 비-상대적 모듈 import (Relative vs. Non-relative module imports)","depth":2},{"value":"모듈 해석 전략 (Module Resolution Strategies)","depth":2},{"value":"클래식 (Classic)","depth":3},{"value":"노드 (Node)","depth":3},{"value":"Node.js가 모듈을 해석하는 방법 (How Node.js resolves modules)","depth":4},{"value":"TypeScript가 모듈을 해석하는 방법 (How TypeScript resolves modules)","depth":4},{"value":"추가 모듈 해석 플래그 (Additional module resolution flags)","depth":2},{"value":"기본 URL (Base URL)","depth":3},{"value":"경로 매핑 (Path mapping)","depth":3},{"value":"rootDirs 가상 디렉터리 (Virtual Directories with rootDirs)","depth":3},{"value":"모듈 해석 추적 (Tracing module resolution)","depth":2},{"value":"주의사항 (Things to look out for)","depth":4},{"value":"--noResolve 사용하기 (Using --noResolve)","depth":2},{"value":"app.ts","depth":4},{"value":"공통 질문 (Common Questions)","depth":2},{"value":"제외 목록에 있는 모듈을 여전히 컴파일러가 선택하는 이유는 무엇인가? (Why does a module in the exclude list still get picked up by the compiler?)","depth":3}],"frontmatter":{"permalink":"/ko/docs/handbook/module-resolution.html","title":"Module Resolution","disable_toc":null,"handbook":null,"oneline":"How TypeScript resolves modules in JavaScript","preamble":null,"deprecated_by":null,"deprecation_redirects":null,"experimental":null}},"prev":null,"next":null},"pageContext":{"slug":"/ko/docs/handbook/module-resolution.html","repoPath":"/packages/documentation/copy/ko/reference/Module Resolution.md","lang":"ko","modifiedTime":"2024-10-21T12:35:09.561Z"}},"staticQueryHashes":[]}