{"componentChunkName":"component---src-templates-play-example-tsx","path":"/pt/play/4-1/template-literals/mapped-types-with-template-literals.ts.html","result":{"pageContext":{"name":"Mapped Types with Template Literals","title":"Mapped Types with Template Literals","lang":"pt","html":"\n O TypeScript 4.1 adiciona suporte para as template literals, você pode\n aprender os conceitos básicos em intro-to-template-literals\n\n A 4.1 introduz uma nova sintaxe dentro declaração mapeada de tipos,\n agora você pode utilizar \"as `templated string`\" que pode ser utilizado para transformar\n strings dentro de uma união.\n\n Por exemplo, este tipo irá transformar todas as propriedades de um tipo existente\n em quatro funções que correspondem a chamadas REST tradicionais.\n\n String literals template para descrever cada endpoint da API:\n<code><pre>\ntype GET<T extends string> =  `get${Capitalize<T>}`\ntype POST<T extends string> =  `post${ Capitalize<T>}`\ntype PUT<T extends string> =  `put${ Capitalize<T>}`\ntype DELETE<T extends string> =  `delete${ Capitalize<T>}`\n\n// Uma união dos tipos literais acima\ntype REST<T extends string> = GET<T> | POST<T> | PUT<T> | DELETE<T>\n\n</pre></code>\n// Pega um tipo, então para cada propriedade da string no tipo, mapeia\n esta chave para a REST acima, que criaria as quatro funções.\n\n<code><pre>\ntype RESTify<Type> = {\n  [Key in keyof Type as REST<Key extends string ? Key : never>]: () => Type[Key]\n};\n\n</pre></code>\n// A expressão `Key extends string ? Key : never` é necessária porque um objeto\n pode conter strings, números e símbolos como chaves. Podemos manipular somente \n os casos de chaves string aqui.\n\n Agora temos uma lista de objetos disponíveis através da API:\n\n<code><pre>\ninterface APIs {\n  artwork: { id: string, title: string};\n  artist: { id: string, name: string};\n  location: { id: string, address: string, country: string }\n}\n\n// Entao quanto temos um objeto que usa estes tipos\ndeclare const api: RESTify<APIs>\n\n// Então todas estas funções são criadas automaticamente \napi.getArtist()\napi.postArtist()\napi.putLocation()\n\n</pre></code>\n// Continue aprendendo mais sobre template literals em:\n string-manipulation-with-template-literals\n\n Ou leia o artigo em nosso blog:\n https://devblogs.microsoft.com/typescript/announcing-typescript-4-1-beta/#template-literal-types\n","redirectHref":"pt/play/?#example/mapped-types-with-template-literals"}},"staticQueryHashes":[]}