{"componentChunkName":"component---src-templates-play-example-tsx","path":"/pt/play/4-1/template-literals/string-manipulation-with-template-literals.ts.html","result":{"pageContext":{"name":"String Manipulation with Template Literals","title":"String Manipulation with Template Literals","lang":"pt","html":"\n Template literals podem ser utilizados para extrair e manipular tipos de strings literais.\n Estes tipos de string literal, por sua vez, podem ser usados como propriedades, e podem descrever\n possíveis transformações de uma string para um objeto em uma API.\n\n ## Dividindo uma string para um Objeto\n\n Template literals podem utilizar padrões como \"pontos-de-divisão\" para inferir as\n substrings necessárias. Por exemplo...\n\n Este tipo é uma string literal que conforma com uma string padrão SemVer.\n<code><pre>\ntype TSVersion = \"4.1.2\"\n\n</pre></code>\n// Podemos criar um tipo para extrair os componentes desta string.\n Vamos dividir em dois caracteres '.'.\n<code><pre>\ntype ExtractSemver<SemverString extends string> =\n  SemverString extends `${infer Major}.${ infer Minor }.${ infer Patch } ` ? \n        { major: Major, minor: Minor, patch: Patch } : { error: \"Cannot parse semver string\" }\n\n</pre></code>\n// A linha 1 deve lhe parecer familiar se você observou os exemplos anteriores:\n intro-to-template-literals / mapped-types-with-template-literals\n\n A linha 2 é um tipo condicional, o TypeScript valida que o padrão de inferência combina\n com o parâmetro SemverString.\n\n A linha3 é o resultado da condição, se verdadeiro então resulta em um objeto\n com as substrings informadas em diferentes posições em um objeto. Se a string \n não corresponder, então retorna o tipo com uma formatação de erro.\n\n<code><pre>\ntype TS = ExtractSemver<TSVersion>\n\n// Isto não representa um SemVer 100%, como no exemplo:\ntype BadSemverButOKString = ExtractSemver<\"4.0.Four.4444\">\n\n</pre></code>\n// Entretanto, o ExtractSemver irá falhar em strings que não tiverem o formato correto. Este caso\n só irá funcionar quando a string tiver o formato \"X.Y.Z\", que na linha abaixo não tem:\n<code><pre>\ntype SemverError = ExtractSemver<\"Four point Zero point Five\">\n\n// ## Divisão Recursiva de String\n\n</pre></code>\n// O exemplo anterior vai funcionar somente quando você tiver uma string exata para comparar,\n para os demais casos você deverá utilizar a feature do TypeScript 4.0: tuplas-variáveis.\n\n Para dividir uma string em componentes reutilizáveis, Tuplas são uma boa maneira para manter\n o registro dos resultados. Aqui temos um tipo de Split:\n\n<code><pre>\ntype Split<S extends string, D extends string> =\n    string extends S ? string[] :\n        S extends '' ? [] :\n            S extends `${ infer T } ${ D } ${ infer U } ` ?  [T, ...Split<U, D>] :  [S];\n\n</pre></code>\n// A linha 1 declara dois parâmetros, iremos utilizar um único caractere por abreviação\n S representa a string por dividir, e D o delimitador. Esta\n linha garante que ambas são strings.\n\n A linha 2 verifica se a string é literal, checando se uma string usual\n pode ser estendida de uma string de entrada. Caso sim, retorna um array de strings. Não\n podemos utilizar com strings não literais.\n\n Por exemplo neste caso:\n<code><pre>\ntype S1 = Split<string, \".\">\n\n// A linha 3 verifica se a string está vazia, Caso sim retorna uma tupla vazia\ntype S2 = Split<\"\", \".\">\n\n</pre></code>\n// A linha 4 possui uma verificação similar a nossa ExtractSemver. Se a string combina com\n `[Prefix as T][Deliminator][Suffix as U]` então extrai o prefixo (T) no\n primeiro parâmetro da tupla, executa novamente a divisão no sufixo (U) para garantir\n que mais de uma combinação pode ser encontrada.\n\n Se a string não incluir um delimitador, então retorna uma tupla de comprimento 1 \n que contém a string passada como argumento (S).\n\n Caso simples\n<code><pre>\ntype S3 = Split<\"1.2\", \".\">\n\n// Irá executar recursivamente até ter todos os .'s divididos\ntype S4 = Split<\"1.2.3\", \".\">\n\n\n</pre></code>\n// Com este conhecimento, você deve ser capaz de ler e entender um pouco\n dos exemplos da comunidade sobre template literals, por exemplo:\n\n - Um extrator de rotas express por Dan Vanderkam\n https://twitter.com/danvdk/status/1301707026507198464\n\n - Uma definição de document.querySelector por Mike Ryan\n https://twitter.com/mikeryandev/status/1308472279010025477\n\n Algumas pessoas também expirementaram exemplos mais complexos de analisadores de strings \n utilizando string template literals, o que é interessante - mas não recomendado para\n códigos em ambientes de produção.\n\n https://github.com/ghoullier/awesome-template-literal-types\n \n Ou leia o artigo em nosso blog:\n https://devblogs.microsoft.com/typescript/announcing-typescript-4-1-beta/#template-literal-types\n","redirectHref":"pt/play/?#example/string-manipulation-with-template-literals"}},"staticQueryHashes":[]}