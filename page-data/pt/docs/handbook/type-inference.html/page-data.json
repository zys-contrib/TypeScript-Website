{"componentChunkName":"component---src-templates-documentation-tsx","path":"/pt/docs/handbook/type-inference.html","result":{"data":{"markdownRemark":{"id":"73e8573e-cc94-571c-b713-18fb8af74543","excerpt":"Em TypeScript, existem vários locais onde a inferência de tipos é usada para prover informação quando não se tem um tipo explícito de anotação. Por exemplo…","html":"<p>Em TypeScript, existem vários locais onde a inferência de tipos é usada para prover informação quando não se tem um tipo explícito de anotação. Por exemplo, nesse código</p>\n<pre class=\"shiki light-plus twoslash lsp\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\"><data-lsp lsp='let x: number' style='border-bottom: solid 2px lightgrey;'>x</data-lsp></span><span style=\"color: #000000\"> = </span><span style=\"color: #098658\">3</span><span style=\"color: #000000\">;</span></div><div class='meta-line'><span class='popover-prefix'>   </span><span class='popover'><div class='arrow'></div>let x: number</span></div></code><a class='playground-link' href='https://www.typescriptlang.org/play/#code/DYUwLgBAHhC8EGYDcAoA9GiEB6B+IA'>Try</a></div></pre>\n<p>O tipo da variável <code>x</code> é inferido como sendo <code>number</code>.\nEsse tipo de inferência ocorre ao inicializar variáveis e membros, definir valores padrão de parâmetros e ao determinar o tipo de valor retornado por funções.</p>\n<p>Na maioria dos casos, inferência de tipos é fácil de entender.\nNa próxima sessão, iremos explorar algumas das nuances em como tipos são inferidos.</p>\n<h2 id=\"melhor-tipo-comum\" style=\"position:relative;\"><a href=\"#melhor-tipo-comum\" aria-label=\"melhor tipo comum permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Melhor tipo comum</h2>\n<p>Quando uma inferência de tipo é composta por várias expressões, o tipo dessas expressões é usada para calcular o “melhor tipo comum”. Por exemplo:</p>\n<pre class=\"shiki light-plus twoslash lsp\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\"><data-lsp lsp='let x: (number | null)[]' style='border-bottom: solid 2px lightgrey;'>x</data-lsp></span><span style=\"color: #000000\"> = [</span><span style=\"color: #098658\">0</span><span style=\"color: #000000\">, </span><span style=\"color: #098658\">1</span><span style=\"color: #000000\">, </span><span style=\"color: #0000FF\">null</span><span style=\"color: #000000\">];</span></div><div class='meta-line'><span class='popover-prefix'>   </span><span class='popover'><div class='arrow'></div>let x: (number | null)[]</span></div></code><a class='playground-link' href='https://www.typescriptlang.org/play/#code/DYUwLgBAHhC8EG0AMAaCBGNA7ArsYAugNwBQA9GRBAHoD8QA'>Try</a></div></pre>\n<p>Para inferir o tipo de <code>x</code> no exemplo acima, nós precisamos considerar o tipo de cada elemento do array.\nAqui nos foi dada duas escolhas para o tipo do array: <code>number</code> e <code>null</code>.\nO algoritmo do melhor tipo comum considera o tipo de cada candidato e escolhe o tipo que é compatível com todos os outros candidatos.</p>\n<p>Porquê o melhor tipo comum tem de ser escolhido a partir dos tipos candidatos providos, existem alguns casos onde tipos compartilham uma estrutura comum, mas nenhum tipo é o supertipo de todos os tipos candidatos. Por Exemplo:</p>\n<pre class=\"shiki light-plus twoslash lsp\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\"><data-lsp lsp='let zoo: (Rinoceronte | Elefante | Cobra)[]' style='border-bottom: solid 2px lightgrey;'>zoo</data-lsp></span><span style=\"color: #000000\"> = [</span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\"><data-lsp lsp='constructor Rinoceronte(): Rinoceronte' >Rinoceronte</data-lsp></span><span style=\"color: #000000\">(), </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\"><data-lsp lsp='constructor Elefante(): Elefante' >Elefante</data-lsp></span><span style=\"color: #000000\">(), </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\"><data-lsp lsp='constructor Cobra(): Cobra' >Cobra</data-lsp></span><span style=\"color: #000000\">()];</span></div><div class='meta-line'><span class='popover-prefix'>    </span><span class='popover'><div class='arrow'></div>let zoo: (Rinoceronte | Elefante | Cobra)[]</span></div></code><a class='playground-link' href='https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgCCAdvALY6gDeAvkSWaAErxUD2ieWLyrQ8oPAA9RVACblqdBowKhQo2gGEAFvHSw8aOAFc8AbgKtipcgFFseLCLGTpcyjXrYmKtXloAVIVoAI0xDWBNzS3ZyDV5g2ExxKTxZeQ8lH3UABUEqUjQsXDMLAhBQAFoqxCNoKoqCe2hQAC9eXlAAXlAAbSo8AHcuHn5BYVEACgBKABpQfqG7B0wnabmF0DiEzGmAXXNy1VAAPQB+IA'>Try</a></div></pre>\n<p>De forma ideal, queremos que <code>zoo</code> seja inferido como um <code>Animal[]</code>, mas como não existe um objeto que seja estritamente do tipo <code>Animal</code> no array, nós não fazemos inferências sobre o tipo de elemento do array.\nPara corrigir isso, em troca forneça explicitamente o tipo quando nenhum outro tipo é um supertipo de todos os outros candidatos:</p>\n<pre class=\"shiki light-plus twoslash lsp\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #0000FF\">let</span><span style=\"color: #000000\"> </span><span style=\"color: #001080\"><data-lsp lsp='let zoo: Animal[]' style='border-bottom: solid 2px lightgrey;'>zoo</data-lsp></span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\"><data-lsp lsp='class Animal' >Animal</data-lsp></span><span style=\"color: #000000\">[] = [</span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\"><data-lsp lsp='constructor Rinoceronte(): Rinoceronte' >Rinoceronte</data-lsp></span><span style=\"color: #000000\">(), </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\"><data-lsp lsp='constructor Elefante(): Elefante' >Elefante</data-lsp></span><span style=\"color: #000000\">(), </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\"><data-lsp lsp='constructor Cobra(): Cobra' >Cobra</data-lsp></span><span style=\"color: #000000\">()];</span></div><div class='meta-line'><span class='popover-prefix'>    </span><span class='popover'><div class='arrow'></div>let zoo: Animal[]</span></div></code><a class='playground-link' href='https://www.typescriptlang.org/play/#code/PTAEAEGcBcCcEsDG0BcoBmBDANpApgFCLaaSSgCCAdvALY6gDeAvkSWaAErxUD2ieWLyrQ8oPAA9RVACblqdBowKhQo2gGEAFvHSw8aOAFc8AbgKtipcgFFseLCLGTpcyjXrYmKtXloAVIVoAI0xDWBNzS3ZyDV5g2ExxKTxZeQ8lH3UABUEqUjQsXDMLAhBQAFoqxCNoKoqCe2hQAC9eXjQFTwBtAF1QAF5Qbqo8AHcuHn5BYVEACgBKABpQUYm7B0wnRZW10DiEzEXe83LVUAA9AH4gA'>Try</a></div></pre>\n<p>Quando nenhum tipo comum é encontrado, a inferência resultante é a união dos tipos do array, <code>(Rinoceronte | Elefante | Cobra)[]</code>.</p>\n<h2 id=\"tipagem-contextual\" style=\"position:relative;\"><a href=\"#tipagem-contextual\" aria-label=\"tipagem contextual permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Tipagem Contextual</h2>\n<p>Inferência de tipo também funciona “em direção oposta” em alguns casos no TypeScript.\nIsso é conhecido como “tipagem contextual”. Tipagem contextual ocorre quando o tipo de uma expressão é inferido por sua localização. Por exemplo:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #001080\">window</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">onmousedown</span><span style=\"color: #000000\"> = </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> (</span><span style=\"color: #001080\">mouseEvent</span><span style=\"color: #000000\">) {</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">mouseEvent</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">botao</span><span style=\"color: #000000\">); </span><span style=\"color: #008000\">//&lt;- OK</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">mouseEvent</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">canguru</span><span style=\"color: #000000\">); </span><span style=\"color: #008000\">//&lt;- Error!</span></div><div class='line'><span style=\"color: #000000\">};</span></div></code></div></pre>\n<p>Aqui, o verificador de tipos do TypeScript usa o tipo da função <code>Window.onmousedown</code> para inferir o tipo da expressão função do lado direito da atribuição.\nAo fazer isso, ele foi capaz de inferir o <a href=\"https://developer.mozilla.org/docs/Web/API/MouseEvent\">tipo</a> do parâmetro <code>mouseEvent</code>, que de fato contém uma propriedade <code>botao</code>, mas não uma propriedade <code>canguru</code>.</p>\n<p>TypeScript é inteligente o suficiente para inferir tipos em outros contextos também:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #001080\">window</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">onscroll</span><span style=\"color: #000000\"> = </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> (</span><span style=\"color: #001080\">uiEvent</span><span style=\"color: #000000\">) {</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">uiEvent</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">botao</span><span style=\"color: #000000\">); </span><span style=\"color: #008000\">//&lt;- Erro!</span></div><div class='line'><span style=\"color: #000000\">};</span></div></code></div></pre>\n<p>Baseado no fato que a função acima foi atribuida a <code>Window.onscroll</code>, TypeScript sabe que <code>uiEvent</code> é um <a href=\"https://developer.mozilla.org/docs/Web/API/UIEvent\">UIEvent</a>, e não um <a href=\"https://developer.mozilla.org/docs/Web/API/MouseEvent\">MouseEvent</a> como no exemplo anterior. Objetos <code>UIEvent</code> não contém a propriedade <code>botao</code>, dessa forma TypeScript irá lançar um erro.</p>\n<p>Se essa função não estivesse digitada em uma posição contextualizada, os argumentos da função teriam implicitamente o tipo <code>any</code>, e nenhum erro seria emitido (a não ser que você esteja usando a opção <code>--noImplicitAny</code>):</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #0000FF\">const</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">handler</span><span style=\"color: #000000\"> = </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> (</span><span style=\"color: #001080\">uiEvent</span><span style=\"color: #000000\">) {</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">uiEvent</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">botao</span><span style=\"color: #000000\">); </span><span style=\"color: #008000\">//&lt;- OK</span></div><div class='line'><span style=\"color: #000000\">};</span></div></code></div></pre>\n<p>Nós também podemos fornecer explicitamente informação sobre o tipo para que os argumentos da função sobrescrevam qualquer tipo contextual:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #001080\">window</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">onscroll</span><span style=\"color: #000000\"> = </span><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> (</span><span style=\"color: #001080\">uiEvent</span><span style=\"color: #000000\">: </span><span style=\"color: #1C6277\">any</span><span style=\"color: #000000\">) {</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #001080\">console</span><span style=\"color: #000000\">.</span><span style=\"color: #795E26\">log</span><span style=\"color: #000000\">(</span><span style=\"color: #001080\">uiEvent</span><span style=\"color: #000000\">.</span><span style=\"color: #001080\">botao</span><span style=\"color: #000000\">); </span><span style=\"color: #008000\">//&lt;- Agora, nenhum erro é fornecido</span></div><div class='line'><span style=\"color: #000000\">};</span></div></code></div></pre>\n<p>Entretanto, esse código será exibido no log como <code>undefined</code>, uma vez que <code>uiEvent</code> não tem nenhuma propriedade <code>botao</code>.</p>\n<p>Tipagem contextual se aplica em muitos casos.\nCasos comuns incluem argumentos para chamadas de funções, lado direito de atribuições, asserções de tipo, membros de objetos, arrays literais, e declarações de retorno.\nO tipo contextual também age como um tipo candidato no melhor tipo comum. Por exemplo:</p>\n<pre class=\"shiki light-plus\" style=\"background-color: #FFFFFF; color: #000000\"><div class=\"language-id\">ts</div><div class='code-container'><code><div class='line'><span style=\"color: #0000FF\">function</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">criaZologico</span><span style=\"color: #000000\">(): </span><span style=\"color: #1C6277\">Animal</span><span style=\"color: #000000\">[] {</span></div><div class='line'><span style=\"color: #000000\">  </span><span style=\"color: #AF00DB\">return</span><span style=\"color: #000000\"> [</span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">Rinoceronte</span><span style=\"color: #000000\">(), </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">Elefante</span><span style=\"color: #000000\">(), </span><span style=\"color: #0000FF\">new</span><span style=\"color: #000000\"> </span><span style=\"color: #795E26\">Cobra</span><span style=\"color: #000000\">()];</span></div><div class='line'><span style=\"color: #000000\">}</span></div></code></div></pre>\n<p>Nesse exemplo, o melhor tipo comum tem um grupo de quatro candidatos: <code>Animal</code>, <code>Rinoceronte</code>, <code>Elefante</code>, e <code>Cobra</code>.\nDesses, <code>Animal</code> pode ser escolhido pelo algorítimo de melhor candidato comum.</p>","headings":[{"value":"Melhor tipo comum","depth":2},{"value":"Tipagem Contextual","depth":2}],"frontmatter":{"permalink":"/pt/docs/handbook/type-inference.html","title":"Inferência de Tipo","disable_toc":null,"handbook":null,"oneline":"Como a analise do fluxo de código funciona em TypeScript","preamble":null,"deprecated_by":null,"deprecation_redirects":null,"experimental":null}},"prev":null,"next":null},"pageContext":{"id":"2-inferência-de-tipo","slug":"/pt/docs/handbook/type-inference.html","repoPath":"/packages/documentation/copy/pt/reference/Type Inference.md","lang":"pt","modifiedTime":"2024-10-21T12:35:09.573Z"}},"staticQueryHashes":[]}