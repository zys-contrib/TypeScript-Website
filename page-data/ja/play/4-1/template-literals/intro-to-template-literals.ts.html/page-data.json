{"componentChunkName":"component---src-templates-play-example-tsx","path":"/ja/play/4-1/template-literals/intro-to-template-literals.ts.html","result":{"pageContext":{"name":"Intro to Template Literals","title":"Intro to Template Literals","lang":"ja","html":"\n TypeScriptでは、すでに厳密な文字列/数値をリテラルとして\n 扱うことができます。例えば、次の関数は厳密な文字列を\n 2つだけ許可し、それ以外は許可しません。\n\n<code><pre>\ndeclare function enableFeature(command: \"redesign\" | \"newArtistPage\"): void;\nenableFeature(\"redesign\");\nenableFeature(`newArtistPage`);\nenableFeature(\"newPaymentSystem\");\n\n</pre></code>\n// 文字列リテラルはES2020で記述できるすべての文字列の記述方法をサポートしています。\n さらに、TypeScript 4.1では、サポートを拡張し、\n テンプレート文字列リテラルへの文字列挿入ができるようになりました。\n\n<code><pre>\ntype Features = \"Redesign\" | \"newArtistPage\";\n\n</pre></code>\n// 次の型は上記のUnion型であるFeaturesを使用し、\n Union型の各要素を変換して文字列の後ろに`-branch`を追加します。\n<code><pre>\ntype FeatureBranch = `${Features}-branch`;\n\n</pre></code>\n// 4.1では、文字列を操作するためにテンプレートリテラル内で使用できる\n ジェネリクスのような新しいキーワードのセットをサポートしています。\n そのキーワードとは、Uppercase、Lowercase、Capitalize、Uncapitalizeです。\n\n<code><pre>\ntype FeatureID = `${Lowercase<Features>}-id`;\ntype FeatureEnvVar = `${Uppercase<Features>}-ID`;\n\n</pre></code>\n// Union型を構成する文字列は掛け合わされます。\n したがって、複数のUnion型を使用した場合、Union型を構成するそれぞれの型は、\n 他のUnion型を構成するそれぞれの型に対して評価されます。\n\n<code><pre>\ntype EnabledStates = \"enabled\" | \"disabled\";\ntype FeatureUIStrings = `${Features} is ${EnabledStates}`;\n\n</pre></code>\n// このことにより、それぞれのUnion型の要素の\n すべての可能な組み合わせが考慮されることが保証されます。\n\n 次の型では、インデックスシグネチャと併用することで\n プロパティキーのリストを素早く作成することができます。\n\n<code><pre>\ntype SetFeatures = {\n  [K in FeatureID]: boolean\n};\n\n</pre></code>\n// テンプレートリテラルについて続けて学ぶ場合はこちらを参照してください:\n example:mapped-types-with-template-literals\n\n もしくはこちらの告知ブログ記事をご覧ください:\n https://devblogs.microsoft.com/typescript/announcing-typescript-4-1-beta/#template-literal-types\n","redirectHref":"ja/play/?ts=4.1.0-dev.20201028#example/intro-to-template-literals"}},"staticQueryHashes":[]}