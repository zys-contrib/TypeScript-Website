{"componentChunkName":"component---src-templates-play-example-tsx","path":"/ja/play/3-7/types-and-code-flow/recursive-type-references.ts.html","result":{"pageContext":{"name":"Recursive Type References","title":"Recursive Type References","lang":"ja","html":"\n タイプを使うかインターフェースを使うかはそれぞれの機能の制約に依るところがあります。\n 3.7では、type aliasに関する制約のうち、interfaceにはない制約が削除\n されました。\n\n これについての詳細はexample:types-vs-interfacesを参照してください。\n\n 以前は、定義している型自体の内部で\n 定義している型を参照することはできませんでした。\n これはインターフェースには存在しない制約であり、\n 回避するには少しの手間が必要でした。\n\n 例えば、以下は3.6では実行できません:\n<code><pre>\ntype ValueOrArray<T> = T | Array<ValueOrArray<T>>;\n\n</pre></code>\n// type aliasとinterfaceを組み合わせた回避策は\n 次のようなものでした。\n<code><pre>\ntype ValueOrArray2<T> = T | ArrayOfValueOrArray<T>;\ninterface ArrayOfValueOrArray<T> extends Array<ValueOrArray2<T>> {}\n\n</pre></code>\n// この制約の削除により、自身を参照することでJSONを包括的に\n 定義できます。\n\n<code><pre>\ntype Json = string | number | boolean | null | Json[] | { [key: string]: Json };\n\nconst exampleStatusJSON: Json = {\n  available: true,\n  username: \"Jean-loup\",\n  room: {\n    name: \"Highcrest\",\n    // Json型に関数を追加できない\n    // update: () => {}\n  },\n};\n\n</pre></code>\n// 3.7ベータ版のリリースノートとPRでより多くのことが学べます:\n\n https://devblogs.microsoft.com/typescript/announcing-typescript-3-7/\n https://github.com/microsoft/TypeScript/pull/33050\n","redirectHref":"ja/play/?#example/recursive-type-references"}},"staticQueryHashes":[]}